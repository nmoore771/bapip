//
// Generated by Bluespec Compiler, version 2015.09.beta2 (build 34689, 2015-09-07)
//
// On Sat May 21 12:31:55 EDT 2016
//
//
// Ports:
// Name                         I/O  size props
// set_Alarms                     O     1
// RDY_set_Alarms                 O     1 const
// get_q                          O     1
// RDY_get_q                      O     1 const
// get_qh                         O     1 reg
// RDY_get_qh                     O     1 const
// get_ql                         O     1 reg
// RDY_get_ql                     O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// set_Alarms_x                   I    16
// set_Alarms_h                   I    16
// set_Alarms_l                   I    16
// set_Alarms_eps                 I    16
// EN_set_Alarms                  I     1
//
// Combinational paths from inputs to outputs:
//   (set_Alarms_x,
//    set_Alarms_h,
//    set_Alarms_l,
//    set_Alarms_eps,
//    EN_set_Alarms) -> set_Alarms
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkLIMITS_ALARM(CLK,
		      RST_N,

		      set_Alarms_x,
		      set_Alarms_h,
		      set_Alarms_l,
		      set_Alarms_eps,
		      EN_set_Alarms,
		      set_Alarms,
		      RDY_set_Alarms,

		      get_q,
		      RDY_get_q,

		      get_qh,
		      RDY_get_qh,

		      get_ql,
		      RDY_get_ql);
  input  CLK;
  input  RST_N;

  // actionvalue method set_Alarms
  input  [15 : 0] set_Alarms_x;
  input  [15 : 0] set_Alarms_h;
  input  [15 : 0] set_Alarms_l;
  input  [15 : 0] set_Alarms_eps;
  input  EN_set_Alarms;
  output set_Alarms;
  output RDY_set_Alarms;

  // value method get_q
  output get_q;
  output RDY_get_q;

  // value method get_qh
  output get_qh;
  output RDY_get_qh;

  // value method get_ql
  output get_ql;
  output RDY_get_ql;

  // signals for module outputs
  wire RDY_get_q,
       RDY_get_qh,
       RDY_get_ql,
       RDY_set_Alarms,
       get_q,
       get_qh,
       get_ql,
       set_Alarms;

  // ports of submodule high_alarm
  wire [15 : 0] high_alarm$set_Inputs_eps,
		high_alarm$set_Inputs_xin1,
		high_alarm$set_Inputs_xin2;
  wire high_alarm$EN_set_Inputs, high_alarm$get_q, high_alarm$set_Inputs;

  // ports of submodule low_alarm
  wire [15 : 0] low_alarm$set_Inputs_eps,
		low_alarm$set_Inputs_xin1,
		low_alarm$set_Inputs_xin2;
  wire low_alarm$EN_set_Inputs, low_alarm$get_q, low_alarm$set_Inputs;

  // rule scheduling signals
  wire CAN_FIRE_set_Alarms, WILL_FIRE_set_Alarms;

  // remaining internal signals
  wire [15 : 0] IF_set_Alarms_eps_BIT_15_THEN_NEG_IF_set_Alarm_ETC___d6,
		x__h448;

  // actionvalue method set_Alarms
  assign set_Alarms = high_alarm$set_Inputs || low_alarm$set_Inputs ;
  assign RDY_set_Alarms = 1'd1 ;
  assign CAN_FIRE_set_Alarms = 1'd1 ;
  assign WILL_FIRE_set_Alarms = EN_set_Alarms ;

  // value method get_q
  assign get_q = high_alarm$get_q || low_alarm$get_q ;
  assign RDY_get_q = 1'd1 ;

  // value method get_qh
  assign get_qh = high_alarm$get_q ;
  assign RDY_get_qh = 1'd1 ;

  // value method get_ql
  assign get_ql = low_alarm$get_q ;
  assign RDY_get_ql = 1'd1 ;

  // submodule high_alarm
  mkHYSTERESIS high_alarm(.CLK(CLK),
			  .RST_N(RST_N),
			  .set_Inputs_eps(high_alarm$set_Inputs_eps),
			  .set_Inputs_xin1(high_alarm$set_Inputs_xin1),
			  .set_Inputs_xin2(high_alarm$set_Inputs_xin2),
			  .EN_set_Inputs(high_alarm$EN_set_Inputs),
			  .set_Inputs(high_alarm$set_Inputs),
			  .RDY_set_Inputs(),
			  .get_q(high_alarm$get_q),
			  .RDY_get_q());

  // submodule low_alarm
  mkHYSTERESIS low_alarm(.CLK(CLK),
			 .RST_N(RST_N),
			 .set_Inputs_eps(low_alarm$set_Inputs_eps),
			 .set_Inputs_xin1(low_alarm$set_Inputs_xin1),
			 .set_Inputs_xin2(low_alarm$set_Inputs_xin2),
			 .EN_set_Inputs(low_alarm$EN_set_Inputs),
			 .set_Inputs(low_alarm$set_Inputs),
			 .RDY_set_Inputs(),
			 .get_q(low_alarm$get_q),
			 .RDY_get_q());

  // submodule high_alarm
  assign high_alarm$set_Inputs_eps =
	     IF_set_Alarms_eps_BIT_15_THEN_NEG_IF_set_Alarm_ETC___d6 ;
  assign high_alarm$set_Inputs_xin1 = set_Alarms_x ;
  assign high_alarm$set_Inputs_xin2 =
	     set_Alarms_h -
	     IF_set_Alarms_eps_BIT_15_THEN_NEG_IF_set_Alarm_ETC___d6 ;
  assign high_alarm$EN_set_Inputs = EN_set_Alarms ;

  // submodule low_alarm
  assign low_alarm$set_Inputs_eps =
	     IF_set_Alarms_eps_BIT_15_THEN_NEG_IF_set_Alarm_ETC___d6 ;
  assign low_alarm$set_Inputs_xin1 =
	     set_Alarms_l +
	     IF_set_Alarms_eps_BIT_15_THEN_NEG_IF_set_Alarm_ETC___d6 ;
  assign low_alarm$set_Inputs_xin2 = set_Alarms_x ;
  assign low_alarm$EN_set_Inputs = EN_set_Alarms ;

  // remaining internal signals
  assign IF_set_Alarms_eps_BIT_15_THEN_NEG_IF_set_Alarm_ETC___d6 =
	     set_Alarms_eps[15] ? -x__h448 : x__h448 ;
  assign x__h448 =
	     (set_Alarms_eps[15] ? -set_Alarms_eps : set_Alarms_eps) >> 1 ;
endmodule  // mkLIMITS_ALARM

