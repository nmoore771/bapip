
==================== FINAL INTERFACE ====================
2022-04-26 14:29:47.769765243 UTC

interface BAPIP-0.1.0.0-IeoLXJJUcqyHz2cFv4cIMD:PVSGenerator 8022
  interface hash: 267c0d626f7f2b46231b2211567860f6
  ABI hash: b951ab9844c1b33612ee7cc1b8b1f41a
  export-list hash: 365c2a1307dc17ef5f7bd2b855d9893b
  orphan hash: 9ee2057e251a3aed47246abb67d9a258
  flag hash: aa1a6078e28560b315026c49539ca393
  sig of: Nothing
  used TH splices: False
  where
exports:
  PVSGenerator.addPreIfMissing
  PVSGenerator.addPreIfMissing'
  PVSGenerator.addSuffix
  PVSGenerator.addVectExptoID
  PVSGenerator.args2LVars
  PVSGenerator.argsMatch
  PVSGenerator.badType
  PVSGenerator.branchTest
  PVSGenerator.checkForSynonyms
  PVSGenerator.constructInvokationTree
  PVSGenerator.constructInvokationTree'
  PVSGenerator.containsFifoMethod
  PVSGenerator.convertMeths2Name
  PVSGenerator.createEquivalencePairings
  PVSGenerator.createHistoryPairings
  PVSGenerator.crunchTruples
  PVSGenerator.crunchTuples
  PVSGenerator.deAlias
  PVSGenerator.deAliasArg
  PVSGenerator.def2exp
  PVSGenerator.def2string
  PVSGenerator.def2string'
  PVSGenerator.defaultVal
  PVSGenerator.deleteTable
  PVSGenerator.depTuples
  PVSGenerator.desynonymize
  PVSGenerator.desynonymize'
  PVSGenerator.displayArgs
  PVSGenerator.displayArgs'
  PVSGenerator.displaySchedule
  PVSGenerator.doesntNeed
  PVSGenerator.drillOutSynonyms
  PVSGenerator.elimRedundantEntries
  PVSGenerator.eliminateSubModEntities
  PVSGenerator.expandTable
  PVSGenerator.extractFifos
  PVSGenerator.extractWires
  PVSGenerator.extractWires'
  PVSGenerator.filterWires
  PVSGenerator.filterWires'
  PVSGenerator.findField
  PVSGenerator.findPVSState
  PVSGenerator.findPVSState'
  PVSGenerator.findPVSState''
  PVSGenerator.findPVSState'''
  PVSGenerator.findPVSStateType
  PVSGenerator.findPathToName
  PVSGenerator.findTypeDef
  PVSGenerator.fixDV
  PVSGenerator.fixDV'
  PVSGenerator.followStructs
  PVSGenerator.gatherPastTransPred
  PVSGenerator.gatherTransPred''
  PVSGenerator.genConsProof
  PVSGenerator.genConsTheorem
  PVSGenerator.genConsTheorems
  PVSGenerator.genDocumentation
  PVSGenerator.genFuncProof
  PVSGenerator.genIf
  PVSGenerator.genIf'
  PVSGenerator.genIfTruple
  PVSGenerator.genInit
  PVSGenerator.genLets
  PVSGenerator.genMethodCase
  PVSGenerator.genNewTransition
  PVSGenerator.genTabLine
  PVSGenerator.genTabSpec
  PVSGenerator.genTabSpecCall
  PVSGenerator.genTabVar
  PVSGenerator.genTabVars
  PVSGenerator.genTableLine
  PVSGenerator.genValueMethodHeader
  PVSGenerator.generateTabspecs
  PVSGenerator.getExclusionNames
  PVSGenerator.getExpressionBitSize
  PVSGenerator.getFieldBitSize
  PVSGenerator.getFieldType
  PVSGenerator.getFifoSize
  PVSGenerator.getFunctionReturnSize
  PVSGenerator.getGetMeth
  PVSGenerator.getIDRoot
  PVSGenerator.getInputTrans
  PVSGenerator.getLVType
  PVSGenerator.getLiteralBitSize
  PVSGenerator.getMArgs
  PVSGenerator.getNumericSuffix
  PVSGenerator.getPair
  PVSGenerator.getReadsByOverTree
  PVSGenerator.getState
  PVSGenerator.getStateDec
  PVSGenerator.getStructBitSize
  PVSGenerator.getTablesBySubmod
  PVSGenerator.getTrans
  PVSGenerator.getTransitionGlobalTables
  PVSGenerator.getTree
  PVSGenerator.getTypeBitSize
  PVSGenerator.getTypeFromField
  PVSGenerator.getTypeFromLV
  PVSGenerator.getTypeFromState
  PVSGenerator.getTypedefBitSize
  PVSGenerator.getVectorInit
  PVSGenerator.getVectorInit'
  PVSGenerator.getWireDeps
  PVSGenerator.getWireDeps'
  PVSGenerator.groupByArgs
  PVSGenerator.idTopLevel
  PVSGenerator.invertID
  PVSGenerator.isDWire
  PVSGenerator.isDWire'
  PVSGenerator.isEnum
  PVSGenerator.isMethTop
  PVSGenerator.isNotDefault
  PVSGenerator.isNotDefault'
  PVSGenerator.isNotSubModEntity
  PVSGenerator.isStruct
  PVSGenerator.isStruct'
  PVSGenerator.isStruct''
  PVSGenerator.isSubmod
  PVSGenerator.isSynonym
  PVSGenerator.isWireOrFifo
  PVSGenerator.isWireOrFifo'
  PVSGenerator.isWireOrFifo''
  PVSGenerator.isntIn
  PVSGenerator.justTheMaybes
  PVSGenerator.justTheName
  PVSGenerator.justTheName'
  PVSGenerator.killRefs
  PVSGenerator.killRefsWithNoTransition
  PVSGenerator.killStateWires
  PVSGenerator.killSurfaceWires
  PVSGenerator.killVoids
  PVSGenerator.killWires
  PVSGenerator.killWires'
  PVSGenerator.kludgeInit
  PVSGenerator.kludgeInit'
  PVSGenerator.kludgeInit''
  PVSGenerator.lookupInst
  PVSGenerator.lookupTable
  PVSGenerator.lookupTable'
  PVSGenerator.lvLookup
  PVSGenerator.makeStateDepTuples
  PVSGenerator.needsHistory
  PVSGenerator.noStateTables
  PVSGenerator.notEmpty
  PVSGenerator.orderLets
  PVSGenerator.orderStates
  PVSGenerator.orderWires'
  PVSGenerator.pathEq
  PVSGenerator.pickInfimum
  PVSGenerator.preproc
  PVSGenerator.readIntLit
  PVSGenerator.removePathOverlaps
  PVSGenerator.removePathOverlaps'
  PVSGenerator.sameName
  PVSGenerator.seekTable
  PVSGenerator.showBinding
  PVSGenerator.showClusterField'
  PVSGenerator.showIDPath
  PVSGenerator.showIDPath'
  PVSGenerator.showLet
  PVSGenerator.showLit
  PVSGenerator.showOutTime
  PVSGenerator.showPVSArgument
  PVSGenerator.showPVSConstantDeclaration
  PVSGenerator.showPVSDefInst
  PVSGenerator.showPVSExpression
  PVSGenerator.showPVSFunc
  PVSGenerator.showPVSInstanceDef
  PVSGenerator.showPVSMethods
  PVSGenerator.showPVSPackage
  PVSGenerator.showPVSPackages
  PVSGenerator.showPVSStateDef'
  PVSGenerator.showPVSStateInstance
  PVSGenerator.showPVSStateInstance'
  PVSGenerator.showPVSStateTypes
  PVSGenerator.showPVSStates
  PVSGenerator.showPVSTop
  PVSGenerator.showPVSTrans
  PVSGenerator.showPVSTransState
  PVSGenerator.showPVSTransStateCluster
  PVSGenerator.showPVSTransStates
  PVSGenerator.showPVSTransTree
  PVSGenerator.showPVSTransition'
  PVSGenerator.showPVSTransitionTable
  PVSGenerator.showPVSType
  PVSGenerator.showPVSTypedef
  PVSGenerator.showPVSTypedefs
  PVSGenerator.showPVSTypedefs'
  PVSGenerator.showPVSVectorState
  PVSGenerator.showPVSvariable
  PVSGenerator.showProofTheory
  PVSGenerator.showReplacementsAsEquations
  PVSGenerator.showTransitionHierarchy
  PVSGenerator.showValueMethod
  PVSGenerator.sortDefInsts
  PVSGenerator.sortStructs
  PVSGenerator.splitAtFifoMethod
  PVSGenerator.splitAtFifoMethod'
  PVSGenerator.stGlobalLookup
  PVSGenerator.stLookup
  PVSGenerator.stLookup'
  PVSGenerator.stLookup''
  PVSGenerator.stateless
  PVSGenerator.stateless'
  PVSGenerator.sth
  PVSGenerator.tailEq
  PVSGenerator.tailEq'
  PVSGenerator.tdLookup
  PVSGenerator.tripleConc
  PVSGenerator.truplePad
  PVSGenerator.unMaybeList
  PVSGenerator.wireFilter
  PVSGenerator.wireLookup
module dependencies: BSV2PVS LexerTypes
package dependencies: array-0.5.2.0 base-4.10.1.0 binary-0.8.5.1
                      bytestring-0.10.8.2 containers-0.5.10.2 deepseq-1.4.3.0 extra-1.6.8
                      ghc-prim-0.5.1.1 integer-gmp-1.0.1.0 split-0.2.3.3 text-1.2.3.0
orphans: text-1.2.3.0:Data.Text binary-0.8.5.1:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.0:Data.Text.Show base-4.10.1.0:GHC.Float
         base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Complex base-4.10.1.0:Data.Either
                         base-4.10.1.0:Data.Functor.Compose base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity
                         base-4.10.1.0:Data.Functor.Product base-4.10.1.0:Data.Functor.Sum
                         base-4.10.1.0:Data.List.NonEmpty base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Semigroup base-4.10.1.0:Data.Type.Equality
                         base-4.10.1.0:Data.Version base-4.10.1.0:Data.Void
                         base-4.10.1.0:GHC.Exts base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats containers-0.5.10.2:Data.IntMap.Internal
                         containers-0.5.10.2:Data.IntSet.Internal
                         containers-0.5.10.2:Data.Map.Internal
                         containers-0.5.10.2:Data.Sequence.Internal
                         containers-0.5.10.2:Data.Set.Internal containers-0.5.10.2:Data.Tree
                         text-1.2.3.0:Data.Text
import  -/  BSV2PVS 30286a8fbec138891fd845ec4c231c76
  exports: 878cf3fe588260c7f372a78e427d849f
  b2pType caee861dd3ab6de34f42926e8cf92d69
  getReadsBy 2115ac79884dfc3924a61a6f7abaa856
  idpath2strings f8cd6fe226dc17ed3a95305ff93e6792
  lastID eef7a3daf78b2fcf8be4da5f80746c74
  mergeIDPaths 25b182ff97517c14b563194e4204873e
  strings2idpath ac1cacfb7d38e56850f736a3238339b6
import  -/  LexerTypes ea2837b19066a45c4d666600c2728879
  exports: 24099e1d1a603a4b110bad9ae51c8629
  Add 36538cb76d628c0acd4a4cf71078cdb4
  And e22c6395cd4b23e2790ce49d4543b755
  Binding a73de62264e667fab5ce9150342bfbb0
  BitConcat ce09575274ede88737a0901dbf5bea16
  BitSelect 679dead99df4296b229e1d1889f748e3
  BitSelectRange 589edace8d5eec8af5245f487ee43fc4
  BitwiseAND 7e507419ece991ad7ce0f2956c9aa213
  BitwiseOR 302153d3c58ce21102a7455a65b88105
  BitwiseXOR c9cc2432ec74bae8bc7895c9ccd99e77
  CasesOf bdd2bd759473940f256fcd9ae669ae8c
  Context 6c786502deb98f09a62d2de966e659f3
  DefaultValue f74abb4a6bb0da4b0ec4dc2ee72d6a63
  Divide 4e0e22b926cf6cc14d39a04fc286fe36
  Equals 61c8e1ea5b6b779f6da6a09d78deda00
  Exp_FunctionCall e2d5fa7c978122cee21bc7c2633d698e
  Exp_If 8f8ce8dc133821fef9f9cd8882f50996
  Exp_MethodCall e0fa569420d352ff8a5c69ead86bec0f
  Explicit fff7810158b75b46dc5a65736647c0a3
  Expression 6b58178d3226f5dcfa379df74cd7f6b5
  FieldAccess c2642295d71416d9cf7ea37b886f9d15
  FifoType 62d32f60bf0117d657237a0b1409daa5
  File c24aa2ddc97c4de99fb79219c2e2ad5c
  FromMaybe ba67a205c79eed67f02da6f0a827eec3
  Greater 6b9689f45536195da18383e5326b97a8
  GreaterEquals 6d9a338a7609c353aeb3bdce17362ec6
  ID 162ab617d5709f209b382d729b114647
  ID_Path 6b58178d3226f5dcfa379df74cd7f6b5
  ID_Submod_Struct 463de23e5c7996a7d7e8c379f21535c2
  ID_Vect ac4504a9362ebe24ddb26ea1baec8978
  Identifier f34a421e3991b38924384ea37d474049
  Ileaf 950100560485addcb587f478bbf06cd2
  Invalid ed1ca468e26ed28115951dd040fb4279
  InvokationTree 3ae8634cce2ce6c491831d891f6327fe
  IsValid 86cdbf08e2e7a3d893fc5ab943e94310
  Istem 18b12f8fe7558d18f3f581688b80c5eb
  LShift a6a4b281298d1b8a75f764462c15d6a1
  Less d59e317442af542f318ae1618692d2bb
  LessEquals 0253bd2afe07783f24a5580881609c67
  Lit e03304d97e0d6aca513132b576af286a
  LitBool f9036459d5bfa3180b25936630b48534
  LitChar 7f94333a3e51272aed4b39115a5953fa
  LitEnum 3534e76614187a07c69c8d39073a6f24
  LitInt 85e98ff38658a058a373ff0d13101497
  LitReal 1718a0fd8087fa703023fd43c6f0504f
  LitSizedInt 8b76517d0d11aa759dbd7f9307ca74b7
  LitString 3e963e81617eb1025a56f6d00be3e486
  LitStructConstructor a91bdcbd8e359522c690b7666c6b98b4
  LitVoid 78667fcb5e09de66105a1d72dda08978
  Literal 337aee2c7f9cd9dd951f930c9b9dbe73
  Literal 6b58178d3226f5dcfa379df74cd7f6b5
  LocalVar 6b58178d3226f5dcfa379df74cd7f6b5
  MaybeContainer 672d36bd151398507ab3b4acf991b824
  MaybeIf 34bc4228cd97532add7324e8063547f0
  MaybeValue b4406f5978a10fdfe189d8f0d74eb951
  MethodArg 3690921074a8037a0b7e5c576e714940
  MethodName afc969c65aec121c900a4f28adbec892
  Modulo ef51c13e1735d14b66d320257e21a593
  Multiply 2e1955b341ad5724899f6d2460f61d10
  N_Time 26c4b688e65cba63574a39af3f33761b
  Name 7c6cc0f4ece946a46df101a52b2e2642
  Negative 9890405dd1a0c5764d6155433ae9484e
  Not 22d1103f357094a67193828970d4b051
  NotEquals ca898c161ed932983a471d3d692c86bf
  Or 29cc9a489f4941fb8f760730dd0dff52
  PVSArgument 7d8a7e836795cb9d22f15bbe05b0f092
  PVSConstantDec 2f2405ef76e2fdf81a05bdc6a4655ac9
  PVSFunction bd8391fe6aa4b9aeeace864d9f179cb4
  PVSInstDef 4cd52ce8483a87744e359b1843bfd9d3
  PVSPackage 2ebe3fda021fa922603a337269985adf
  PVSType 5293579e9cbbf6986dcf46fee97434cb
  PVSTypeDef 263d5987ddec79fadf35563de5be9f0c
  PVS_Bit 22acc7100431b38432c9c3c07d2b2a41
  PVS_Bool 9e0621e80245a1f11c51a0ee4357c949
  PVS_Custom 3b7a0ad00510c97e677113fc5dcc2393
  PVS_DWire 828e6ea5d731fd0010e348a66b7108a2
  PVS_Enumeration 4c8f7f14ccc0ee1299e205bd31c7048b
  PVS_Field 907934b371d6291fd472d601c345122a
  PVS_Fifo 6d6da14962836ca13ef4dabaa82408b6
  PVS_Int 00b5ec9b246ed8c7086e269060a6072e
  PVS_Maybe 3847bfcf37f5af07138f72f8f928732b
  PVS_Real 92e906bfc31d0cbaed8d7427f91679ca
  PVS_Reg fe7cd9f9365abb666cc495e6b8106326
  PVS_Struct 3e464b1a1f5a13bed37a0a89c99f7fb7
  PVS_SubModuleDec dbe1e226acd2b6511ad77f6aa920087a
  PVS_Synonym 8a9d46d2cacf21d3788db9f5d6b38bde
  PVS_UInt db0d5cc35fbfe6395496e1c360f6dd95
  PVS_Vector 28aa2de41cd2f5bbe33ceea566b39929
  PVSstate 27e7de08b1523caab97202618cf8bce6
  PVSstateDec 10d0986ecfd076e695b49c5e94e87c77
  PVStransition 74cf04055f6193fb2cf856c4b138a104
  PackageName 6454d16386f2f0fea028840e593a69c1
  RShift 6a6e1d65a10e1f1cbb73413d5cb25175
  Replacement e8e0dabb470ed6767d6eeba2a104c650
  Replicate 0596cb6a1d5f7590a004891e465925ab
  SizedBypassFIFOF 9c9fb32fec045cb2d0c09a8ac07f6676
  SizedFIFO 2119097fca1a77d4d22493adb4066fcc
  SizedFIFOF 30fb53a8f0d1f1f038997a3d00b43758
  Skip c4d4e47795a29b6972a451ca43a86c1a
  SpecEx 26637e3bd58c473091b6566a0fbdc641
  SpecLeaf e32e60e0336d77e475456485973057be
  SpecStem f6a722964cf9c3795146efc8eea95e68
  SpecificTree 6a668caddf4b8e9677117e2028b195e2
  StructCluster d1d9a321e54a65adb8a23ae2be47bd44
  Subtract 8f6065598203e3e8d21db427badb1bf6
  TSPLine b93aef0411d044ff4424aa4a41963594
  TSPTable 8b6d1afccd9c3b1fa2d8d2ad6c723805
  TSPpackage c811cfd5a607fccc3baae6462b8eca1f
  TVarDec e24892224e84f179f5d881ea6ad6b8d1
  Tagged 0103ea8b59c5429e51d36d50c470f390
  Temporal 4df2e074d05690b7f852eb8a56267ac6
  TransDWire d4795ee85497c0ff1208c1fea07f1eae
  TransFIFO 54f039d20fa6c537ed219c894a3c864f
  TransMod b2295ed615c13bc8edb9b75da1874a04
  TransReg 66e3d25125f674da894bdf36a2c2da3d
  TransStruct 751ab6f0525a7c9d2168f4a413caf775
  TransVect 8cad7a999fbf903557bc2dbec666d39e
  TransitionTable 321d4bb033873a046e1650695f529c57
  TransitionVar 853751140af520152685e71ddf0e992f
  Valid a42292174e949ee84846f4697e0a0816
  ValueMethod 162bf9d0bb1089190de24d16b16617f0
  ValueMethodCall 6e178be71a4412cc4bda1ba94fdf869f
  VectorInit c2b979719dd3c7dfe36e1834bf38f676
  mkBSVModule 58ee1a3540da646a028dad6f00fa6ec3
  pvs_constants 2ebe3fda021fa922603a337269985adf
  pvs_functions 2ebe3fda021fa922603a337269985adf
  pvs_instantiations 2ebe3fda021fa922603a337269985adf
  pvs_packageName 2ebe3fda021fa922603a337269985adf
  pvs_state 2ebe3fda021fa922603a337269985adf
  pvs_typedefs 2ebe3fda021fa922603a337269985adf
  transitions 2ebe3fda021fa922603a337269985adf
  tsps c811cfd5a607fccc3baae6462b8eca1f
  varDecs c811cfd5a607fccc3baae6462b8eca1f
import  -/  base-4.10.1.0:Data.Char fe4e3458190deeac19969ce15e33bed9
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.Maybe 07738c5485acb328136bb15596f8b845
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:Debug.Trace d6b92a67d41f66511d3d35c0713fec79
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Err 514b3a24b22e9d7d731c2d0d02d10842
import  -/  base-4.10.1.0:GHC.Float 28e3bf9e258278ac8084e9cab43fd542
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:Text.Read 9e862e012b3c71e83cb56fb456188f44
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  integer-gmp-1.0.1.0:GHC.Integer.Type 5fa81108482c33b62ec3ac7464eece96
import  -/  split-0.2.3.3:Data.List.Split d6f07f97ee293e86e1952e7427bfffa3
import  -/  split-0.2.3.3:Data.List.Split.Internals 07f8f22ebfb54f941d103ac266ac982b
import  -/  text-1.2.3.0:Data.Text 0519455f2b04d2a7315c2959461dd14e
2b3b87f59a6ec96da1885889670d04f3
  $s$fEq(,) :: GHC.Classes.Eq ([GHC.Types.Char], LexerTypes.PVSType)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], LexerTypes.PVSType)
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ LexerTypes.PVSType
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     LexerTypes.$fEqPVSType)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ [GHC.Types.Char]
                     @ LexerTypes.PVSType
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     LexerTypes.$fEqPVSType) -}
962b7aee859326a1b5835728f4d55d26
  $s$fShow(,,)_$cshowsPrec_$s$fShowMaybe ::
    GHC.Show.Show (GHC.Base.Maybe LexerTypes.BSVType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe LexerTypes.BSVType)
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ LexerTypes.BSVType
                     LexerTypes.$fShowBSVType)
                  (\ (x :: GHC.Base.Maybe LexerTypes.BSVType) ->
                   case x of wild {
                     GHC.Base.Nothing -> GHC.Show.$fShowMaybe4
                     GHC.Base.Just b1
                     -> GHC.Base.augment
                          @ GHC.Types.Char
                          (\ @ b
                             (c :: GHC.Types.Char -> b -> b)[OneShot]
                             (n :: b)[OneShot] ->
                           GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe1)
                          (LexerTypes.$fShowBSVType_$cshowsPrec
                             GHC.Show.appPrec1
                             b1
                             (GHC.Types.[] @ GHC.Types.Char)) })
                  (\ (eta :: [GHC.Base.Maybe LexerTypes.BSVType])
                     (eta1 :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (GHC.Base.Maybe LexerTypes.BSVType)
                     (GHC.Show.$fShowMaybe_$cshowsPrec
                        @ LexerTypes.BSVType
                        LexerTypes.$fShowBSVType
                        GHC.Show.$fShow(,)1)
                     eta
                     eta1) -}
2b57a4e1dc2375de7bf586994a5f7027
  $s$fShow(,,)_$cshowsPrec_$s$fShowMaybe1 ::
    GHC.Show.Show (GHC.Base.Maybe LexerTypes.PVSType)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe LexerTypes.PVSType)
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ LexerTypes.PVSType
                     LexerTypes.$fShowPVSType)
                  (\ (x :: GHC.Base.Maybe LexerTypes.PVSType) ->
                   case x of wild {
                     GHC.Base.Nothing -> GHC.Show.$fShowMaybe4
                     GHC.Base.Just b1
                     -> GHC.Base.augment
                          @ GHC.Types.Char
                          (\ @ b
                             (c :: GHC.Types.Char -> b -> b)[OneShot]
                             (n :: b)[OneShot] ->
                           GHC.Base.foldr @ GHC.Types.Char @ b c n GHC.Show.$fShowMaybe1)
                          (LexerTypes.$fShowPVSType_$cshowsPrec
                             GHC.Show.appPrec1
                             b1
                             (GHC.Types.[] @ GHC.Types.Char)) })
                  (\ (eta :: [GHC.Base.Maybe LexerTypes.PVSType])
                     (eta1 :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (GHC.Base.Maybe LexerTypes.PVSType)
                     (GHC.Show.$fShowMaybe_$cshowsPrec
                        @ LexerTypes.PVSType
                        LexerTypes.$fShowPVSType
                        GHC.Show.$fShow(,)1)
                     eta
                     eta1) -}
581e4c855aaaef7d0d0eca4b9a944707
  $s$fShowMaybe_$cshowList ::
    [GHC.Base.Maybe LexerTypes.BSVType] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [GHC.Base.Maybe LexerTypes.BSVType])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Base.Maybe LexerTypes.BSVType)
                   (GHC.Show.$fShowMaybe_$cshowsPrec
                      @ LexerTypes.BSVType
                      LexerTypes.$fShowBSVType
                      GHC.Show.$fShow(,)1)
                   eta
                   eta1) -}
a32fcdfa427a6a134d3354499889ea68
  $s$fShowMaybe_$cshowList1 ::
    [GHC.Base.Maybe LexerTypes.PVSType] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [GHC.Base.Maybe LexerTypes.PVSType])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Base.Maybe LexerTypes.PVSType)
                   (GHC.Show.$fShowMaybe_$cshowsPrec
                      @ LexerTypes.PVSType
                      LexerTypes.$fShowPVSType
                      GHC.Show.$fShow(,)1)
                   eta
                   eta1) -}
9ca3f3e6efaac5b3d9cac083e9d75f6c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   PVSGenerator.$trModule3
                   PVSGenerator.$trModule1) -}
8336bc92b91e07f5f11faaf0a1e9fdf7
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PVSGenerator.$trModule2) -}
53a67281a97c441a5b01ae86d13daeb7
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PVSGenerator"#) -}
052523c61d460dbfa275bb97605987cb
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS PVSGenerator.$trModule4) -}
9f130a1a0c6f7d387a69fc6965a12eca
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("BAPIP-0.1.0.0-IeoLXJJUcqyHz2cFv4cIMD"#) -}
14fc02f6941dfe88bfb4a10dd5ea819e
  $wargsMatch ::
    LexerTypes.PVSPackage
    -> [(LexerTypes.MethodName,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> [(LexerTypes.MethodName,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*U,A,A,A,A)><S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: [(LexerTypes.MethodName,
                            [(LexerTypes.MethodArg, LexerTypes.PVSType)])])
                   (ww1 :: [(LexerTypes.MethodName,
                             [(LexerTypes.MethodArg, LexerTypes.PVSType)])]) ->
                 let {
                   lvl568 :: [LexerTypes.PVSTypeDef]
                   = case w of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                     ds3 }
                 } in
                 let {
                   lvl569 :: [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                             -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                     {- Arity: 1 -}
                   = PVSGenerator.desynonymize' lvl568
                 } in
                 let {
                   xs :: [[(LexerTypes.MethodArg, LexerTypes.PVSType)]]
                   = GHC.Base.map
                       @ (LexerTypes.MethodName,
                          [(LexerTypes.MethodArg, LexerTypes.PVSType)])
                       @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                       (Data.Tuple.snd
                          @ LexerTypes.MethodName
                          @ [(LexerTypes.MethodArg, LexerTypes.PVSType)])
                       ww
                 } in
                 let {
                   ys :: [[(LexerTypes.MethodArg, LexerTypes.PVSType)]]
                   = GHC.Base.map
                       @ (LexerTypes.MethodName,
                          [(LexerTypes.MethodArg, LexerTypes.PVSType)])
                       @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                       (Data.Tuple.snd
                          @ LexerTypes.MethodName
                          @ [(LexerTypes.MethodArg, LexerTypes.PVSType)])
                       ww1
                 } in
                 case PVSGenerator.argsMatch_go
                        (GHC.Base.map
                           @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                           @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                           lvl569
                           ys)
                        (GHC.Base.map
                           @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                           @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                           lvl569
                           xs) of wild {
                   []
                   -> case PVSGenerator.argsMatch_go
                             (GHC.Base.map
                                @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                                @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                                lvl569
                                xs)
                             (GHC.Base.map
                                @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                                @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                                lvl569
                                ys) of wild1 {
                        [] -> GHC.Types.True : ds1 ds2 -> GHC.Types.False }
                   : ds1 ds2 -> GHC.Types.False }) -}
88c9e0ddfbff43c1e24f4ed7df239845
  $wconstructInvokationTree ::
    LexerTypes.PackageName
    -> [LexerTypes.PVSstateDec] -> LexerTypes.InvokationTree
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.PackageName)
                   (ww1 :: [LexerTypes.PVSstateDec]) ->
                 case GHC.List.lookup
                        @ LexerTypes.PackageName
                        @ [LexerTypes.PVSstate]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        ww
                        ww1 of wild {
                   GHC.Base.Nothing
                   -> case PVSGenerator.constructInvokationTree13
                      ret_ty LexerTypes.InvokationTree
                      of {}
                   GHC.Base.Just x
                   -> PVSGenerator.$wconstructInvokationTree'
                        (LexerTypes.PVSPackage
                           ww
                           PVSGenerator.constructInvokationTree11
                           PVSGenerator.constructInvokationTree9
                           PVSGenerator.constructInvokationTree7
                           ww1
                           PVSGenerator.constructInvokationTree5
                           PVSGenerator.constructInvokationTree3)
                        PVSGenerator.constructInvokationTree1
                        ww
                        x }) -}
f0b8168c82b6138a76d17f1d0464917f
  $wconstructInvokationTree' ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> LexerTypes.Name
    -> [LexerTypes.PVSstate]
    -> LexerTypes.InvokationTree
  {- Arity: 4, Strictness: <L,U(A,A,A,A,U,A,A)><L,U><L,U><S,1*U>,
     Inline: [0] -}
17df4e1ef3aea932d366b3754f69f356
  $wcreateEquivalencePairings ::
    LexerTypes.PVSPackage
    -> LexerTypes.ID_Path -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: LexerTypes.ID_Path)
                   (ww1 :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (PVSGenerator.showPVSExpression
                      w
                      (GHC.Types.[] @ LexerTypes.LocalVar)
                      (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                      PVSGenerator.badType
                      (LexerTypes.Identifier ww)
                      (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                      (GHC.Types.[] @ GHC.Types.Char))
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.createEquivalencePairings3
                      (GHC.Base.++
                         @ GHC.Types.Char
                         ww1
                         PVSGenerator.createEquivalencePairings1))) -}
fd78cd7d1af2e50bf192cfc46624fd93
  $wcreateHistoryPairings ::
    GHC.Base.String
    -> GHC.Base.String -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.createHistoryPairings4
                      (GHC.Base.++
                         @ GHC.Types.Char
                         w
                         (GHC.CString.unpackAppendCString#
                            PVSGenerator.createHistoryPairings3
                            (GHC.Base.++
                               @ GHC.Types.Char
                               ww1
                               PVSGenerator.createHistoryPairings1))))) -}
75e1a4afe8aec00b5fa92069414d782a
  $wcrunchTruples ::
    GHC.Classes.Eq c => [(a, b, c)] -> [([(a, b)], c)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),C(C1(U)))><S,1*U>, Inline: [0] -}
6bac3dad5c507b52c3d8a45ae2ceb397
  $wcrunchTuples :: GHC.Classes.Eq b => [(a, b)] -> [([a], b)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),C(C1(U)))><S,1*U>, Inline: [0] -}
2008e049553336e1c87a4767dc33d43e
  $wdef2string ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSTypeDef
    -> [(LexerTypes.Name, LexerTypes.Literal)]
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(A,A,U,A,A,U,A)><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSTypeDef)
                   (ww :: [(LexerTypes.Name, LexerTypes.Literal)]) ->
                 GHC.CString.unpackAppendCString#
                   PVSGenerator.def2string5
                   (case GHC.Base.map
                           @ (LexerTypes.Name, LexerTypes.Literal)
                           @ [GHC.Types.Char]
                           (PVSGenerator.def2string' w w1)
                           ww of wild {
                      [] -> PVSGenerator.def2string3
                      : x xs1
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           (Data.OldList.intercalate_$spoly_go
                              @ GHC.Types.Char
                              x
                              (Data.OldList.prependToAll
                                 @ [GHC.Types.Char]
                                 PVSGenerator.def2string1
                                 xs1))
                           PVSGenerator.def2string3 })) -}
2d988ef970652241a46f11efe038cf37
  $wdef2string' ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSTypeDef
    -> LexerTypes.Name
    -> LexerTypes.Literal
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*U(A,A,U,A,A,U,A)><L,1*U><S,U><S,U>,
     Inline: [0] -}
64dbfaef0b31ae1c06f42b9f4f5b6550
  $wdepTuples ::
    [LexerTypes.TransitionTable]
    -> LexerTypes.TransitionTable
    -> (# LexerTypes.TransitionTable, [LexerTypes.ID_Path] #)
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
aaf94a7f312e4adfd1c728c853e07f19
  $wdisplayArgs ::
    LexerTypes.MethodArg -> LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.MethodArg)
                   (ww1 :: LexerTypes.PVSType) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.displayArgs1
                      (PVSGenerator.$wshowPVSType ww1))) -}
81e5654d80a0448c421c2e7e04b537ef
  $wdisplaySchedule ::
    GHC.Integer.Type.Integer
    -> [(LexerTypes.MethodName,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
94425dd3b374f10ecb2e5af206854a69
  $weliminateSubModEntities ::
    [LexerTypes.ID_Path]
    -> LexerTypes.PVSstateDec
    -> LexerTypes.TransitionTable
    -> [LexerTypes.ID_Path]
    -> (# LexerTypes.TransitionTable, [LexerTypes.ID_Path] #)
  {- Arity: 4, Strictness: <L,U><L,1*U(A,1*U)><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.ID_Path])
                   (w1 :: LexerTypes.PVSstateDec)
                   (ww :: LexerTypes.TransitionTable)
                   (ww1 :: [LexerTypes.ID_Path]) ->
                 (# ww,
                    let {
                      lvl568 :: [LexerTypes.PVSstate]
                      = case w1 of wild { (,) ds1 y -> y }
                    } in
                    GHC.List.filter
                      @ LexerTypes.ID_Path
                      (\ (x :: LexerTypes.ID_Path) ->
                       case x of wild {
                         LexerTypes.ID_Submod_Struct x1 y
                         -> case PVSGenerator.isStruct'' lvl568 wild of wild1 {
                              GHC.Types.False -> GHC.Types.False
                              GHC.Types.True
                              -> case GHC.List.elem
                                        @ LexerTypes.ID_Path
                                        LexerTypes.$fEqID_Path
                                        wild
                                        w of wild2 {
                                   GHC.Types.False -> GHC.Types.True
                                   GHC.Types.True -> GHC.Types.False } }
                         LexerTypes.ID x1
                         -> case GHC.List.elem
                                   @ LexerTypes.ID_Path
                                   LexerTypes.$fEqID_Path
                                   wild
                                   w of wild1 {
                              GHC.Types.False -> GHC.Types.True
                              GHC.Types.True -> GHC.Types.False }
                         LexerTypes.ID_Vect ipv ipv1
                         -> PVSGenerator.eliminateSubModEntities1 })
                      ww1 #)) -}
7d7177465beac560c4d24f7f65b03ee6
  $wfindPVSState''' ::
    [LexerTypes.PVSstate] -> LexerTypes.ID_Path -> LexerTypes.PVSType
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
b58946e1373c4d6d37c4a49dffd0ed26
  $wfindPathToName ::
    LexerTypes.InvokationTree
    -> GHC.Base.String -> (# GHC.Base.String, [GHC.Base.String] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
e2e5712fac937be46fe875e8bb6e7aa8
  $wgatherPastTransPred ::
    GHC.Base.String
    -> [(LexerTypes.MethodName,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String)
                   (ww :: [(LexerTypes.MethodName,
                            [(LexerTypes.MethodArg, LexerTypes.PVSType)])]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   w
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.gatherPastTransPred10
                      (let {
                         arg :: [GHC.Types.Char]
                         = GHC.CString.unpackAppendCString#
                             PVSGenerator.gatherPastTransPred9
                             (case PVSGenerator.gatherPastTransPred_go ww of wild {
                                [] -> PVSGenerator.gatherPastTransPred7
                                : ds1 ds2
                                -> GHC.CString.unpackAppendCString#
                                     PVSGenerator.gatherPastTransPred6
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        (Data.OldList.intercalate_$spoly_go
                                           @ GHC.Types.Char
                                           ds1
                                           (Data.OldList.prependToAll
                                              @ [GHC.Types.Char]
                                              PVSGenerator.gatherPastTransPred4
                                              ds2))
                                        PVSGenerator.gatherPastTransPred2) })
                       } in
                       case GHC.Base.map
                              @ (LexerTypes.MethodName,
                                 [(LexerTypes.MethodArg, LexerTypes.PVSType)])
                              @ [GHC.Types.Char]
                              (Data.Tuple.fst
                                 @ LexerTypes.MethodName
                                 @ [(LexerTypes.MethodArg, LexerTypes.PVSType)])
                              ww of wild {
                         [] -> arg
                         : x xs1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.gatherPastTransPred1
                                    xs1))
                              arg }))) -}
46710a8b5fb5c6a386bd17712a5f20c1
  $wgatherTransPred'' ::
    [(LexerTypes.MethodName,
      [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [(LexerTypes.MethodName,
                            [(LexerTypes.MethodArg, LexerTypes.PVSType)])]) ->
                 GHC.CString.unpackAppendCString#
                   PVSGenerator.gatherTransPred''3
                   (case PVSGenerator.gatherTransPred''_go ww of wild {
                      [] -> PVSGenerator.gatherPastTransPred7
                      : ds1 ds2
                      -> GHC.CString.unpackAppendCString#
                           PVSGenerator.gatherPastTransPred6
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 ds1
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.gatherPastTransPred4
                                    ds2))
                              PVSGenerator.gatherTransPred''1) })) -}
533fd96630ebd6ba848cf782b1e0ff66
  $wgenConsTheorem ::
    GHC.Base.String -> [LexerTypes.PVStransition] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
876035724bf3f7219bc1f019839260bf
  $wgenIfTruple ::
    LexerTypes.PVSPackage
    -> LexerTypes.ValueMethod
    -> [LexerTypes.PVStransition]
    -> [(GHC.Integer.Type.Integer, GHC.Base.String,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
  {- Arity: 3,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U(U,U,U,A,U,U,A)><S,1*U>,
     Inline: [0] -}
d69ce1dd19eb0c896c0f96e32af832ea
  $wgenMethodCase ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> LexerTypes.MethodName
    -> LexerTypes.ModuleName
    -> GHC.Base.String
    -> LexerTypes.PVSType
    -> LexerTypes.Expression
    -> GHC.Integer.Type.Integer
    -> [LexerTypes.TransitionTable]
    -> GHC.Base.String
  {- Arity: 9,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U(A,U)><L,1*U><L,U><L,1*U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
bead53a3b2f14ce703c76ab667d017bf
  $wgenNewTransition ::
    LexerTypes.PackageName
    -> [LexerTypes.PVSTypeDef]
    -> [LexerTypes.PVStransition]
    -> [LexerTypes.PVSstateDec]
    -> [LexerTypes.PVSInstDef]
    -> [LexerTypes.PVSFunction]
    -> LexerTypes.PVSstateDec
    -> GHC.Base.String
    -> GHC.Types.Bool
    -> [LexerTypes.PVStransition]
    -> [GHC.Types.Char]
  {- Arity: 10,
     Strictness: <L,U><L,U><L,U><S,U><L,U><L,U><L,U(A,U)><L,U><L,U><L,U>,
     Inline: [0] -}
8bd28fbffe34943319e8c2572bebaee5
  $wgenTabLine ::
    LexerTypes.TName -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.TName)
                   (ww1 :: [GHC.Base.String]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.genTabLine5
                      (case ww1 of wild {
                         [] -> PVSGenerator.genTabLine3
                         : x xs1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.genTabLine1
                                    xs1))
                              PVSGenerator.genTabLine3 }))) -}
7eaf0f7ddf7ff78f57609eba280b82c9
  $wgenTabSpec ::
    LexerTypes.PVSPackage
    -> LexerTypes.TName
    -> LexerTypes.ID_Path
    -> LexerTypes.Temporal
    -> LexerTypes.Expression
    -> [LexerTypes.Replacement]
    -> [GHC.Base.String]
    -> [LexerTypes.TSPLine]
    -> GHC.Base.String
  {- Arity: 8,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,1*U><L,U><L,1*U(1*U(U))><L,U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
45e034af5395b5343d87bd8f0c7efe50
  $wgenTabSpecCall ::
    LexerTypes.TName
    -> LexerTypes.Temporal -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,1*U(1*U(1*U))><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.TName)
                   (ww1 :: LexerTypes.Temporal)
                   (ww2 :: [GHC.Base.String]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.genTabLine5
                      (let {
                         n :: [GHC.Types.Char]
                         = GHC.CString.unpackAppendCString#
                             PVSGenerator.gatherPastTransPred8
                             (case ww1 of wild { LexerTypes.N_Time a1 ->
                              case a1 of wild1 { GHC.Types.I# x ->
                              case x of wild2 {
                                DEFAULT -> PVSGenerator.genTabSpecCall3
                                0# -> PVSGenerator.genTabSpecCall1 } } })
                       } in
                       case ww2 of wild {
                         [] -> n
                         : x xs1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.genTabLine1
                                    xs1))
                              n }))) -}
22dca9cdd19f4d4d48061a9091248163
  $wgenTabVar ::
    [GHC.Base.String] -> LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Base.String])
                   (ww1 :: LexerTypes.PVSType) ->
                 case GHC.List.filter
                        @ [GHC.Types.Char]
                        PVSGenerator.genTabVar4
                        ww of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ds1 ds2
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (Data.OldList.intercalate_$spoly_go
                           @ GHC.Types.Char
                           ds1
                           (Data.OldList.prependToAll
                              @ [GHC.Types.Char]
                              PVSGenerator.genConsProof13
                              ds2))
                        (GHC.CString.unpackAppendCString#
                           PVSGenerator.genTabVar3
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (PVSGenerator.$wshowPVSType ww1)
                              PVSGenerator.genTabVar1)) }) -}
a220b7d9953b19ddad670ae2aefece44
  $wgenTabVars :: [LexerTypes.TVarDec] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.TVarDec]) ->
                 case GHC.Base.map
                        @ ([GHC.Base.String], LexerTypes.PVSType)
                        @ [GHC.Types.Char]
                        PVSGenerator.genTabVars3
                        w of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.genTabVars1
                           xs1) }) -}
8a1e88b1a5aa64e3004fe7ef90a84d37
  $wgenTableLine ::
    LexerTypes.PVSPackage
    -> LexerTypes.Guard -> LexerTypes.Expression -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: LexerTypes.Guard)
                   (ww1 :: LexerTypes.Expression) ->
                 GHC.CString.unpackAppendCString#
                   PVSGenerator.genTableLine4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (PVSGenerator.showPVSExpression
                         w
                         (GHC.Types.[] @ LexerTypes.LocalVar)
                         (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                         (GHC.Base.Nothing @ LexerTypes.PVSType)
                         ww
                         (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                         (GHC.Types.[] @ GHC.Types.Char))
                      (GHC.CString.unpackAppendCString#
                         PVSGenerator.genTableLine3
                         (GHC.Base.++
                            @ GHC.Types.Char
                            (PVSGenerator.showPVSExpression
                               w
                               (GHC.Types.[] @ LexerTypes.LocalVar)
                               (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                               (GHC.Base.Nothing @ LexerTypes.PVSType)
                               ww1
                               (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                               (GHC.Types.[] @ GHC.Types.Char))
                            PVSGenerator.genTableLine1)))) -}
89e7345c9b160b9cd124fd286695725c
  $wgenValueMethodHeader ::
    GHC.Types.Bool
    -> LexerTypes.MethodName
    -> LexerTypes.ModuleName
    -> GHC.Base.String
    -> LexerTypes.PVSType
    -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
    -> GHC.Base.String
  {- Arity: 6, Strictness: <L,1*U><S,1*U><L,U><L,U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Bool)
                   (ww :: LexerTypes.MethodName)
                   (ww1 :: LexerTypes.ModuleName)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: LexerTypes.PVSType)
                   (w1 :: [(LexerTypes.MethodArg, LexerTypes.PVSType)]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.genValueMethodHeader10
                      (let {
                         arg :: [GHC.Types.Char]
                         = GHC.CString.unpackAppendCString#
                             PVSGenerator.genValueMethodHeader9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                (PVSGenerator.$wshowPVSType ww3)
                                PVSGenerator.genValueMethodHeader7)
                       } in
                       case w of wild {
                         GHC.Types.False
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 (GHC.CString.unpackAppendCString#
                                    PVSGenerator.genValueMethodHeader6
                                    ww2)
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.genConsProof13
                                    (GHC.Types.:
                                       @ [GHC.Types.Char]
                                       (GHC.CString.unpackAppendCString#
                                          PVSGenerator.genValueMethodHeader5
                                          ww1)
                                       (GHC.Base.map
                                          @ (GHC.Base.String, LexerTypes.PVSType)
                                          @ [GHC.Types.Char]
                                          PVSGenerator.genValueMethodHeader3
                                          w1))))
                              arg
                         GHC.Types.True
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 PVSGenerator.genValueMethodHeader1
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.genConsProof13
                                    (GHC.Types.:
                                       @ [GHC.Types.Char]
                                       (GHC.CString.unpackAppendCString#
                                          PVSGenerator.genValueMethodHeader6
                                          ww2)
                                       (GHC.Types.:
                                          @ [GHC.Types.Char]
                                          (GHC.CString.unpackAppendCString#
                                             PVSGenerator.genValueMethodHeader5
                                             ww1)
                                          (GHC.Base.map
                                             @ (GHC.Base.String, LexerTypes.PVSType)
                                             @ [GHC.Types.Char]
                                             PVSGenerator.genValueMethodHeader3
                                             w1)))))
                              arg }))) -}
20742f136a6e1de9d567d5e363d94a2f
  $wgetIDRoot :: LexerTypes.ID_Path -> (# GHC.Base.String #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
abcc41dd6e09fe6ab1b32221e869325a
  $wgetInputTrans ::
    [LexerTypes.PVStransition]
    -> (# GHC.Integer.Type.Integer,
          [(LexerTypes.MethodName,
            [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
          [LexerTypes.ValueMethod], [LexerTypes.TransitionTable] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
34a256d2d021995d502c11089f45a04d
  $wgetState ::
    [LexerTypes.PVSstateDec]
    -> GHC.Base.String -> (# LexerTypes.Name, [LexerTypes.PVSstate] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
f8cb69651366eb405337442c01ca080b
  $wgetVectorInit' ::
    LexerTypes.PVSPackage
    -> GHC.Prim.Int# -> LexerTypes.Literal -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: LexerTypes.Literal) ->
                 case GHC.Show.$wshowSignedInt
                        0#
                        ww
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.getVectorInit'1
                      (PVSGenerator.showPVSExpression
                         w
                         (GHC.Types.[] @ LexerTypes.LocalVar)
                         (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                         PVSGenerator.badType
                         ww1
                         (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                         (GHC.Types.[] @ GHC.Types.Char))) }) -}
ae8bb69da47fe912cc24c2c19480218e
  $wisDWire ::
    [LexerTypes.PVSstate] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [LexerTypes.PVSstate])
                   (w :: LexerTypes.ID_Path) ->
                 letrec {
                   go4 :: [LexerTypes.PVSstate] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [LexerTypes.PVSstate]) ->
                     case ds of wild {
                       [] -> GHC.Types.False
                       : y ys
                       -> case y of wild1 {
                            DEFAULT -> go4 ys
                            LexerTypes.PVS_DWire i' ds1 ds2
                            -> case PVSGenerator.pathEq w i' of wild2 {
                                 GHC.Types.False -> go4 ys GHC.Types.True -> GHC.Types.True } } }
                 } in
                 go4 ww) -}
c82fa9abcea3ec04f98a7f140655d9fe
  $wisNotDefault' ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> LexerTypes.Expression
    -> [(GHC.Base.String, LexerTypes.Expression)]
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U(A,A,A,A,A,U,A)><L,U><S,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: GHC.Base.String)
                   (ww1 :: LexerTypes.Expression)
                   (w1 :: [(GHC.Base.String, LexerTypes.Expression)]) ->
                 case ww1 of wild {
                   DEFAULT
                   -> case GHC.List.lookup
                             @ GHC.Base.String
                             @ LexerTypes.Expression
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ww
                             w1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just x -> LexerTypes.$fEqExpression_$c== wild x }
                   LexerTypes.StructCluster x y
                   -> PVSGenerator.isNotDefault w wild }) -}
e260b012c2618efa42d0e0c9a3cf543a
  $wisWireOrFifo ::
    [LexerTypes.PVSstate] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [LexerTypes.PVSstate])
                   (w :: LexerTypes.ID_Path) ->
                 letrec {
                   go4 :: [LexerTypes.PVSstate] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [LexerTypes.PVSstate]) ->
                     case ds of wild {
                       [] -> GHC.Types.False
                       : y ys
                       -> case y of wild1 {
                            DEFAULT -> go4 ys
                            LexerTypes.PVS_Fifo ds1 i' ds2
                            -> case PVSGenerator.pathEq w i' of wild2 {
                                 GHC.Types.False -> go4 ys GHC.Types.True -> GHC.Types.True }
                            LexerTypes.PVS_DWire i' ds1 ds2
                            -> case PVSGenerator.pathEq w i' of wild2 {
                                 GHC.Types.False -> go4 ys GHC.Types.True -> GHC.Types.True } } }
                 } in
                 go4 ww) -}
aa435853fcd127fff391da2b17e07cb2
  $wjustTheMaybes ::
    [LexerTypes.PVSType]
    -> (# LexerTypes.PVSType, [LexerTypes.PVSType] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
e93c86ce19219418957597a97031ed5d
  $wjustTheName ::
    LexerTypes.TransitionTable
    -> [LexerTypes.ID_Path] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
33eec5e97fbe5b914b20af176a83b6b1
  $wlvl :: LexerTypes.TransitionTable -> LexerTypes.ID_Path
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.TransitionTable) ->
                 case ww of wild {
                   LexerTypes.TransMod i ds -> LexerTypes.ID i
                   LexerTypes.TransReg i ds -> i
                   LexerTypes.TransVect i ds ds1 -> i
                   LexerTypes.TransStruct i ds -> LexerTypes.ID i
                   LexerTypes.TransDWire i ds ds1 -> i
                   LexerTypes.TransFIFO i ds ds1 ds2 -> i }) -}
fbbd82cbf4d50c43c294fff8233a903e
  $wlvl1 ::
    LexerTypes.TransitionTable
    -> [LexerTypes.ID_Path]
    -> LexerTypes.TransitionTable
    -> [LexerTypes.ID_Path]
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.TransitionTable)
                   (ww1 :: [LexerTypes.ID_Path])
                   (ww2 :: LexerTypes.TransitionTable)
                   (ww3 :: [LexerTypes.ID_Path]) ->
                 case LexerTypes.$fEqTransitionTable_$c== ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ LexerTypes.ID_Path
                        LexerTypes.$fEqID_Path
                        ww1
                        ww3 }) -}
a67e643e4d4e273b944906e39fa1fa5f
  $wmakeStateDepTuples ::
    LexerTypes.Name
    -> [LexerTypes.PVSstate]
    -> [LexerTypes.PVSstateDec]
    -> (# [GHC.Base.String], LexerTypes.PVSstateDec #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.Name)
                   (ww1 :: [LexerTypes.PVSstate])
                   (w :: [LexerTypes.PVSstateDec]) ->
                 (# let {
                      ssNameList :: [[GHC.Types.Char]]
                      = let {
                          x :: [[GHC.Types.Char]]
                          = GHC.Base.map
                              @ (LexerTypes.Name, [LexerTypes.PVSstate])
                              @ [GHC.Types.Char]
                              (Data.Tuple.fst @ LexerTypes.Name @ [LexerTypes.PVSstate])
                              w
                        } in
                        GHC.Base.++
                          @ [GHC.Types.Char]
                          x
                          (GHC.Base.map
                             @ [GHC.Types.Char]
                             @ [GHC.Types.Char]
                             PVSGenerator.makeStateDepTuples1
                             x)
                    } in
                    Data.Maybe.catMaybes1
                      @ LexerTypes.Name
                      (GHC.Base.map
                         @ LexerTypes.PVSstate
                         @ (GHC.Base.Maybe LexerTypes.Name)
                         (\ (ds :: LexerTypes.PVSstate) ->
                          case ds of wild {
                            DEFAULT -> GHC.Base.Nothing @ LexerTypes.Name
                            LexerTypes.PVS_SubModuleDec ds1 x ds2
                            -> case GHC.List.elem
                                      @ LexerTypes.Name
                                      GHC.Classes.$fEq[]_$s$fEq[]1
                                      x
                                      ssNameList of wild1 {
                                 GHC.Types.False -> GHC.Base.Nothing @ LexerTypes.Name
                                 GHC.Types.True -> GHC.Base.Just @ LexerTypes.Name x } })
                         ww1),
                    (ww, ww1) #)) -}
bc43b04ca4df6d08bbd20bf8f8a1a08b
  $wneedsHistory ::
    LexerTypes.PVSPackage
    -> [LexerTypes.TransitionTable] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U>,
     Inline: [0] -}
925c605ce1c87bca52781350a3f768e4
  $worderLets ::
    LexerTypes.PVSstateDec
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.TransitionTable]
  {- Arity: 4, Strictness: <L,U(A,U)><L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSstateDec)
                   (w1 :: [LexerTypes.ID_Path])
                   (w2 :: [LexerTypes.TransitionTable])
                   (w3 :: [LexerTypes.TransitionTable]) ->
                 PVSGenerator.orderWires'
                   (GHC.Base.map
                      @ (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
                      @ (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
                      (PVSGenerator.eliminateSubModEntities w1 w)
                      (Data.OldList.nubBy
                         @ (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
                         PVSGenerator.orderLets1
                         (GHC.Base.map
                            @ LexerTypes.TransitionTable
                            @ (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
                            (\ (w4 :: LexerTypes.TransitionTable) ->
                             case PVSGenerator.$wdepTuples w2 w4 of ww { (#,#) ww1 ww2 ->
                             (ww1, ww2) })
                            w3)))) -}
2766f476dcf544c17771178182ebfef3
  $wsameName ::
    LexerTypes.MethodName
    -> LexerTypes.ModuleName
    -> LexerTypes.MethodName
    -> LexerTypes.ModuleName
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.MethodName)
                   (ww1 :: LexerTypes.ModuleName)
                   (ww2 :: LexerTypes.MethodName)
                   (ww3 :: LexerTypes.ModuleName) ->
                 case GHC.Base.eqString ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Base.eqString ww1 ww3 }) -}
1a0d938fdc2a532000615f774ea28502
  $wshowBinding ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.ID_Path
    -> Data.Either.Either
         (GHC.Base.Maybe LexerTypes.BSVType)
         (GHC.Base.Maybe LexerTypes.PVSType)
    -> LexerTypes.Expression
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><S,1*U><S,1*U><L,U><L,U>,
     Inline: [0] -}
f3834245ceff5607782d184e94962052
  $wshowClusterField' ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe LexerTypes.DefaultValue
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.PVSType
    -> GHC.Base.String
    -> LexerTypes.Expression
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 8,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><L,U><L,1*U><S,U><S,U><L,U>,
     Inline: [0] -}
cf003584c8c0786524684551b610375b
  $wshowOutTime :: GHC.Prim.Int# -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
32ac41531ea718f7d8965a4ae3f628f9
  $wshowPVSArgument ::
    GHC.Base.String -> LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: LexerTypes.PVSType) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.genValueMethodHeader4
                      (PVSGenerator.$wshowPVSType ww1))) -}
fb047e9ca78173be17a9373fa97bce6b
  $wshowPVSConstantDeclaration ::
    LexerTypes.PVSPackage
    -> LexerTypes.Name
    -> LexerTypes.PVSType
    -> LexerTypes.Literal
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: LexerTypes.Name)
                   (ww1 :: LexerTypes.PVSType)
                   (ww2 :: LexerTypes.Literal) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.displayArgs1
                      (GHC.Base.++
                         @ GHC.Types.Char
                         (PVSGenerator.$wshowPVSType ww1)
                         (GHC.CString.unpackAppendCString#
                            PVSGenerator.genValueMethodHeader8
                            (PVSGenerator.showPVSExpression
                               w
                               (GHC.Types.[] @ LexerTypes.LocalVar)
                               (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                               (GHC.Base.Just @ LexerTypes.PVSType ww1)
                               ww2
                               (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                               (GHC.Types.[] @ GHC.Types.Char)))))) -}
f8653569a0f850b202eb2399a99e6cb9
  $wshowPVSDefInst ::
    LexerTypes.PVSPackage
    -> LexerTypes.Name
    -> [(LexerTypes.Name, LexerTypes.Literal)]
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: LexerTypes.Name)
                   (ww1 :: [(LexerTypes.Name, LexerTypes.Literal)]) ->
                 case ww1 of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ds1 ds2
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        (GHC.CString.unpackAppendCString#
                           PVSGenerator.showLit1
                           (GHC.Base.++
                              @ GHC.Types.Char
                              ww
                              (GHC.CString.unpackAppendCString# PVSGenerator.displayArgs1 ww)))
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.genTabVars1
                           (GHC.Types.:
                              @ [GHC.Types.Char]
                              (GHC.CString.unpackAppendCString#
                                 PVSGenerator.showPVSDefInst6
                                 (case GHC.Base.map
                                         @ (GHC.Base.String, LexerTypes.Literal)
                                         @ [GHC.Types.Char]
                                         (PVSGenerator.showPVSInstanceDef w ww)
                                         wild of wild1 {
                                    [] -> GHC.Types.[] @ GHC.Types.Char
                                    : x xs1
                                    -> Data.OldList.intercalate_$spoly_go
                                         @ GHC.Types.Char
                                         x
                                         (Data.OldList.prependToAll
                                            @ [GHC.Types.Char]
                                            PVSGenerator.showPVSDefInst4
                                            xs1) }))
                              PVSGenerator.showPVSDefInst1)) }) -}
4a70b22f118101c8205f0b93bd217f53
  $wshowPVSFunc ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> [LexerTypes.PVSArgument]
    -> LexerTypes.PVSType
    -> LexerTypes.Expression
    -> GHC.Base.String
  {- Arity: 5,
     Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: GHC.Base.String)
                   (ww1 :: [LexerTypes.PVSArgument])
                   (ww2 :: LexerTypes.PVSType)
                   (ww3 :: LexerTypes.Expression) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   (GHC.Base.++
                      @ GHC.Types.Char
                      ww
                      (GHC.CString.unpackAppendCString#
                         PVSGenerator.genValueMethodHeader10
                         (case GHC.Base.map
                                 @ (GHC.Base.String, LexerTypes.PVSType)
                                 @ [GHC.Types.Char]
                                 (PVSGenerator.showPVSArgument w)
                                 ww1 of wild {
                            []
                            -> GHC.CString.unpackAppendCString#
                                 PVSGenerator.genValueMethodHeader9
                                 (PVSGenerator.$wshowPVSType ww2)
                            : x xs1
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (Data.OldList.intercalate_$spoly_go
                                    @ GHC.Types.Char
                                    x
                                    (Data.OldList.prependToAll
                                       @ [GHC.Types.Char]
                                       PVSGenerator.genConsProof13
                                       xs1))
                                 (GHC.CString.unpackAppendCString#
                                    PVSGenerator.genValueMethodHeader9
                                    (PVSGenerator.$wshowPVSType ww2)) })))
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.genTabVars1
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         (GHC.CString.unpackAppendCString#
                            PVSGenerator.showPVSFunc1
                            (PVSGenerator.showPVSExpression
                               w
                               (GHC.Base.map
                                  @ (GHC.Base.String, LexerTypes.PVSType)
                                  @ (LexerTypes.ID_Path,
                                     Data.Either.Either
                                       (GHC.Base.Maybe LexerTypes.BSVType)
                                       (GHC.Base.Maybe LexerTypes.PVSType),
                                     LexerTypes.Expression)
                                  (PVSGenerator.args2LVars w)
                                  ww1)
                               (GHC.Base.Just
                                  @ LexerTypes.Expression
                                  (LexerTypes.Identifier
                                     (LexerTypes.ID
                                        (GHC.CString.unpackAppendCString#
                                           PVSGenerator.showLit1
                                           (PVSGenerator.$wshowPVSType ww2)))))
                               (GHC.Base.Just @ LexerTypes.PVSType ww2)
                               ww3
                               (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                               (GHC.Types.[] @ GHC.Types.Char)))
                         (GHC.Types.[] @ [GHC.Types.Char])))) -}
1b178c9cbf088d2684fb7376259f13e6
  $wshowPVSInstanceDef ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> GHC.Base.String
    -> LexerTypes.Literal
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.String)
                   (ww :: GHC.Base.String)
                   (ww1 :: LexerTypes.Literal) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.getVectorInit'1
                      (let {
                         typ'' :: LexerTypes.PVSType
                         = case w of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                           case PVSGenerator.checkForSynonyms ds3 w1 of wild1 {
                             GHC.Base.Nothing
                             -> case PVSGenerator.showPVSInstanceDef2
                                ret_ty LexerTypes.PVSType
                                of {}
                             GHC.Base.Just x
                             -> case x of wild2 {
                                  DEFAULT
                                  -> case PVSGenerator.getFieldType1 ret_ty LexerTypes.PVSType of {}
                                  LexerTypes.PVS_Struct ds fs
                                  -> case GHC.List.lookup
                                            @ GHC.Base.String
                                            @ LexerTypes.PVSType
                                            GHC.Classes.$fEq[]_$s$fEq[]1
                                            ww
                                            fs of wild3 {
                                       GHC.Base.Nothing -> PVSGenerator.showPVSInstanceDef1
                                       GHC.Base.Just x1 -> x1 } } } }
                       } in
                       PVSGenerator.showPVSExpression
                         w
                         (GHC.Types.[] @ LexerTypes.LocalVar)
                         (case typ'' of wild {
                            DEFAULT -> GHC.Base.Nothing @ LexerTypes.Expression
                            LexerTypes.PVS_Custom x
                            -> GHC.Base.Just
                                 @ LexerTypes.Expression
                                 (LexerTypes.Identifier
                                    (LexerTypes.ID
                                       (GHC.CString.unpackAppendCString#
                                          PVSGenerator.showLit1
                                          x))) })
                         (GHC.Base.Just @ LexerTypes.PVSType typ'')
                         ww1
                         (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                         (GHC.Types.[] @ GHC.Types.Char)))) -}
5da1b02e4f01ec748dedd4cff917213c
  $wshowPVSPackage ::
    LexerTypes.PVSPackage
    -> GHC.Base.Maybe LexerTypes.TSPpackage
    -> (# LexerTypes.File, [LexerTypes.File] #)
  {- Arity: 2, Strictness: <L,U(U,1*U,U,U,U,U,U)><L,U>, Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.Maybe LexerTypes.TSPpackage) ->
                 (# (PVSGenerator.showPVSPackage19,
                     PVSGenerator.$wshowPVSTypedefs
                       w
                       (LexerTypes.pvs_constants w)
                       (LexerTypes.pvs_typedefs w)
                       (LexerTypes.pvs_instantiations w)
                       (LexerTypes.pvs_functions w)),
                    let {
                      trans :: [LexerTypes.PVStransition]
                      = case w of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                        ds4 }
                    } in
                    let {
                      nom :: LexerTypes.PackageName
                      = case w of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                        ds1 }
                    } in
                    GHC.Types.:
                      @ ([GHC.Types.Char], GHC.Base.String)
                      (GHC.Base.++ @ GHC.Types.Char nom PVSGenerator.showPVSPackage12,
                       PVSGenerator.showPVSTop w nom trans w1)
                      (case trans of wild {
                         [] -> GHC.Types.[] @ ([GHC.Types.Char], GHC.Base.String)
                         : ds1 ds2
                         -> GHC.Types.:
                              @ ([GHC.Types.Char], GHC.Base.String)
                              (PVSGenerator.showPVSPackage10,
                               PVSGenerator.$wshowPVSStates w (LexerTypes.pvs_state w))
                              (GHC.Types.:
                                 @ ([GHC.Types.Char], GHC.Base.String)
                                 (PVSGenerator.showPVSPackage3, PVSGenerator.showPVSMethods w wild)
                                 (GHC.Types.:
                                    @ ([GHC.Types.Char], GHC.Base.String)
                                    (PVSGenerator.showPVSPackage1,
                                     PVSGenerator.showPVSTrans w nom wild)
                                    (GHC.Types.[] @ ([GHC.Types.Char], GHC.Base.String)))) }) #)) -}
72fe418b8dcb7414b9f9b5082bc4e90a
  $wshowPVSStateInstance ::
    LexerTypes.PVSPackage
    -> LexerTypes.Name -> [LexerTypes.PVSstate] -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U(U,A,U,A,U,U,U)><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: LexerTypes.Name)
                   (ww1 :: [LexerTypes.PVSstate]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.showPVSStateInstance10
                      (GHC.Base.++
                         @ GHC.Types.Char
                         ww
                         (GHC.CString.unpackAppendCString#
                            PVSGenerator.showPVSStateInstance9
                            (GHC.Base.++
                               @ GHC.Types.Char
                               ww
                               (GHC.CString.unpackAppendCString#
                                  PVSGenerator.genValueMethodHeader10
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     ww
                                     (GHC.CString.unpackAppendCString#
                                        PVSGenerator.showPVSStateInstance8
                                        (case w of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                                         case PVSGenerator.wireFilter ds5 of wild1 {
                                           [] -> PVSGenerator.showPVSStateInstance5
                                           : ds11 ds12
                                           -> case PVSGenerator.killStateWires ww1 of wild2 {
                                                [] -> PVSGenerator.showPVSStateInstance5
                                                : ds13 ds14
                                                -> case GHC.Base.map
                                                          @ LexerTypes.PVSstate
                                                          @ [GHC.Types.Char]
                                                          (PVSGenerator.showPVSStateInstance'
                                                             wild
                                                             ww)
                                                          wild2 of wild3 {
                                                     [] -> PVSGenerator.showPVSStateInstance3
                                                     : x xs1
                                                     -> GHC.Base.++
                                                          @ GHC.Types.Char
                                                          (Data.OldList.intercalate_$spoly_go
                                                             @ GHC.Types.Char
                                                             x
                                                             (Data.OldList.prependToAll
                                                                @ [GHC.Types.Char]
                                                                PVSGenerator.showPVSStateInstance1
                                                                xs1))
                                                          PVSGenerator.showPVSStateInstance3 } } } }))))))))) -}
16de420ba96e4acbfa1437590c3e498b
  $wshowPVSStateTypes ::
    LexerTypes.PVSPackage
    -> LexerTypes.Name -> [LexerTypes.PVSstate] -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (ww :: LexerTypes.Name)
                   (ww1 :: [LexerTypes.PVSstate]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.showPVSStateTypes5
                      (case GHC.Base.map
                              @ LexerTypes.PVSstate
                              @ [GHC.Types.Char]
                              (PVSGenerator.showPVSStateDef' w)
                              (PVSGenerator.killStateWires ww1) of wild {
                         [] -> PVSGenerator.showPVSStateTypes3
                         : x xs1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.showPVSStateTypes1
                                    xs1))
                              PVSGenerator.showPVSStateTypes3 }))) -}
2685b4ca0a6c50d70257ccaed85a6a06
  $wshowPVSStates ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstateDec] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><L,U>, Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: [LexerTypes.PVSstateDec]) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   PVSGenerator.showPVSPackage8
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.generateTabspecs1
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         (case GHC.Base.map
                                 @ (LexerTypes.Name, [LexerTypes.PVSstate])
                                 @ [GHC.Types.Char]
                                 (PVSGenerator.showPVSStateTypes w)
                                 (PVSGenerator.orderStates w1) of wild {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : x xs1
                            -> Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.generateTabspecs1
                                    xs1) })
                         (GHC.Types.:
                            @ [GHC.Types.Char]
                            (case GHC.Base.map
                                    @ (LexerTypes.Name, [LexerTypes.PVSstate])
                                    @ [GHC.Types.Char]
                                    (PVSGenerator.showPVSStateInstance w)
                                    (PVSGenerator.orderStates w1) of wild {
                               [] -> GHC.Types.[] @ GHC.Types.Char
                               : x xs1
                               -> Data.OldList.intercalate_$spoly_go
                                    @ GHC.Types.Char
                                    x
                                    (Data.OldList.prependToAll
                                       @ [GHC.Types.Char]
                                       PVSGenerator.generateTabspecs1
                                       xs1) })
                            PVSGenerator.showPVSPackage5)))) -}
af5b3fe3dbd8a5e8c975ac31aed1266b
  $wshowPVSTransitionTable ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> [LexerTypes.ID_Path]
    -> GHC.Types.Bool
    -> GHC.Integer.Type.Integer
    -> [LexerTypes.TransitionTable]
    -> GHC.Base.String
  {- Arity: 6,
     Strictness: <L,U(U,A,U,U,U,U,U)><L,U(A,U)><L,U><L,1*U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: [LexerTypes.ID_Path])
                   (w3 :: GHC.Types.Bool)
                   (ww :: GHC.Integer.Type.Integer)
                   (ww1 :: [LexerTypes.TransitionTable]) ->
                 PVSGenerator.showPVSTransStateCluster
                   w
                   w1
                   (GHC.Types.[] @ GHC.Types.Char)
                   (GHC.Types.[] @ GHC.Types.Char)
                   w2
                   (LexerTypes.TransMod PVSGenerator.addPreIfMissing1 ww1)
                   (case GHC.Show.$w$cshowsPrec4
                           0#
                           ww
                           (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                    GHC.Types.: @ GHC.Types.Char ww3 ww4 })
                   w3) -}
9f4829dcf5f79964018315f84bb359d9
  $wshowPVSType :: LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
3f7ed4e7f001408d36c4f87839bb2896
  $wshowPVSTypedefs ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSConstantDec]
    -> [LexerTypes.PVSTypeDef]
    -> [LexerTypes.PVSInstDef]
    -> [LexerTypes.PVSFunction]
    -> [GHC.Types.Char]
  {- Arity: 5,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,1*U><L,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: [LexerTypes.PVSConstantDec])
                   (w2 :: [LexerTypes.PVSTypeDef])
                   (w3 :: [LexerTypes.PVSInstDef])
                   (w4 :: [LexerTypes.PVSFunction]) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   PVSGenerator.showPVSPackage17
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.generateTabspecs1
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         (case GHC.Base.map
                                 @ (LexerTypes.Name, LexerTypes.PVSType, LexerTypes.Literal)
                                 @ [GHC.Types.Char]
                                 (PVSGenerator.showPVSConstantDeclaration w)
                                 w1 of wild {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : x xs1
                            -> Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.genTabVars1
                                    xs1) })
                         (GHC.Types.:
                            @ [GHC.Types.Char]
                            (PVSGenerator.showPVSTypedefs' w w2)
                            (GHC.Types.:
                               @ [GHC.Types.Char]
                               (case GHC.Base.map
                                       @ (LexerTypes.Name, [(LexerTypes.Name, LexerTypes.Literal)])
                                       @ [GHC.Types.Char]
                                       (PVSGenerator.showPVSDefInst w)
                                       (PVSGenerator.sortDefInsts w3 w2) of wild {
                                  [] -> GHC.Types.[] @ GHC.Types.Char
                                  : x xs1
                                  -> Data.OldList.intercalate_$spoly_go
                                       @ GHC.Types.Char
                                       x
                                       (Data.OldList.prependToAll
                                          @ [GHC.Types.Char]
                                          PVSGenerator.generateTabspecs1
                                          xs1) })
                               (GHC.Types.:
                                  @ [GHC.Types.Char]
                                  (case GHC.Base.map
                                          @ (GHC.Base.String, [LexerTypes.PVSArgument],
                                             LexerTypes.PVSType, LexerTypes.Expression)
                                          @ [GHC.Types.Char]
                                          (PVSGenerator.showPVSFunc w)
                                          w4 of wild {
                                     [] -> GHC.Types.[] @ GHC.Types.Char
                                     : x xs1
                                     -> Data.OldList.intercalate_$spoly_go
                                          @ GHC.Types.Char
                                          x
                                          (Data.OldList.prependToAll
                                             @ [GHC.Types.Char]
                                             PVSGenerator.generateTabspecs1
                                             xs1) })
                                  PVSGenerator.showPVSPackage14)))))) -}
699e1dc722e349b92ce23a806f05576b
  $wshowPVSvariable ::
    LexerTypes.PVSType -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.PVSType)
                   (ww1 :: [GHC.Base.String]) ->
                 case ww1 of wild {
                   []
                   -> GHC.CString.unpackAppendCString#
                        PVSGenerator.showPVSvariable1
                        (PVSGenerator.$wshowPVSType ww)
                   : x xs1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (Data.OldList.intercalate_$spoly_go
                           @ GHC.Types.Char
                           x
                           (Data.OldList.prependToAll
                              @ [GHC.Types.Char]
                              PVSGenerator.genConsProof13
                              xs1))
                        (GHC.CString.unpackAppendCString#
                           PVSGenerator.showPVSvariable1
                           (PVSGenerator.$wshowPVSType ww)) }) -}
3d32dce9f28a30ce48ddf582fa9f88f7
  $wshowValueMethod ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVStransition]
    -> LexerTypes.MethodName
    -> LexerTypes.ModuleName
    -> GHC.Base.String
    -> LexerTypes.PVSType
    -> LexerTypes.Expression
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
2c5c20b73363c4e2d584f76975115406
  $wsplitAtFifoMethod ::
    LexerTypes.ID_Path
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> (# GHC.Base.String, [GHC.Base.String], [GHC.Base.String] #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U>, Inline: [0] -}
2ce49b342c450d53ea0c4d1d21a5caca
  $wsplitAtFifoMethod' ::
    LexerTypes.ID_Path
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> (# GHC.Base.String, [GHC.Base.String], [GHC.Base.String] #)
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,1*U>, Inline: [0] -}
6ac0ef2b423a4e2fe6334b2b7e202d1f
  addPreIfMissing :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.ID_Path) ->
                 case w of wild {
                   LexerTypes.ID_Submod_Struct x y
                   -> case GHC.Base.eqString
                             x
                             PVSGenerator.addPreIfMissing1 of wild1 {
                        GHC.Types.False
                        -> LexerTypes.ID_Submod_Struct
                             PVSGenerator.addPreIfMissing1
                             (LexerTypes.ID_Submod_Struct x y)
                        GHC.Types.True -> LexerTypes.ID_Submod_Struct x y }
                   LexerTypes.ID x
                   -> LexerTypes.ID_Submod_Struct
                        PVSGenerator.addPreIfMissing1
                        (LexerTypes.ID x)
                   LexerTypes.ID_Vect x y
                   -> LexerTypes.ID_Submod_Struct
                        PVSGenerator.addPreIfMissing1
                        (LexerTypes.ID_Vect x y) }) -}
0411b5f002ae380327707993eefa99c9
  addPreIfMissing' :: LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.Expression) ->
                 case ds of wild {
                   DEFAULT -> wild
                   LexerTypes.Identifier ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> LexerTypes.Identifier
                             (case wild1 of wild2 {
                                LexerTypes.ID_Submod_Struct x y
                                -> case GHC.Base.eqString
                                          x
                                          PVSGenerator.addPreIfMissing1 of wild3 {
                                     GHC.Types.False
                                     -> LexerTypes.ID_Submod_Struct
                                          PVSGenerator.addPreIfMissing1
                                          wild2
                                     GHC.Types.True -> wild2 }
                                LexerTypes.ID_Vect x y
                                -> LexerTypes.ID_Submod_Struct
                                     PVSGenerator.addPreIfMissing1
                                     wild2 })
                        LexerTypes.ID x
                        -> case Data.OldList.isPrefixOf
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqChar
                                  PVSGenerator.addPreIfMissing'3
                                  x of wild2 {
                             GHC.Types.False
                             -> case Data.OldList.isPrefixOf
                                       @ GHC.Types.Char
                                       GHC.Classes.$fEqChar
                                       PVSGenerator.addPreIfMissing'1
                                       x of wild3 {
                                  GHC.Types.False
                                  -> LexerTypes.Identifier
                                       (LexerTypes.ID_Submod_Struct
                                          PVSGenerator.addPreIfMissing1
                                          wild1)
                                  GHC.Types.True -> wild }
                             GHC.Types.True -> wild } } }) -}
d0ba374c6071b6ebb454d48eb732e46f
  addPreIfMissing'1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.addPreIfMissing'2) -}
d17ec8c56c1da0486de0d96b11d09674
  addPreIfMissing'2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("value_"#) -}
cd0860ebd60f7b954db3f30e804487be
  addPreIfMissing'3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.addPreIfMissing'4) -}
35a1a25862744dc5f5d713c8d2d15b82
  addPreIfMissing'4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("wr_"#) -}
387f163ba0f9cdfd235ba55d6abd74a2
  addPreIfMissing1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.addPreIfMissing2) -}
a23a5556a8df01a509405c56f2e10ad7
  addPreIfMissing2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pre"#) -}
a07dd0240f42794cd7bed861a9288616
  addSuffix ::
    LexerTypes.ID_Path -> GHC.Base.String -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
cecf5a3b1138ffdcac3af9702c1ce82b
  addVectExptoID ::
    LexerTypes.ID_Path -> LexerTypes.Expression -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
6c0872db2ea24ec6eca4a4de18881eed
  args2LVars ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSArgument -> LexerTypes.LocalVar
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (uni :: LexerTypes.PVSPackage)
                   (ds :: (GHC.Base.String, LexerTypes.PVSType)) ->
                 case ds of wild { (,) x y ->
                 (LexerTypes.ID x,
                  Data.Either.Right
                    @ (GHC.Base.Maybe LexerTypes.BSVType)
                    @ (GHC.Base.Maybe LexerTypes.PVSType)
                    (GHC.Base.Just @ LexerTypes.PVSType y),
                  LexerTypes.Skip) }) -}
5b8ba31f9c5715c78221d9ae2f14c447
  argsMatch ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVStransition
    -> LexerTypes.PVStransition
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*U,A,A,A,A)><S(LSLL),1*U(A,1*U,A,A)><S(LSLL),1*U(A,1*U,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVStransition)
                   (w2 :: LexerTypes.PVStransition) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 case w2 of ww5 { (,,,) ww6 ww7 ww8 ww9 ->
                 PVSGenerator.$wargsMatch w ww2 ww7 } }) -}
8d95c61e10ee80e65b67f076b5f8826c
  argsMatch_go ::
    [[(LexerTypes.MethodArg, LexerTypes.PVSType)]]
    -> [[(LexerTypes.MethodArg, LexerTypes.PVSType)]]
    -> [[(LexerTypes.MethodArg, LexerTypes.PVSType)]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
563c0602a4833f8d09d148fcd146f83e
  badType :: GHC.Base.Maybe LexerTypes.PVSType
  {- Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ LexerTypes.PVSType
                   PVSGenerator.badType1) -}
909cf6aea70c40c8fed1a4c0d1fc7665
  badType1 :: LexerTypes.PVSType
  {- Strictness: m6,
     Unfolding: (LexerTypes.PVS_Custom PVSGenerator.badType2) -}
12adc988ea523a714b634971bf062bc2
  badType2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# PVSGenerator.badType3) -}
e0a0d7c2c4607b6361bcba594badbe79
  badType3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Loto"#) -}
aad66b9a8712db171dbb1ef0edc49788
  branchTest ::
    LexerTypes.InvokationTree -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U> -}
2ae8159015d5b188fdb0ab9fe76fffad
  checkForSynonyms ::
    [LexerTypes.PVSTypeDef]
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.PVSTypeDef
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
269de1b6e2efba608970ffc22af3b8a8
  constructInvokationTree ::
    LexerTypes.PVSPackage -> LexerTypes.InvokationTree
  {- Arity: 1, Strictness: <S(LLLLSLL),1*U(U,A,A,A,U,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.PVSPackage) ->
                 case w of ww { LexerTypes.PVSPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PVSGenerator.$wconstructInvokationTree ww1 ww5 }) -}
270a5d5208d39cffd4639cf64facf7f4
  constructInvokationTree' ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> LexerTypes.PVSstateDec
    -> LexerTypes.InvokationTree
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,U,A,A)><L,U><S(LS),1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.String)
                   (w2 :: LexerTypes.PVSstateDec) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wconstructInvokationTree' w w1 ww1 ww2 }) -}
341d8207697a61b430a0bbffaa49d17f
  constructInvokationTree1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.constructInvokationTree2) -}
5eb0ca9789171a87331f35596c67d52d
  constructInvokationTree10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [PVSTypeDef]"#) -}
69c0f555f059579cc5e1eb98e980d9ba
  constructInvokationTree11 :: [LexerTypes.PVSConstantDec]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.PVSConstantDec]
                   PVSGenerator.constructInvokationTree12) -}
90ee3302bf1991daa18e532d95a98bde
  constructInvokationTree12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [PVSConstantDec]"#) -}
9b1f63754c3cb9a385a17869fea92486
  constructInvokationTree13 ::
    (LexerTypes.PackageName, [LexerTypes.PVSstate])
  {- Strictness: x -}
8ee51ef716d525951e3f0277bef00499
  constructInvokationTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("root"#) -}
9256669585a76185941b01dce2d9367e
  constructInvokationTree3 :: [LexerTypes.PVSFunction]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.PVSFunction]
                   PVSGenerator.constructInvokationTree4) -}
3d8ff8322b8337ec54fe4361e1192a1c
  constructInvokationTree4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [PVSFunction]"#) -}
cced8c3b1239f0b33c100499d33c4f8a
  constructInvokationTree5 :: [LexerTypes.PVSInstDef]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.PVSInstDef]
                   PVSGenerator.constructInvokationTree6) -}
b61e82e51bec6bb6f468483feee8b1c8
  constructInvokationTree6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [PVSInstDef]"#) -}
a9212811dbe9186ea0730f1f2fd2cb6f
  constructInvokationTree7 :: [LexerTypes.PVStransition]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.PVStransition]
                   PVSGenerator.constructInvokationTree8) -}
c343d9026813cc69189c6683c6d97bed
  constructInvokationTree8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [PVStransition]"#) -}
4cefa03950a8809b9abbad9e0550557f
  constructInvokationTree9 :: [LexerTypes.PVSTypeDef]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.PVSTypeDef]
                   PVSGenerator.constructInvokationTree10) -}
1864b281ab4db4a523dc80e7eba88231
  containsFifoMethod :: LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
c0df5d48e55cea1eabec9829d2723845
  convertMeths2Name :: [GHC.Base.String] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (xss :: [[GHC.Types.Char]]) ->
                 case xss of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.convertMeths2Name_xs
                           xs1) }) -}
a7903420028e188285501814edec3482
  convertMeths2Name1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_m_"#) -}
80349ec1b75506814fa597614b72b365
  convertMeths2Name_xs :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.convertMeths2Name1) -}
0b433b50475258f7eff63df9f58323c2
  createEquivalencePairings ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> (LexerTypes.ID_Path, GHC.Base.String)
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,A><S,1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.String)
                   (w2 :: (LexerTypes.ID_Path, GHC.Base.String)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wcreateEquivalencePairings w ww1 ww2 }) -}
e6a16c1d0304c3214ce307476a6b5fe2
  createEquivalencePairings1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.createEquivalencePairings2) -}
395db632468c9eccf8ae0c97b81bbd2b
  createEquivalencePairings2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(0, s(next(t)), s(next(t)))"#) -}
655da692e9222a96421db6ae13394b57
  createEquivalencePairings3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(next(t)) = "#) -}
7bc1570ac50be593752b3f1f91460dfc
  createHistoryPairings ::
    GHC.Base.String
    -> (GHC.Base.String, GHC.Base.String) -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wcreateHistoryPairings w ww1 ww2 }) -}
f703b0565efed3ec61c64338997df7a3
  createHistoryPairings1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.createHistoryPairings2) -}
f9f580951c87964dea25b3feaca8334c
  createHistoryPairings2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(s(t))"#) -}
1529c6cb14166fce0b0835b1a11e9686
  createHistoryPairings3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_"#) -}
a6af3b04679c43d47cd43a79626e58ef
  createHistoryPairings4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(t) = "#) -}
cb1b8ccfdeb59e7ee0bf3e1b1d7eb655
  crunchTruples ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    [(a, b, c)] -> [([(a, b)], c)]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,A><L,U(C(C1(U)),C(C1(U)))><S,1*U>, Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: GHC.Classes.Eq c)
                   (w3 :: [(a, b, c)]) ->
                 PVSGenerator.$wcrunchTruples @ a @ b @ c w2 w3) -}
1e0aa6148fcd37d33d117035cb246b42
  crunchTruples_$scrunchTruples ::
    [(GHC.Integer.Type.Integer, GHC.Base.String,
      [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> [([(GHC.Integer.Type.Integer, GHC.Base.String)],
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a082cdff9e89550e65fd32a6bea0defe
  crunchTuples ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) => [(a, b)] -> [([a], b)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C1(U)),C(C1(U)))><S,1*U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: [(a, b)]) ->
                 PVSGenerator.$wcrunchTuples @ a @ b w1 w2) -}
df0dd10467047c3fde002fce283906d3
  crunchTuples_$scrunchTuples ::
    [(GHC.Integer.Type.Integer, GHC.Base.String)]
    -> [([GHC.Integer.Type.Integer], GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
571d054ac7d2f874e954260590b7c162
  deAlias ::
    [LexerTypes.PVSTypeDef] -> LexerTypes.PVSType -> LexerTypes.PVSType
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (tds :: [LexerTypes.PVSTypeDef]) (ds :: LexerTypes.PVSType) ->
                 case ds of wild {
                   DEFAULT -> wild
                   LexerTypes.PVS_Custom x -> PVSGenerator.tdLookup tds x }) -}
aa439966258f1daaad613ec1725fec96
  deAliasArg ::
    [LexerTypes.PVSTypeDef]
    -> (LexerTypes.MethodArg, LexerTypes.PVSType)
    -> (LexerTypes.MethodArg, LexerTypes.PVSType)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (tds :: [LexerTypes.PVSTypeDef])
                   (ds :: (LexerTypes.MethodArg, LexerTypes.PVSType)) ->
                 case ds of wild { (,) n t -> (n, PVSGenerator.deAlias tds t) }) -}
64bc2a575357440869c4c8cd22ccbac5
  def2exp ::
    LexerTypes.PVSInstDef
    -> LexerTypes.PVSType -> LexerTypes.Expression
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U)><L,U>m38,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (LexerTypes.Name,
                           [(LexerTypes.Name, LexerTypes.Literal)]))
                   (t :: LexerTypes.PVSType) ->
                 case ds of wild { (,) n fs ->
                 LexerTypes.StructCluster
                   (Data.Either.Right @ LexerTypes.BSVType @ LexerTypes.PVSType t)
                   fs }) -}
a35030eac14e92cf40b8ac4bf9840b06
  def2string ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSTypeDef
    -> LexerTypes.PVSInstDef
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(A,A,U,A,A,U,A)><L,U><S,1*U(A,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSTypeDef)
                   (w2 :: LexerTypes.PVSInstDef) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wdef2string w w1 ww2 }) -}
a15cda46a540058cac38ffa8559cc327
  def2string' ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSTypeDef
    -> (LexerTypes.Name, LexerTypes.Literal)
    -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(A,A,U,A,A,U,A)><L,1*U><S(SS),1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSTypeDef)
                   (w2 :: (LexerTypes.Name, LexerTypes.Literal)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wdef2string' w w1 ww1 ww2 }) -}
c048977a97c89ca2a98f021913332bb0
  def2string1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.def2string2) -}
eba6a7bcac7a978f910953731db5bb07
  def2string2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t\t, "#) -}
68557a8ff61b45e7e7655af5b35a0ae7
  def2string3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.def2string4) -}
2da2368509ccf495f542a02aa14cc17b
  def2string4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t\t#)"#) -}
2877212cfe4c08ad06181a843005d41a
  def2string5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(# "#) -}
98b168cbb18caba6b734a3c8fc7d6fbf
  defaultVal :: LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.PVSType) ->
                 case ds of wild {
                   LexerTypes.PVS_Bool -> PVSGenerator.defaultVal6
                   LexerTypes.PVS_Bit ds1 -> PVSGenerator.defaultVal4
                   LexerTypes.PVS_Int ds1 -> PVSGenerator.defaultVal4
                   LexerTypes.PVS_UInt ds1 -> PVSGenerator.defaultVal4
                   LexerTypes.PVS_Real -> PVSGenerator.defaultVal2
                   LexerTypes.PVS_Custom nom -> PVSGenerator.defaultVal4
                   LexerTypes.PVS_Maybe ipv -> PVSGenerator.defaultVal1 }) -}
5c5ef0371416c30ded15be748d5d6c1c
  defaultVal1 :: GHC.Base.String
  {- Strictness: x -}
0734ffa827aed4e016ea133007db016b
  defaultVal2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.defaultVal3) -}
401a5ff419b63a2d89e3627b65acbb59
  defaultVal3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("0.0"#) -}
46e55f0f161c8a798ae867c49cf3c1f9
  defaultVal4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.defaultVal5) -}
136dd30bf9d9f6b6e994ba254c815868
  defaultVal5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("0"#) -}
85ca995f17e67cf69f77c69db33020cf
  defaultVal6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.defaultVal7) -}
4194fc75341839b11aba65fd70add3dc
  defaultVal7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("false"#) -}
c48e80434cba8b0cf7c71c74fab8197d
  deleteTable ::
    [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
    -> LexerTypes.TransitionTable
    -> [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
fdb29a5d8531fed5437376546842efcf
  depTuples ::
    [LexerTypes.PVSstateDec]
    -> [LexerTypes.TransitionTable]
    -> LexerTypes.TransitionTable
    -> (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
  {- Arity: 3, Strictness: <L,A><L,U><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [LexerTypes.PVSstateDec])
                   (w1 :: [LexerTypes.TransitionTable])
                   (w2 :: LexerTypes.TransitionTable) ->
                 case PVSGenerator.$wdepTuples w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
4b9aae74f0e7ea67fda32837653ea1e1
  desynonymize ::
    [LexerTypes.PVSTypeDef]
    -> [(LexerTypes.MethodName,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> [(LexerTypes.MethodName,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
027578b3a91ef5394ddc8714aa77a38b
  desynonymize' ::
    [LexerTypes.PVSTypeDef]
    -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
    -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
2660dc8ea1d5df7c419c1720fa2ff9e0
  displayArgs ::
    LexerTypes.PVSPackage
    -> (LexerTypes.MethodArg, LexerTypes.PVSType) -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: (LexerTypes.MethodArg, LexerTypes.PVSType)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wdisplayArgs ww1 ww2 }) -}
110846576f9d6382991e6bb00d113d37
  displayArgs' :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (xs :: GHC.Base.String) ->
                 case PVSGenerator.getNumericSuffix xs of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.++ @ GHC.Types.Char xs PVSGenerator.displayArgs'4
                   GHC.Base.Just x
                   -> case GHC.List.dropWhile
                             @ GHC.Types.Char
                             PVSGenerator.displayArgs'3
                             (GHC.List.reverse1
                                @ GHC.Types.Char
                                xs
                                (GHC.Types.[] @ GHC.Types.Char)) of wild1 {
                        []
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PVSGenerator.displayArgs'2
                             (GHC.CString.unpackAppendCString# PVSGenerator.displayArgs'1 x)
                        : ds1 ds2
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             (GHC.List.reverse1
                                @ GHC.Types.Char
                                ds2
                                (GHC.Types.[] @ GHC.Types.Char))
                             (GHC.CString.unpackAppendCString#
                                PVSGenerator.displayArgs'1
                                x) } }) -}
4002550ada154c5e3a1e18691e6e628a
  displayArgs'1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
fa8c8b029aa32c2b6b3e7345c370efd4
  displayArgs'2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.List.reverse1
                   @ GHC.Types.Char
                   (GHC.Types.[] @ GHC.Types.Char)
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e9e8bfce8c4836409293d13aead8403c
  displayArgs'3 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.True '_'# -> GHC.Types.False } }) -}
1faac73e9d27d50541ccab9993c41191
  displayArgs'4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.displayArgs'5) -}
c79f67e712bbde13e03fcd98c53bd617
  displayArgs'5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!1"#) -}
afd242dea4c219add9673183111e4cad
  displayArgs1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : "#) -}
42f4a1ea3c31723389eab79df0e8e575
  displaySchedule ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVStransition -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S(SSLL),1*U(U,U,A,A)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVStransition) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 PVSGenerator.$wdisplaySchedule ww1 ww2 }) -}
453dea65c04e06c35ccd6276e01d338d
  doesntNeed ::
    LexerTypes.PVSTypeDef -> [LexerTypes.PVSTypeDef] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
2316427704e5e16d9f077425d38e5a72
  drillOutSynonyms ::
    [LexerTypes.PVSTypeDef] -> LexerTypes.PVSType -> LexerTypes.PVSType
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
8dea60e0d8b11479f3a531af3d28d9ea
  elimRedundantEntries ::
    [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 1, Strictness: <S,1*U> -}
f3823dad52f57a99d69d086cdce1c550
  eliminateSubModEntities ::
    [LexerTypes.ID_Path]
    -> LexerTypes.PVSstateDec
    -> (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
    -> (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
  {- Arity: 3, Strictness: <L,U><L,1*U(A,1*U)><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [LexerTypes.ID_Path])
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: (LexerTypes.TransitionTable, [LexerTypes.ID_Path])) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case PVSGenerator.$weliminateSubModEntities
                        w
                        w1
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
ff610aee12edfbd5a7f6b6f874cd36d9
  eliminateSubModEntities1 :: GHC.Types.Bool
  {- Strictness: x -}
0ee02a7ea2ad57d7c6ee5b9de01e4ce7
  expandTable ::
    GHC.Base.Maybe LexerTypes.ID_Path
    -> LexerTypes.TransitionTable -> [LexerTypes.TransitionTable]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
78bc67bba6416781c94b3d56845cb66b
  extractFifos ::
    [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c586713e7b1df2034f121e3adfaccf41
  extractWires ::
    LexerTypes.PVStransition -> [LexerTypes.TransitionTable]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Integer.Type.Integer,
                           [(LexerTypes.MethodName,
                             [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
                           [LexerTypes.ValueMethod], [LexerTypes.TransitionTable])) ->
                 case ds of wild { (,,,) ds1 ds2 ds3 xs ->
                 PVSGenerator.extractWires' xs }) -}
27ae1dce9cbe2039673e5ead50e31b94
  extractWires' ::
    [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
06e55159ec2c3b051ca0a0603885910e
  filterWires ::
    [LexerTypes.ID_Path]
    -> [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
842f6cbf24ea0e1ba7cacfec11ba5784
  filterWires' ::
    [LexerTypes.TransitionTable]
    -> [LexerTypes.ID_Path] -> [LexerTypes.ID_Path]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
47c5b707c9761f48cb8fefa74a9738bd
  findField ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVS_Field]
    -> GHC.Base.String
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ (uni :: LexerTypes.PVSPackage)
                   (xs :: [LexerTypes.PVS_Field])
                   (y :: GHC.Base.String) ->
                 case GHC.List.lookup
                        @ GHC.Base.String
                        @ LexerTypes.PVSType
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        y
                        xs of wild {
                   GHC.Base.Nothing -> PVSGenerator.findField1
                   GHC.Base.Just x -> PVSGenerator.getTypeBitSize uni x }) -}
5c5a53e2e5619a3993f797e5d9136eb9
  findField1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
dbfcd6396ba22f6f4b3e288b5f4e1256
  findPVSState ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstateDec]
    -> LexerTypes.ID_Path
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U><S,1*U> -}
b8f951856ce92da19478bd3f909ceed6
  findPVSState' ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstate]
    -> LexerTypes.ID_Path
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U><L,U> -}
695d22d359ef836a237c0e1c87e46c5f
  findPVSState'' ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstateDec]
    -> LexerTypes.Context
    -> LexerTypes.ID_Path
    -> GHC.Integer.Type.Integer
  {- Arity: 4,
     Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U><S,1*U><S,U> -}
a7ef429f6582bcb27c065fae7b29b571
  findPVSState''' ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstate]
    -> LexerTypes.ID_Path
    -> LexerTypes.PVSType
  {- Arity: 3, Strictness: <L,A><S,1*U><S,U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: [LexerTypes.PVSstate])
                   (w2 :: LexerTypes.ID_Path) ->
                 PVSGenerator.$wfindPVSState''' w1 w2) -}
67d3d8cc77311df5b6ddfa6d0c311ced
  findPVSStateType ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstateDec]
    -> LexerTypes.ID_Path
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (ds :: [LexerTypes.PVSstateDec])
                   (x :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   [] -> PVSGenerator.findPVSStateType2 x
                   : ds1 xs
                   -> case ds1 of wild1 { (,) x1 ys ->
                      case x of wild2 {
                        DEFAULT -> PVSGenerator.findPVSStateType1
                        LexerTypes.ID_Submod_Struct p q
                        -> case GHC.Base.eqString x1 p of wild3 {
                             GHC.Types.False -> PVSGenerator.findPVSState uni xs wild2
                             GHC.Types.True -> PVSGenerator.findPVSState' uni ys q } } } }) -}
7cdb4606aac575c633ecc2b51a661092
  findPVSStateType1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
4db85dcf6817fe9ddf6d20bee6ca8b98
  findPVSStateType2 :: LexerTypes.ID_Path -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <B,1*U>x -}
7af937b70278f6dd8122d0616b645fc7
  findPathToName ::
    LexerTypes.InvokationTree -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><S,U>m2, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.InvokationTree) (w1 :: GHC.Base.String) ->
                 case PVSGenerator.$wfindPathToName w w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Base.String ww1 ww2 }) -}
fe531d41b50bfb92d928948550611630
  findTypeDef ::
    [LexerTypes.PVSTypeDef]
    -> LexerTypes.PVSType -> LexerTypes.PVSTypeDef
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
a3a6c59bbbc4dc15d0a79b1aa2213a2c
  fixDV ::
    GHC.Base.Maybe LexerTypes.PVSType
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: GHC.Base.Maybe LexerTypes.PVSType)
                   (x :: LexerTypes.Expression) ->
                 case ds of wild {
                   GHC.Base.Nothing -> x
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> x
                        LexerTypes.PVS_Maybe t
                        -> case x of wild2 {
                             DEFAULT
                             -> LexerTypes.Tagged
                                  (GHC.Base.Just @ LexerTypes.PVSType t)
                                  (LexerTypes.Valid wild2)
                             LexerTypes.Tagged x1 y -> wild2 } } }) -}
1bb54f71ac83278aa6b140abde23eba1
  fixDV' :: LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.Expression) ->
                 case ds of wild {
                   DEFAULT -> wild
                   LexerTypes.Identifier i
                   -> LexerTypes.Identifier (PVSGenerator.removePathOverlaps i) }) -}
32f359fdc7c4696a20c453774c375e53
  followStructs ::
    [LexerTypes.PVSTypeDef]
    -> LexerTypes.ID_Path -> LexerTypes.PVSType -> LexerTypes.PVSType
  {- Arity: 3, Strictness: <S,U><S,U><S,U> -}
67dbbae3e61c961a2b75f79b83ace934
  gatherPastTransPred ::
    GHC.Base.String -> LexerTypes.PVStransition -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U(A,U,A,A)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: LexerTypes.PVStransition) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 PVSGenerator.$wgatherPastTransPred w ww2 }) -}
ee9ddb11b229a8c1ca32485e646a0856
  gatherPastTransPred1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.createHistoryPairings3) -}
b9144ea38581718807290c1e9b5e4996
  gatherPastTransPred10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_t_m_"#) -}
a13de135461ef0327c5a2699d614912d
  gatherPastTransPred2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.gatherPastTransPred3) -}
ffad8ad9523bd65f93d7175710dd5f9a
  gatherPastTransPred3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(pre(t)))"#) -}
b3642343a27e57c7dbb886710b4c3e38
  gatherPastTransPred4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.gatherPastTransPred5) -}
7ac6261c95a1eb58de997d51a5bc72f9
  gatherPastTransPred5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(t), "#) -}
b9e50ac76d6111bb4bcd0b79b3dc0063
  gatherPastTransPred6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", "#) -}
098909b1cc6573360639a55502bdd89b
  gatherPastTransPred7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.gatherPastTransPred8) -}
a04830198a3f57222d7190f540956141
  gatherPastTransPred8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (")"#) -}
6a618d6093222b8b62e04354c9a882d0
  gatherPastTransPred9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" (s(pre(t)), s(t)"#) -}
c432ffd515aae78bdee788283c5b8ed1
  gatherPastTransPred_go ::
    [(LexerTypes.MethodName,
      [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
5ba11e3caa1d055a044ece036e433d7b
  gatherTransPred'' ::
    GHC.Base.String -> LexerTypes.PVStransition -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S,1*U(A,1*U,A,A)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Base.String) (w1 :: LexerTypes.PVStransition) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 PVSGenerator.$wgatherTransPred'' ww2 }) -}
11569f34ac09c267d43c00c3b4cd117c
  gatherTransPred''1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.gatherTransPred''2) -}
d038802c67956885b5ee2f95a06ff34b
  gatherTransPred''2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(t))"#) -}
a64773b63ac284188922b25976491f98
  gatherTransPred''3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("transition (1, s(t), s(next(t))"#) -}
0155f0fa8adb4f3980ab0e55f563bbd2
  gatherTransPred''_go ::
    [(LexerTypes.MethodName,
      [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
afbdbc96be7da4fc1cd96928a3511f91
  genConsProof :: [LexerTypes.PVStransition] -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (ts :: [LexerTypes.PVStransition]) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.genConsProof25
                      (case GHC.Base.map
                              @ (GHC.Integer.Type.Integer,
                                 [(LexerTypes.MethodName,
                                   [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
                                 [LexerTypes.ValueMethod], [LexerTypes.TransitionTable])
                              @ [GHC.Types.Char]
                              PVSGenerator.genConsProof24
                              ts of wild {
                         [] -> PVSGenerator.genConsProof22
                         : x xs1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.gatherPastTransPred1
                                    xs1))
                              PVSGenerator.genConsProof22 }))
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.genConsProof20
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         PVSGenerator.genConsProof18
                         (GHC.Types.:
                            @ [GHC.Types.Char]
                            (GHC.CString.unpackAppendCString#
                               PVSGenerator.genConsProof17
                               (case ts of wild {
                                  [] -> case GHC.List.badHead ret_ty [GHC.Types.Char] of {}
                                  : x ds1
                                  -> case x of wild1 { (,,,) ds x1 ds2 ds3 ->
                                     case PVSGenerator.genConsProof_go x1 of wild2 {
                                       [] -> PVSGenerator.genConsProof15
                                       : ds4 ds5
                                       -> GHC.CString.unpackAppendCString#
                                            PVSGenerator.gatherPastTransPred6
                                            (case GHC.Base.map
                                                    @ (LexerTypes.MethodArg, LexerTypes.PVSType)
                                                    @ [GHC.Types.Char]
                                                    PVSGenerator.genConsProof14
                                                    wild2 of wild3 {
                                               [] -> PVSGenerator.genConsProof15
                                               : x2 xs1
                                               -> GHC.Base.++
                                                    @ GHC.Types.Char
                                                    (Data.OldList.intercalate_$spoly_go
                                                       @ GHC.Types.Char
                                                       x2
                                                       (Data.OldList.prependToAll
                                                          @ [GHC.Types.Char]
                                                          PVSGenerator.genConsProof13
                                                          xs1))
                                                    PVSGenerator.genConsProof15 }) } } }))
                            PVSGenerator.genConsProof1)))) -}
95b1ce8ee990410201c7a77ae089c099
  genConsProof1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genConsProof11
                   PVSGenerator.genConsProof2) -}
1728529a15d33d28c80a67e19b06c420
  genConsProof10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("      (rewrite transition_val)"#) -}
2696a063cc3c1dca037af9d0db945e62
  genConsProof11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof12) -}
4ac05074019280f4f3dd01efdefaf424
  genConsProof12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("      (rewrite transition)"#) -}
7d83201b9495e4184e65b21a56925538
  genConsProof13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.gatherPastTransPred6) -}
6ff1fc0e33011fa33635ac172ff90c2a
  genConsProof14 ::
    (LexerTypes.MethodArg, LexerTypes.PVSType) -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (LexerTypes.MethodArg, LexerTypes.PVSType)) ->
                 case x of wild { (,) x1 ds1 -> PVSGenerator.displayArgs' x1 }) -}
ef9e03e6779bcf9b96cca779965654b9
  genConsProof15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof16) -}
7215bef896a215cf0feaf45540aed555
  genConsProof16 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (")\")"#) -}
9068170f4fd8f85032fd78b2c1ab0ed2
  genConsProof17 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("      (inst + \"transition_val (i!1,pre!1"#) -}
1b2ce793e15ab16e6773ec8c0728d6e0
  genConsProof18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof19) -}
a1ff11eba3d3d17d9c50e899f5c57bd1
  genConsProof19 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(then (skolem!)"#) -}
818856a4a693f3436c0273fe43549671
  genConsProof2 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genConsProof9
                   PVSGenerator.genConsProof3) -}
d6ac77b8b9a58ab5ac807b39f184a2e5
  genConsProof20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof21) -}
2a256babaca4c6ed937618a980042c60
  genConsProof21 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \%|- "#) -}
65da3337fadf271a0ba239c2d540a798
  genConsProof22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof23) -}
796f5a552792c3aba1aed81ec47a73eb
  genConsProof23 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : PROOF"#) -}
29f101ec8bf561eba7a8dd643736ccd6
  genConsProof24 ::
    (GHC.Integer.Type.Integer,
     [(LexerTypes.MethodName,
       [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
     [LexerTypes.ValueMethod], [LexerTypes.TransitionTable])
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SLLL),1*U(U,A,A,A)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (GHC.Integer.Type.Integer,
                          [(LexerTypes.MethodName,
                            [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
                          [LexerTypes.ValueMethod], [LexerTypes.TransitionTable])) ->
                 case x of wild { (,,,) x1 ds ds1 ds2 ->
                 case GHC.Show.$w$cshowsPrec4
                        0#
                        x1
                        (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                 GHC.Types.: @ GHC.Types.Char ww3 ww4 } }) -}
b5d02d9212a13c58d96914004867653d
  genConsProof25 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \%|- consistency_"#) -}
846b4c5aa78e90ba9a8a287a719699e5
  genConsProof3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genConsProof7
                   PVSGenerator.genConsProof4) -}
b81525eb98af44b3f05caa6ef8594ca5
  genConsProof4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genConsProof5
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
2ca6b6898deae9855d3bea7c8794395e
  genConsProof5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof6) -}
b944129b45f40098ec2dc0641f71adbd
  genConsProof6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("QED"#) -}
9396f27bb5cb243bbe5c2f502c22cd0b
  genConsProof7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof8) -}
d13e527249750f38209133b599717f31
  genConsProof8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("      (assert))"#) -}
cf448003a5d8e450ad73c8508aceb21b
  genConsProof9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genConsProof10) -}
6964b71938bfb2ac4abf901e7dcf5203
  genConsProof_go ::
    [(LexerTypes.MethodName,
      [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
    -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8d9463af86c3bf50265f46ccc80acf43
  genConsTheorem ::
    LexerTypes.PVSPackage
    -> GHC.Base.String -> [LexerTypes.PVStransition] -> GHC.Base.String
  {- Arity: 3, Strictness: <L,A><L,U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.String)
                   (w2 :: [LexerTypes.PVStransition]) ->
                 PVSGenerator.$wgenConsTheorem w1 w2) -}
545898d57e053ac5020f9065dfd375f3
  genConsTheorems ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVStransition]
    -> GHC.Base.String
    -> [GHC.Base.String]
  {- Arity: 3, Strictness: <L,1*U(U,A,U,A,1*U,A,A)><S,1*U><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (ts :: [LexerTypes.PVStransition])
                   (nom :: GHC.Base.String) ->
                 case ts of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds1 ds2
                   -> case uni of wild1 { LexerTypes.PVSPackage ds4 ds5 ds3 ds6 ds7 ds8 ds9 ->
                      case GHC.List.lookup
                             @ GHC.Base.String
                             @ [LexerTypes.PVSstate]
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ds4
                             ds7 of wild2 {
                        GHC.Base.Nothing
                        -> case PVSGenerator.genConsTheorems1 ds4
                           ret_ty [GHC.Base.String]
                           of {}
                        GHC.Base.Just x
                        -> case PVSGenerator.stateless' x of wild3 {
                             GHC.Types.False
                             -> GHC.Base.map
                                  @ [LexerTypes.PVStransition]
                                  @ [GHC.Types.Char]
                                  (\ (w :: [LexerTypes.PVStransition]) ->
                                   PVSGenerator.$wgenConsTheorem nom w)
                                  (PVSGenerator.groupByArgs wild1 wild)
                             GHC.Types.True -> GHC.Types.[] @ GHC.Base.String } } } }) -}
ef6a3f778ce58ce5fd410e93416b2f8f
  genConsTheorems1 :: GHC.Base.String -> [LexerTypes.PVSstate]
  {- Arity: 1, Strictness: <B,1*U>x -}
87438307dab8375c794ba71eb42e5abe
  genDocumentation ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVStransition] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U,A,A,A,1*U,A,A)><S,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (ts :: [LexerTypes.PVStransition]) ->
                 let {
                   scheduleDisplay :: [GHC.Types.Char]
                   = case ts of wild {
                       [] -> PVSGenerator.genDocumentation31
                       : ds1 ds2
                       -> case GHC.Base.map
                                 @ (GHC.Integer.Type.Integer,
                                    [(LexerTypes.MethodName,
                                      [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
                                    [LexerTypes.ValueMethod], [LexerTypes.TransitionTable])
                                 @ [GHC.Types.Char]
                                 (PVSGenerator.displaySchedule uni)
                                 wild of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : x xs1
                            -> Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.genDocumentation29
                                    xs1) } }
                 } in
                 case ts of wild {
                   []
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        PVSGenerator.genDocumentation_header'
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.genDocumentation29
                           (GHC.Types.:
                              @ [GHC.Types.Char]
                              scheduleDisplay
                              PVSGenerator.genDocumentation22))
                   : ds1 ds2
                   -> case uni of wild1 { LexerTypes.PVSPackage ds4 ds5 ds3 ds6 ds7 ds8 ds9 ->
                      case GHC.List.lookup
                             @ GHC.Base.String
                             @ [LexerTypes.PVSstate]
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ds4
                             ds7 of wild2 {
                        GHC.Base.Nothing
                        -> case PVSGenerator.genConsTheorems1 ds4
                           ret_ty [GHC.Types.Char]
                           of {}
                        GHC.Base.Just x
                        -> case PVSGenerator.stateless' x of wild3 {
                             GHC.Types.False
                             -> Data.OldList.intercalate_$spoly_go
                                  @ GHC.Types.Char
                                  PVSGenerator.genDocumentation20
                                  (Data.OldList.prependToAll
                                     @ [GHC.Types.Char]
                                     PVSGenerator.genDocumentation29
                                     (GHC.Types.:
                                        @ [GHC.Types.Char]
                                        scheduleDisplay
                                        PVSGenerator.genDocumentation1))
                             GHC.Types.True
                             -> Data.OldList.intercalate_$spoly_go
                                  @ GHC.Types.Char
                                  PVSGenerator.genDocumentation_header'
                                  (Data.OldList.prependToAll
                                     @ [GHC.Types.Char]
                                     PVSGenerator.genDocumentation29
                                     (GHC.Types.:
                                        @ [GHC.Types.Char]
                                        scheduleDisplay
                                        PVSGenerator.genDocumentation22)) } } } }) -}
fb3a8ceefab3d39f0c1926a0ed579939
  genDocumentation1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation18
                   PVSGenerator.genDocumentation2) -}
f454fceb812c177a4adb6dcd01c50a4b
  genDocumentation10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation11) -}
587d9b443171d333c8fb2ece8078196a
  genDocumentation11 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\tmethod arguments -> supply the arguments given in the above list of schedules, in the order they appear."#) -}
d61961accb15206405085065341a9cfb
  genDocumentation12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation13) -}
695c03155cbfd032ebb7643b11d646f6
  genDocumentation13 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\tpost -> The post-state of the transition predicate"#) -}
2ef93eb857cf10f7683ded152e370c54
  genDocumentation14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation15) -}
5fcca22821eda21e17f4cc1254494068
  genDocumentation15 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\tpre -> The pre-state of the transition predicate"#) -}
ee46ae9b9d5b2591e34ff1d8ac44a7b8
  genDocumentation16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation17) -}
5aef459c479879a188a8994f51bf50d1
  genDocumentation17 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\tindex -> The index number corresponding to the schedule you wish to invoke"#) -}
3af779c623f59367b121a7a284f3e0dc
  genDocumentation18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation19) -}
14ab97eb8a0dc7535a05d561666cfa67
  genDocumentation19 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("The following arguments must be supplied to invoke the transition predicate."#) -}
a8c6de1dc2b4d9df24814675fb3c24b7
  genDocumentation2 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation16
                   PVSGenerator.genDocumentation3) -}
0c565483aab6e6b1327b8df60847325b
  genDocumentation20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation21) -}
9f603628894dc9dca5909d0930bd6e89
  genDocumentation21 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \%  The following transitions have been scheduled."#) -}
dc26fdcf4dfb8d9f59dbc8e3387460a9
  genDocumentation22 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation_f1'
                   PVSGenerator.genDocumentation23) -}
7458f25bacbbbc6db3f47fa9520251b7
  genDocumentation23 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation_f2'
                   PVSGenerator.genDocumentation24) -}
f15232be7457b5fe7d3e2d3ccf950034
  genDocumentation24 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation_f3'
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
c682cd66a49b45de0efcfc1f1b267893
  genDocumentation25 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("As such, no transitions have actually been generated.  "#) -}
7fc08c1c91c9c940fa444e563c250a31
  genDocumentation26 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("This might be because it is full of Wires and not state holding elements like Registers etc."#) -}
b4288f3bdeffc7e77fc30b9e2983a8cb
  genDocumentation27 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Apparently, however, although the module under examination is exists, it is not stateful!"#) -}
da27cfe95322f34f74da50c3056ee5f7
  genDocumentation28 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \%  The following schedules have been generated."#) -}
d9628fa2b4e3afaea309431982a65081
  genDocumentation29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation30) -}
a240ac8f2914187eae9317baabbcedc5
  genDocumentation3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation14
                   PVSGenerator.genDocumentation4) -}
cccc45f3fb43674b8652497dd2042f08
  genDocumentation30 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \%  "#) -}
e24af8400a8261edc3ac53d238e4b163
  genDocumentation31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation32) -}
df7e710cfd2cbe7c67eb2614f83358ab
  genDocumentation32 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \% None!"#) -}
8d2f4b9f9a4478fcbeed6a66e52faa09
  genDocumentation4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation12
                   PVSGenerator.genDocumentation5) -}
159e289c0535c625ffeeb3516dbe8845
  genDocumentation5 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation10
                   PVSGenerator.genDocumentation6) -}
ec892d5cbe9b8efd045f9c3ebd8783ac
  genDocumentation6 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   (GHC.Types.[] @ GHC.Types.Char)
                   PVSGenerator.genDocumentation7) -}
d6d9d66d356b66b21f822e26f0fcbe29
  genDocumentation7 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genDocumentation8
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
eccc8aeeb35a110e157c2d18041ae0f4
  genDocumentation8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation9) -}
0cbf19799a8b7403a88c9ea984ddf384
  genDocumentation9 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("For an example of how this is intended to work, take a look at the auto-generated consistency theorems below."#) -}
4b042331564140f95a997da0c35c3580
  genDocumentation_f1' :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation27) -}
e702df69ccf2e0f9209f4d897f05f2d5
  genDocumentation_f2' :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation26) -}
61a8f8eb562a31aa416a2e8be30bea3c
  genDocumentation_f3' :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation25) -}
14aa0470aba3043321c4b6e5f5000f94
  genDocumentation_header' :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genDocumentation28) -}
dbcf5a8002cef81a5b3db85840c1a3ec
  genFuncProof :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (nom :: GHC.Base.String) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   (GHC.CString.unpackAppendCString#
                      PVSGenerator.genConsProof21
                      (GHC.Base.++ @ GHC.Types.Char nom PVSGenerator.genFuncProof5))
                   PVSGenerator.genFuncProof1) -}
b5ef62076ba325321a5baa7f227db1f3
  genFuncProof1 :: [[GHC.Types.Char]]
  {- Unfolding: (Data.OldList.prependToAll
                   @ [GHC.Types.Char]
                   PVSGenerator.genConsProof20
                   PVSGenerator.genFuncProof2) -}
cd77f18065058fc8767593e274f8e116
  genFuncProof2 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.genFuncProof3
                   PVSGenerator.genConsProof4) -}
2365796c35d37d563b53b4b0c12a4720
  genFuncProof3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genFuncProof4) -}
20eff288ea80c3ec97b4a07406e14944
  genFuncProof4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(then (grind))"#) -}
a5367646ec4890c4b43444667bc73f93
  genFuncProof5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genFuncProof6) -}
2068ae387e8fd043fcf4506ed28209e6
  genFuncProof6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_REQ : PROOF"#) -}
8c68af4cd3f696abc9a9eacc22ea1688
  genIf ::
    [([GHC.Integer.Type.Integer], GHC.Base.String)]
    -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
2339b01ae2aa88d6cd80dd56f1a71d7f
  genIf' ::
    [(GHC.Integer.Type.Integer, GHC.Base.String)] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
cc14828103a7a634a3f31dbd006737f2
  genIfTruple ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> LexerTypes.ValueMethod
    -> [LexerTypes.PVStransition]
    -> [(GHC.Integer.Type.Integer, GHC.Base.String,
         [(LexerTypes.MethodArg, LexerTypes.PVSType)])]
  {- Arity: 4,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,A><L,U(U,U,U,A,U,U,A)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: LexerTypes.ValueMethod)
                   (w3 :: [LexerTypes.PVStransition]) ->
                 PVSGenerator.$wgenIfTruple w w2 w3) -}
32a992bfbfa3cdedd6ec8369876e8864
  genInit :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   PVSGenerator.genInit2
                   (GHC.Base.build
                      @ GHC.Types.Char
                      (\ @ b
                         (c :: GHC.Types.Char -> b -> b)[OneShot]
                         (n :: b)[OneShot] ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b
                         c
                         (GHC.CString.unpackFoldrCString# @ b PVSGenerator.genInit1 c n)
                         x))) -}
bc7fb307f71e951cd6fd4a8466489020
  genInit1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(s(t)))"#) -}
87149cdf1d4cb5d8215422b2518fed81
  genInit2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(init(t) IMPLIES mk"#) -}
1075be43519694177818108c780bd06a
  genLets ::
    LexerTypes.PVSPackage
    -> [LexerTypes.TransitionTable]
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,U><L,U>,
     Unfolding: (\ (ds :: LexerTypes.PVSPackage)
                   (ds1 :: [LexerTypes.TransitionTable])
                   (ds2 :: GHC.Base.String)
                   (ds3 :: GHC.Base.String) ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1
                   -> GHC.CString.unpackAppendCString#
                        PVSGenerator.genLets5
                        (letrec {
                           go4 :: [LexerTypes.TransitionTable] -> [GHC.Base.String]
                             {- Arity: 1, Strictness: <S,1*U> -}
                           = \ (ds4 :: [LexerTypes.TransitionTable]) ->
                             case ds4 of wild1 {
                               [] -> GHC.Types.[] @ GHC.Base.String
                               : y ys
                               -> GHC.Base.++
                                    @ [GHC.Types.Char]
                                    (PVSGenerator.showLet ds y ds2 ds3)
                                    (go4 ys) }
                         } in
                         case go4 wild of wild1 {
                           [] -> PVSGenerator.genLets3
                           : x xs1
                           -> GHC.Base.++
                                @ GHC.Types.Char
                                (Data.OldList.intercalate_$spoly_go
                                   @ GHC.Types.Char
                                   x
                                   (Data.OldList.prependToAll
                                      @ [GHC.Types.Char]
                                      PVSGenerator.genLets1
                                      xs1))
                                PVSGenerator.genLets3 }) }) -}
b10f2408fa556ad77d5a1547274f9f08
  genLets1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# PVSGenerator.genLets2) -}
357fa80cf3f167e8c6c6d88c0d300ace
  genLets2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t  , "#) -}
327bbb8dede03f665b768ab7cbd20180
  genLets3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# PVSGenerator.genLets4) -}
34ee1e87a984dfade2842887ac0820fe
  genLets4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\tIN "#) -}
78309b0202df6647a94b6f4f8138f159
  genLets5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LET "#) -}
3df0327ab6f094d8be0269e94b80679c
  genMethodCase ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> LexerTypes.ValueMethod
    -> LexerTypes.PVStransition
    -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U(A,U)><S,1*U(1*U,U,1*U,A,U,U,A)><S,1*U(U,A,A,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: LexerTypes.ValueMethod)
                   (w3 :: LexerTypes.PVStransition) ->
                 case w2 of ww { (,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w3 of ww8 { (,,,) ww9 ww10 ww11 ww12 ->
                 PVSGenerator.$wgenMethodCase
                   w
                   w1
                   ww1
                   ww2
                   ww3
                   ww5
                   ww6
                   ww9
                   ww12 } }) -}
8bf6cb903c29bf6dcf14de93ecf13716
  genNewTransition ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> GHC.Base.String
    -> GHC.Types.Bool
    -> [LexerTypes.PVStransition]
    -> GHC.Base.String
  {- Arity: 5,
     Strictness: <S(LLLLSLL),1*U(U,A,U,U,U,U,U)><L,U(A,U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: GHC.Base.String)
                   (w3 :: GHC.Types.Bool)
                   (w4 :: [LexerTypes.PVStransition]) ->
                 case w of ww { LexerTypes.PVSPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PVSGenerator.$wgenNewTransition
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   w1
                   w2
                   w3
                   w4 }) -}
2ce779c91f6d33c0f28998e655623708
  genTabLine :: LexerTypes.TSPTable -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SLLLLL),1*U(1*U,A,A,A,1*U,A)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.TSPTable) ->
                 case w of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 PVSGenerator.$wgenTabLine ww1 ww5 }) -}
75363ffacb28e02d225b6e26c719d1c5
  genTabLine1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabLine2) -}
d647969606c448ddc2d2ebe7696d46fe
  genTabLine2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (","#) -}
17d234c04e76b0f3d76f6cd9516ac28e
  genTabLine3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabLine4) -}
573597d8ea9663e8fe9c7be2a449b852
  genTabLine4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (")(t)"#) -}
fa72ba1ba4c5da0f46f12fcc704d6234
  genTabLine5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("("#) -}
c8e29437dcb1cfef190df3a32bc5bca5
  genTabSpec ::
    LexerTypes.PVSPackage -> LexerTypes.TSPTable -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(U,A,U,A,U,U,U)><S(LSLLLL),1*U(1*U,1*U(U,1*U(1*U(U))),U,1*U,1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.TSPTable) ->
                 case w1 of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case ww2 of ww7 { (,) ww8 ww9 ->
                 PVSGenerator.$wgenTabSpec w ww1 ww8 ww9 ww3 ww4 ww5 ww6 } }) -}
ae2756ddc8c3f5c11fc4e9b69d36a0a1
  genTabSpecCall :: LexerTypes.TSPTable -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S(SSLLLL),1*U(1*U,1*U(A,1*U(1*U(1*U))),A,A,1*U,A)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.TSPTable) ->
                 case w of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case ww2 of ww7 { (,) ww8 ww9 ->
                 PVSGenerator.$wgenTabSpecCall ww1 ww9 ww5 } }) -}
3043e908c6a8cfe98c60429f65f42a39
  genTabSpecCall1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabSpecCall2) -}
59f65113193eef9691945ccbd46f318c
  genTabSpecCall2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(next(t))"#) -}
0d702200650ddc65dbe86936b5260d2a
  genTabSpecCall3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabSpecCall4) -}
9394d4ae1b1f727ed91db6dd0a39123f
  genTabSpecCall4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("(t)"#) -}
52d313f316d52ea0d0fdc9e51ceaae27
  genTabVar ::
    LexerTypes.PVSPackage -> LexerTypes.TVarDec -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.TVarDec) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wgenTabVar ww1 ww2 }) -}
ce51445d53be608680118c1458646661
  genTabVar1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabVar2) -}
e48279cf1a98a6977b0c04e0d9fd56fa
  genTabVar2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" ]"#) -}
ca806b31d66b10d273371cf86073595a
  genTabVar3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : VAR [ tick -> "#) -}
c2bd7c8605bfea1b3df3bd580a7339c2
  genTabVar4 :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [GHC.Types.Char]) ->
                 case GHC.Base.eqString x PVSGenerator.genTabVar5 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ffefb36f04eb5f8a47d25fb2cab17c02
  genTabVar5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabVar6) -}
be7ca1732b189150b43438e2b93c83bd
  genTabVar6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("t"#) -}
a6370b1d0398865b6a5b3839dfdce8f0
  genTabVars ::
    LexerTypes.PVSPackage -> [LexerTypes.TVarDec] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: [LexerTypes.TVarDec]) ->
                 PVSGenerator.$wgenTabVars w1) -}
d59f7e7392e8b57529285f4539444d36
  genTabVars1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTabVars2) -}
20de2f396d07558b4e9ccb6112f8edba
  genTabVars2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t"#) -}
93dc0e5f8f1d37cf86b089a6f9310f5b
  genTabVars3 :: LexerTypes.TVarDec -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>,
     Unfolding: (\ (w :: LexerTypes.TVarDec) ->
                 case w of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wgenTabVar ww1 ww2 }) -}
d4611735491df6b658ebc060eb7926f9
  genTableLine ::
    LexerTypes.PVSPackage -> LexerTypes.TSPLine -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.TSPLine) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wgenTableLine w ww1 ww2 }) -}
650c3129ecd904e6f2ca20ea55fc8786
  genTableLine1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genTableLine2) -}
44e1c521b58515decb6ba33ea8148b45
  genTableLine2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" ||"#) -}
4ade91bc046a6380bef997b0a9425446
  genTableLine3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" | "#) -}
af48cd0100cb5720dcf238c7bc3eb6fd
  genTableLine4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("        | "#) -}
68263f5c175460e677eb779a1e8d24d1
  genValueMethodHeader ::
    LexerTypes.PVSPackage
    -> GHC.Types.Bool
    -> LexerTypes.ValueMethod
    -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
    -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,A><L,1*U><S(SLLLLLL),1*U(1*U,U,U,A,1*U,A,A)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Types.Bool)
                   (w2 :: LexerTypes.ValueMethod)
                   (w3 :: [(LexerTypes.MethodArg, LexerTypes.PVSType)]) ->
                 case w2 of ww { (,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PVSGenerator.$wgenValueMethodHeader w1 ww1 ww2 ww3 ww5 w3 }) -}
07a7ac272802f7a94281ad5605b55966
  genValueMethodHeader1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genValueMethodHeader2) -}
9bee75f5934f4fa7096d6d029cafb3b1
  genValueMethodHeader10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" ("#) -}
7f0bea4f91346502074f34d7c2671dbf
  genValueMethodHeader2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("index : nat"#) -}
5f60f820ed0e7de291d5905cd0dad6d0
  genValueMethodHeader3 :: LexerTypes.PVSArgument -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>,
     Unfolding: (\ (w :: LexerTypes.PVSArgument) ->
                 case w of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSArgument ww1 ww2 }) -}
c5c63d954aa90f4b1ed31fedab01d687
  genValueMethodHeader4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (": "#) -}
a1decc0bdc7f446c109c1688c0e5e17c
  genValueMethodHeader5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("mod : "#) -}
4e83bc57e9b369987fb54cd23c9554a7
  genValueMethodHeader6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pre : "#) -}
f59831604921fdbaf4fda04af39e9301
  genValueMethodHeader7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.genValueMethodHeader8) -}
21f7b400981fad376c4b1ab4a88844a2
  genValueMethodHeader8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" = "#) -}
81f7ca88a00987273f023d303805be19
  genValueMethodHeader9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (") : "#) -}
938a3adc002e31a57fd80d98f67cdea2
  generateTabspecs ::
    LexerTypes.PVSPackage
    -> GHC.Base.Maybe LexerTypes.TSPpackage -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (ds :: GHC.Base.Maybe LexerTypes.TSPpackage) ->
                 case ds of wild {
                   GHC.Base.Nothing -> GHC.Types.[] @ GHC.Types.Char
                   GHC.Base.Just x
                   -> case x of wild1 { LexerTypes.TSPpackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                      Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        (PVSGenerator.$wgenTabVars ds4)
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.generateTabspecs1
                           (GHC.Types.:
                              @ [GHC.Types.Char]
                              (case GHC.Base.map
                                      @ (LexerTypes.TName, LexerTypes.TSPOutVar,
                                         LexerTypes.Expression, [LexerTypes.Replacement],
                                         [GHC.Base.String], [LexerTypes.TSPLine])
                                      @ [GHC.Types.Char]
                                      (PVSGenerator.genTabSpec uni)
                                      ds5 of wild2 {
                                 [] -> GHC.Types.[] @ GHC.Types.Char
                                 : x1 xs1
                                 -> Data.OldList.intercalate_$spoly_go
                                      @ GHC.Types.Char
                                      x1
                                      (Data.OldList.prependToAll
                                         @ [GHC.Types.Char]
                                         PVSGenerator.generateTabspecs1
                                         xs1) })
                              (GHC.Types.[] @ [GHC.Types.Char]))) } }) -}
eda4d76e0f10cfe859b4c18d58dd3595
  generateTabspecs1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.generateTabspecs2) -}
2b7add7f03f4772066926c8d4abe38c7
  generateTabspecs2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\n\
                 \\t"#) -}
4f25a5eacc7d105a5990783b240a4f29
  getExclusionNames ::
    [LexerTypes.TransitionTable] -> [LexerTypes.ID_Path]
  {- Arity: 1, Strictness: <S,1*U> -}
e9fd1aee9edff74f727ab1b4dad249a0
  getExpressionBitSize ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.Expression
    -> GHC.Integer.Type.Integer
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,A,U)><L,U><L,U><S,1*U> -}
da10d5d254b5bc02adaa2cb69f5811ee
  getFieldBitSize ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVS_Field -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,1*U(A,A,U,A,A,A,A)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (uni :: LexerTypes.PVSPackage)
                   (ds :: (LexerTypes.Name, LexerTypes.PVSType)) ->
                 case ds of wild { (,) ds1 typ ->
                 PVSGenerator.getTypeBitSize uni typ }) -}
29a7a57947ceaebabfcf7df3bc35156b
  getFieldType ::
    GHC.Base.String
    -> LexerTypes.PVSTypeDef -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Base.String) (ds :: LexerTypes.PVSTypeDef) ->
                 case ds of wild {
                   DEFAULT -> PVSGenerator.getFieldType1
                   LexerTypes.PVS_Struct ds1 fs
                   -> GHC.List.lookup
                        @ GHC.Base.String
                        @ LexerTypes.PVSType
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        n
                        fs }) -}
33b4d78719a49214849dedf44e012ee4
  getFieldType1 :: GHC.Base.Maybe LexerTypes.PVSType
  {- Strictness: x -}
b42a4cc61c481e32d3b208fba3c3c018
  getFifoSize ::
    LexerTypes.FifoType -> GHC.Base.Maybe LexerTypes.Literal
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.FifoType) ->
                 case ds of wild {
                   DEFAULT -> GHC.Base.Nothing @ LexerTypes.Literal
                   LexerTypes.SizedFIFO x -> GHC.Base.Just @ LexerTypes.Literal x
                   LexerTypes.SizedFIFOF x -> GHC.Base.Just @ LexerTypes.Literal x
                   LexerTypes.SizedBypassFIFOF x
                   -> GHC.Base.Just @ LexerTypes.Literal x }) -}
544a127fa32086e68f8d6a4da964cc65
  getFunctionReturnSize ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSFunction]
    -> GHC.Base.String
    -> GHC.Integer.Type.Integer
  {- Arity: 3, Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U><S,U> -}
0b869cbb1ec669739becc6f03aa56bff
  getGetMeth ::
    LexerTypes.PVSPackage
    -> [LexerTypes.ValueMethod]
    -> LexerTypes.ID_Path
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><S,U> -}
8f677795f1ebd137efde0b3e2356e152
  getIDRoot :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.ID_Path) ->
                 case PVSGenerator.$wgetIDRoot w of ww { Unit# ww1 ->
                 LexerTypes.ID ww1 }) -}
ac9f4ad90ce5f3e878ddc6870cb1a36b
  getInputTrans ::
    [LexerTypes.PVStransition] -> LexerTypes.PVStransition
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [LexerTypes.PVStransition]) ->
                 case PVSGenerator.$wgetInputTrans
                        w of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
779613c0b1b5842d8cff37dbb0fb65dd
  getLVType ::
    LexerTypes.LocalVar
    -> (LexerTypes.ID_Path, GHC.Base.Maybe LexerTypes.PVSType)
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(U,1*U,A)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.LocalVar) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww2 of wild {
                   Data.Either.Left x
                   -> (ww1,
                       case x of wild1 {
                         GHC.Base.Nothing -> GHC.Base.Nothing @ LexerTypes.PVSType
                         GHC.Base.Just a1
                         -> GHC.Base.Just @ LexerTypes.PVSType (BSV2PVS.b2pType a1) })
                   Data.Either.Right x -> (ww1, x) } }) -}
afd1ef396b8725da2e58284dc21019e4
  getLiteralBitSize :: LexerTypes.Lit -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.Lit) ->
                 case ds of wild {
                   LexerTypes.LitString str
                   -> case GHC.List.$wlenAcc
                             @ GHC.Types.Char
                             str
                             0# of ww2 { DEFAULT ->
                      GHC.Integer.Type.timesInteger
                        PVSGenerator.getLiteralBitSize6
                        (GHC.Integer.Type.smallInteger ww2) }
                   LexerTypes.LitEnum enm -> PVSGenerator.getLiteralBitSize5
                   LexerTypes.LitInt int
                   -> case GHC.Integer.Type.doubleFromInteger
                             int of wild2 { DEFAULT ->
                      case PVSGenerator.getLiteralBitSize4 of v { GHC.Types.D# v1 ->
                      case GHC.Prim.logDouble# wild2 of wild4 { DEFAULT ->
                      case GHC.Prim./## wild4 v1 of wild6 { DEFAULT ->
                      case GHC.Integer.Type.decodeDoubleInteger
                             (GHC.Prim.negateDouble# wild6) of ds1 { (#,#) ipv ipv1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# ipv1 0#) of wild1 {
                        GHC.Types.False
                        -> GHC.Integer.Type.negateInteger
                             (GHC.Integer.Type.shiftLInteger ipv ipv1)
                        GHC.Types.True
                        -> let {
                             s :: GHC.Prim.Int# = GHC.Prim.negateInt# ipv1
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># s 52#) of wild7 {
                             GHC.Types.False
                             -> case GHC.Integer.Type.integerToInt ipv of n { DEFAULT ->
                                GHC.Integer.Type.negateInteger
                                  (GHC.Integer.Type.smallInteger
                                     (GHC.Prim.uncheckedIShiftRA# n s)) }
                             GHC.Types.True
                             -> case GHC.Integer.Type.ltInteger#
                                       ipv
                                       PVSGenerator.getLiteralBitSize3 of wild3 { DEFAULT ->
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3 of wild8 {
                                  GHC.Types.False -> PVSGenerator.getLiteralBitSize3
                                  GHC.Types.True -> PVSGenerator.getNumericSuffix2 } } } } } } } } }
                   LexerTypes.LitBool bl -> PVSGenerator.getNumericSuffix2
                   LexerTypes.LitReal rl -> PVSGenerator.getLiteralBitSize2
                   LexerTypes.LitChar ds1 -> PVSGenerator.getLiteralBitSize6
                   LexerTypes.LitSizedInt n ds1 -> n
                   LexerTypes.LitStructConstructor -> PVSGenerator.getLiteralBitSize1
                   LexerTypes.LitVoid -> PVSGenerator.getLiteralBitSize3 }) -}
a388a0bb86216e30fcec6e160b08eb46
  getLiteralBitSize1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
e3131c974bd4ae02ea1503511aec8147
  getLiteralBitSize2 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
5b12b6e4734ccb7319ef27eac6dd8c7f
  getLiteralBitSize3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
d5e04cbff5c2798ac104b804691cface
  getLiteralBitSize4 :: GHC.Types.Double
  {- Unfolding: (case GHC.Prim.logDouble# 2.0## of v { DEFAULT ->
                 GHC.Types.D# v }) -}
cfbed7a20768f9756c6f37f73cd1be12
  getLiteralBitSize5 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
52050312bcbaf061de4ddc81b107f0bf
  getLiteralBitSize6 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (8) -}
6c801aa66ac3239d797adc4759103b88
  getMArgs ::
    [LexerTypes.PVStransition]
    -> [(LexerTypes.MethodArg, LexerTypes.PVSType)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [LexerTypes.PVStransition]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ (LexerTypes.MethodArg, LexerTypes.PVSType)
                   : ds1 xs
                   -> case ds1 of wild1 { (,,,) ds2 ds3 ds4 ds5 ->
                      case ds3 of wild2 {
                        [] -> GHC.Types.[] @ (LexerTypes.MethodArg, LexerTypes.PVSType)
                        : ipv ipv1 -> PVSGenerator.genConsProof_go wild2 } } }) -}
a2ed531593ee9c85c0956d607c7a409f
  getNumericSuffix ::
    GHC.Base.String -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [GHC.Types.Char]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ GHC.Base.String
                   : ipv ipv1
                   -> case Text.Read.readEither8
                             @ GHC.Integer.Type.Integer
                             (Text.ParserCombinators.ReadP.run
                                @ GHC.Integer.Type.Integer
                                PVSGenerator.getNumericSuffix4
                                (GHC.List.reverse1
                                   @ GHC.Types.Char
                                   (GHC.List.takeWhile
                                      @ GHC.Types.Char
                                      PVSGenerator.displayArgs'3
                                      (GHC.List.reverse1
                                         @ GHC.Types.Char
                                         wild
                                         (GHC.Types.[] @ GHC.Types.Char)))
                                   (GHC.Types.[] @ GHC.Types.Char))) of wild1 {
                        []
                        -> case PVSGenerator.getNumericSuffix3
                           ret_ty (GHC.Base.Maybe GHC.Base.String)
                           of {}
                        : x ds1
                        -> case ds1 of wild2 {
                             []
                             -> case GHC.Show.$w$cshowsPrec4
                                       0#
                                       (GHC.Integer.Type.plusInteger
                                          x
                                          PVSGenerator.getNumericSuffix2)
                                       (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                let {
                                  suffix :: GHC.Base.String = GHC.Types.: @ GHC.Types.Char ww3 ww4
                                } in
                                let {
                                  lvl568 :: GHC.Base.Maybe GHC.Base.String <join 0>
                                  = GHC.Base.Just @ GHC.Base.String suffix
                                } in
                                letrec {
                                  go4 :: [GHC.Types.Char] -> GHC.Base.Maybe GHC.Base.String
                                    <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                  = \ (ds2 :: [GHC.Types.Char]) ->
                                    case ds2 of wild3 {
                                      [] -> lvl568
                                      : y ys
                                      -> case y of ww { GHC.Types.C# ww1 ->
                                         case GHC.Unicode.$wgeneralCategory ww1 of wild4 {
                                           DEFAULT -> GHC.Base.Nothing @ GHC.Base.String
                                           GHC.Unicode.DecimalNumber -> go4 ys
                                           GHC.Unicode.LetterNumber -> go4 ys
                                           GHC.Unicode.OtherNumber -> go4 ys } } }
                                } in
                                go4 suffix }
                             : ipv2 ipv3
                             -> case PVSGenerator.getNumericSuffix1
                                ret_ty (GHC.Base.Maybe GHC.Base.String)
                                of {} } } }) -}
d3dc6beca8ef8cba4f984e48259212ce
  getNumericSuffix1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
79d48e15d38e1133b183404663fedd1f
  getNumericSuffix2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
af1bf878a0cd253dd773b7fae785edb4
  getNumericSuffix3 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
8549a7406cbaa455cfed3ca88403851f
  getNumericSuffix4 ::
    Text.ParserCombinators.ReadP.P GHC.Integer.Type.Integer
  {- Unfolding: (GHC.Read.$fReadInteger_$sreadNumber
                   GHC.Read.$fReadInteger2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Integer.Type.Integer
                   (Text.Read.readEither7 @ GHC.Integer.Type.Integer)) -}
a3ba9a856db19f0bd1e22ff2caa9317f
  getPair ::
    LexerTypes.PVSPackage
    -> [LexerTypes.TSPTable]
    -> LexerTypes.PVStransition
    -> ((LexerTypes.ID_Path, GHC.Base.String) -> GHC.Base.String)
    -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,1*U(A,A,1*U,A)><L,C(U)>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (tsps :: [LexerTypes.TSPTable])
                   (trans :: LexerTypes.PVStransition)
                   (transform :: (LexerTypes.ID_Path, GHC.Base.String)
                                 -> GHC.Base.String) ->
                 let {
                   outs :: [LexerTypes.ID_Path]
                   = GHC.Base.map
                       @ (LexerTypes.TName, LexerTypes.TSPOutVar, LexerTypes.Expression,
                          [LexerTypes.Replacement], [GHC.Base.String], [LexerTypes.TSPLine])
                       @ LexerTypes.ID_Path
                       PVSGenerator.getPair3
                       tsps
                 } in
                 letrec {
                   go4 :: [LexerTypes.ID_Path]
                          -> [[GHC.Types.Char]] -> [[GHC.Types.Char]]
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [LexerTypes.ID_Path]) (_ys :: [[GHC.Types.Char]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [GHC.Types.Char]
                       : ipv ipv1
                       -> case _ys of wild1 {
                            [] -> GHC.Types.[] @ [GHC.Types.Char]
                            : ipv2 ipv3
                            -> GHC.Types.:
                                 @ [GHC.Types.Char]
                                 (transform (ipv, ipv2))
                                 (go4 ipv1 ipv3) } }
                 } in
                 case go4
                        outs
                        (GHC.Base.map
                           @ LexerTypes.ID_Path
                           @ [GHC.Types.Char]
                           (PVSGenerator.getGetMeth
                              uni
                              (case trans of wild { (,,,) ds ds1 x ds2 -> x }))
                           outs) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.getPair1
                           xs1) }) -}
30e1faa7259960cb9f19de7bf5728232
  getPair1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# PVSGenerator.getPair2) -}
0568ef3c9eddf9768ff580a12a08e40e
  getPair2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t     AND "#) -}
d7b8fbf0ded545ea65159086dcf99fc9
  getPair3 ::
    (LexerTypes.TName, LexerTypes.TSPOutVar, LexerTypes.Expression,
     [LexerTypes.Replacement], [GHC.Base.String], [LexerTypes.TSPLine])
    -> LexerTypes.ID_Path
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SL)LLLL),1*U(A,1*U(1*U,A),A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (LexerTypes.TName, LexerTypes.TSPOutVar,
                          LexerTypes.Expression, [LexerTypes.Replacement], [GHC.Base.String],
                          [LexerTypes.TSPLine])) ->
                 case x of wild { (,,,,,) ds x1 ds1 ds2 ds3 ds4 ->
                 case x1 of wild1 { (,) x2 ds5 -> x2 } }) -}
f5b1d6df307fc89b61e58dce9b6e4905
  getReadsByOverTree ::
    (LexerTypes.ID_Path -> GHC.Types.Bool)
    -> LexerTypes.SpecificTree -> [LexerTypes.ID_Path]
  {- Arity: 2, Strictness: <L,C(U)><S,1*U> -}
53079ac3760a9650228142500c573040
  getState ::
    [LexerTypes.PVSstateDec]
    -> GHC.Base.String -> LexerTypes.PVSstateDec
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.PVSstateDec]) (w1 :: GHC.Base.String) ->
                 case PVSGenerator.$wgetState w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
be5cbb58de185df161894104b05dd60a
  getStateDec ::
    [LexerTypes.PVSstateDec]
    -> GHC.Base.String -> LexerTypes.PVSstateDec
  {- Arity: 2, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [LexerTypes.PVSstateDec]) (y :: GHC.Base.String) ->
                 case GHC.List.lookup
                        @ GHC.Base.String
                        @ [LexerTypes.PVSstate]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        y
                        x of wild {
                   GHC.Base.Nothing -> PVSGenerator.getStateDec1
                   GHC.Base.Just x1 -> (y, x1) }) -}
0dbe27054718d1f3f3cd1577bfca4be4
  getStateDec1 :: (GHC.Base.String, [LexerTypes.PVSstate])
  {- Strictness: x -}
4a3621fc44d12785ea508cfb42509829
  getStructBitSize ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> [LexerTypes.PVSTypeDef]
    -> LexerTypes.PVSType
    -> LexerTypes.ID_Path
    -> GHC.Integer.Type.Integer
  {- Arity: 5,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><S,1*U><S,1*U><L,1*U> -}
d8bb639b6a90c7c1daabc5a03176823d
  getTablesBySubmod ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.TransitionTable]
  {- Arity: 3,
     Strictness: <S(LLLLSLL),1*U(U,A,A,A,U,A,A)><S,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (uni :: LexerTypes.PVSPackage)
                   (name :: GHC.Base.String)
                   (tables :: [LexerTypes.TransitionTable]) ->
                 PVSGenerator.seekTable
                   tables
                   (PVSGenerator.findPathToName
                      (PVSGenerator.constructInvokationTree uni)
                      name)) -}
aa9bd52e354f6910be6273504fb8b0aa
  getTrans ::
    [LexerTypes.TransitionTable]
    -> LexerTypes.ID_Path -> LexerTypes.TransitionTable
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
80f7568c4ffa818c9fa88b2bf771980e
  getTransitionGlobalTables ::
    GHC.Base.String
    -> [LexerTypes.PVStransition] -> [LexerTypes.TransitionTable]
  {- Arity: 2, Strictness: <S,U><S,1*U> -}
50ac329868f35656ba903083b225daa1
  getTree :: LexerTypes.TransitionTable -> LexerTypes.SpecificTree
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.TransitionTable) ->
                 case ds of wild {
                   DEFAULT -> PVSGenerator.getTree1
                   LexerTypes.TransReg x y -> y
                   LexerTypes.TransDWire x y z -> y }) -}
ae2136377a89e681a293fbdfa0bd6651
  getTree1 :: LexerTypes.SpecificTree
  {- Strictness: x -}
0dea10e95c411aef5eaaf858864971eb
  getTypeBitSize ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSType -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,1*U(A,A,U,A,A,A,A)><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (ds :: LexerTypes.PVSType) ->
                 case ds of wild {
                   LexerTypes.PVS_Bool -> PVSGenerator.getNumericSuffix2
                   LexerTypes.PVS_Bit n -> n
                   LexerTypes.PVS_Int n -> n
                   LexerTypes.PVS_UInt n -> n
                   LexerTypes.PVS_Real -> PVSGenerator.getTypeBitSize3
                   LexerTypes.PVS_Custom nom
                   -> case uni of wild1 { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                      case PVSGenerator.checkForSynonyms ds3 nom of wild2 {
                        GHC.Base.Nothing -> PVSGenerator.getTypeBitSize2
                        GHC.Base.Just x -> PVSGenerator.getTypedefBitSize wild1 x } }
                   LexerTypes.PVS_Maybe ipv -> PVSGenerator.getTypeBitSize1 }) -}
723f1d05bd72cfa1a3730a674d3638c0
  getTypeBitSize1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
ea20065e8193d725f92e20853938b95a
  getTypeBitSize2 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
760cf2ab80b4bac99c132e31c4bf87f8
  getTypeBitSize3 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
2210cda1f2faea83a6618aabb2237f43
  getTypeFromField ::
    [LexerTypes.PVS_Field]
    -> LexerTypes.ID_Path -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (fs :: [LexerTypes.PVS_Field])
                   (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct ipv ipv1
                   -> PVSGenerator.getTypeFromField1
                   LexerTypes.ID x
                   -> GHC.List.lookup
                        @ GHC.Base.String
                        @ LexerTypes.PVSType
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        x
                        fs
                   LexerTypes.ID_Vect x n
                   -> GHC.List.lookup
                        @ GHC.Base.String
                        @ LexerTypes.PVSType
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        x
                        fs }) -}
a3b099adc00c6409b3d88e091572d063
  getTypeFromField1 :: GHC.Base.Maybe LexerTypes.PVSType
  {- Strictness: x -}
3339b052a4e08f62b5d6915e17e17006
  getTypeFromLV ::
    LexerTypes.LocalVar -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.ID_Path,
                           Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType),
                           LexerTypes.Expression)) ->
                 case ds of wild { (,,) i ds1 ds2 ->
                 case ds1 of wild1 {
                   Data.Either.Left x
                   -> case x of wild2 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ LexerTypes.PVSType
                        GHC.Base.Just a1
                        -> GHC.Base.Just @ LexerTypes.PVSType (BSV2PVS.b2pType a1) }
                   Data.Either.Right x -> x } }) -}
c0e94a8a7497f1f5d28713441383fe0f
  getTypeFromState ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSTypeDef]
    -> [LexerTypes.PVSstateDec]
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.ID_Path
    -> LexerTypes.PVSType
  {- Arity: 6,
     Strictness: <L,U(U,A,A,A,A,A,A)><L,U><L,U><S,U><L,1*U><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (tds :: [LexerTypes.PVSTypeDef])
                   (sts :: [LexerTypes.PVSstateDec])
                   (lvs :: [LexerTypes.LocalVar])
                   (context :: GHC.Base.Maybe (GHC.Base.String, GHC.Base.String))
                   (i :: LexerTypes.ID_Path) ->
                 case PVSGenerator.lvLookup tds i lvs of wild {
                   GHC.Base.Nothing
                   -> case PVSGenerator.stLookup uni tds i sts of wild1 {
                        GHC.Base.Nothing
                        -> case PVSGenerator.wireLookup uni tds sts context i of wild2 {
                             GHC.Base.Nothing
                             -> case PVSGenerator.stGlobalLookup tds i sts of wild3 {
                                  GHC.Base.Nothing -> PVSGenerator.getTypeFromState1 lvs i sts tds
                                  GHC.Base.Just a2 -> a2 }
                             GHC.Base.Just a2 -> a2 }
                        GHC.Base.Just a2 -> a2 }
                   GHC.Base.Just a2 -> a2 }) -}
f41e9bf96fb918f31cbc9b3d61f3fe0e
  getTypeFromState1 ::
    [LexerTypes.LocalVar]
    -> LexerTypes.ID_Path
    -> [LexerTypes.PVSstateDec]
    -> [LexerTypes.PVSTypeDef]
    -> LexerTypes.PVSType
  {- Arity: 4, Strictness: <B,1*U><B,1*U><B,1*U><B,1*U>x -}
ca3c107bb5f0ff7f036b8b41b9f163c4
  getTypedefBitSize ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSTypeDef -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <L,U(A,A,U,A,A,A,A)><S,1*U> -}
4ace3911ebb67729195334fd3c45b0e9
  getVectorInit ::
    LexerTypes.PVSPackage
    -> GHC.Types.Int -> LexerTypes.VectorInit -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,1*U(U)><S,1*U> -}
bb2d80b144b4aeaba336d91709d968ff
  getVectorInit' ::
    LexerTypes.PVSPackage
    -> (GHC.Types.Int, LexerTypes.Literal) -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(U,A,U,A,U,U,U)><S(S(S)L),1*U(1*U(U),U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: (GHC.Types.Int, LexerTypes.Literal)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 PVSGenerator.$wgetVectorInit' w ww4 ww2 } }) -}
4f9430185ac573f50a97fd34c7b0f0c6
  getVectorInit'1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" := "#) -}
332d442313be7a267e7572c17d671d95
  getWireDeps ::
    [LexerTypes.TransitionTable]
    -> GHC.Base.Maybe LexerTypes.Expression
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.TransitionTable]
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
d0843a35ac96c943553cd7f81f82d8eb
  getWireDeps' ::
    [LexerTypes.TransitionTable]
    -> LexerTypes.TransitionTable -> [LexerTypes.TransitionTable]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (tables :: [LexerTypes.TransitionTable])
                   (ds :: LexerTypes.TransitionTable) ->
                 case ds of wild {
                   DEFAULT -> PVSGenerator.getWireDeps'2
                   LexerTypes.TransDWire i tree dv
                   -> PVSGenerator.filterWires
                        (GHC.Base.map
                           @ LexerTypes.ID_Path
                           @ LexerTypes.ID_Path
                           PVSGenerator.idTopLevel
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (PVSGenerator.getReadsByOverTree PVSGenerator.getWireDeps'1 tree)))
                        tables }) -}
1e10b74475fb4ffdf6a8ebc851d78ee7
  getWireDeps'1 :: LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: LexerTypes.ID_Path) -> GHC.Types.True) -}
2970f7b745a8e8c31b029cb7ce6f36d5
  getWireDeps'2 :: [LexerTypes.TransitionTable]
  {- Strictness: x -}
d910fb8420d6d7af6b5826e663ad08f4
  groupByArgs ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVStransition] -> [[LexerTypes.PVStransition]]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,U,A,A,A,A)><S,1*U> -}
afad006596154229d55a7f7fe8a31ae8
  idTopLevel :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct x y -> LexerTypes.ID x
                   LexerTypes.ID x -> LexerTypes.ID x
                   LexerTypes.ID_Vect x n -> LexerTypes.ID x }) -}
f7652593e884159735a0cd1d76f6b275
  invertID :: LexerTypes.ID_Path -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
c5353a74eedc77948adf4692339c6191
  isDWire ::
    LexerTypes.PVSstateDec -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSstateDec) (w1 :: LexerTypes.ID_Path) ->
                 case w of ww { (,) ww1 ww2 -> PVSGenerator.$wisDWire ww2 w1 }) -}
e083c3e4b3804df12ec0a58efde8b330
  isDWire' ::
    LexerTypes.ID_Path -> LexerTypes.PVSstate -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (i :: LexerTypes.ID_Path) (ds :: LexerTypes.PVSstate) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   LexerTypes.PVS_DWire i' ds1 ds2 -> PVSGenerator.pathEq i i' }) -}
d2fadcbe82dbe8fb14d41778363d7911
  isEnum :: LexerTypes.PVSTypeDef -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.PVSTypeDef) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   LexerTypes.PVS_Enumeration ds1 ds2 -> GHC.Types.True }) -}
da73462b9d3d807f8990b7b6a81e11ff
  isMethTop ::
    GHC.Base.String -> LexerTypes.ValueMethod -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><S(LSLLLLL),1*U(A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (y :: GHC.Base.String)
                   (ds :: (LexerTypes.MethodName, LexerTypes.ModuleName,
                           GHC.Base.String, LexerTypes.Path, LexerTypes.PVSType,
                           LexerTypes.Expression, [LexerTypes.ID_Path])) ->
                 case ds of wild { (,,,,,,) ds1 x ds2 ds3 ds4 ds5 ds6 ->
                 GHC.Base.eqString x y }) -}
355b71eac105c6870f3605ff3086bb9b
  isNotDefault ::
    LexerTypes.PVSPackage -> LexerTypes.Expression -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,U,A)><S,1*U> -}
8af703aa5d016d5c85939ce5f278b8b4
  isNotDefault' ::
    LexerTypes.PVSPackage
    -> (GHC.Base.String, LexerTypes.Expression)
    -> [(GHC.Base.String, LexerTypes.Expression)]
    -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,U,A)><S(LS),1*U(U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: (GHC.Base.String, LexerTypes.Expression))
                   (w2 :: [(GHC.Base.String, LexerTypes.Expression)]) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wisNotDefault' w ww1 ww2 w2 }) -}
e9f2f5e1a29739b860730e46789737f6
  isNotSubModEntity ::
    [LexerTypes.PVSstate] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (st :: [LexerTypes.PVSstate]) (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct x y
                   -> PVSGenerator.isStruct'' st (LexerTypes.ID_Submod_Struct x y)
                   LexerTypes.ID x -> GHC.Types.True
                   LexerTypes.ID_Vect ipv ipv1
                   -> PVSGenerator.eliminateSubModEntities1 }) -}
674b8af9cd5a097dcef48ec930b6c046
  isStruct ::
    [LexerTypes.PVSTypeDef] -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
bde77862d59f7468531ef0a514c26233
  isStruct' :: LexerTypes.PVSTypeDef -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.PVSTypeDef) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   LexerTypes.PVS_Struct ds1 ds2 -> GHC.Types.True }) -}
f51e94d5a25aa19a07506a1b89ff49a1
  isStruct'' ::
    [LexerTypes.PVSstate] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
74e74896a8696b413da3e6a42854d1ac
  isSubmod :: LexerTypes.PVSstate -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.PVSstate) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   LexerTypes.PVS_SubModuleDec ds1 ds2 ds3
                   -> case ds2 of wild1 {
                        [] -> GHC.Types.False : ipv ipv1 -> GHC.Types.True } }) -}
03e0595ea1f0d01522f6acb336d086a9
  isSynonym :: LexerTypes.PVSTypeDef -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.PVSTypeDef) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   LexerTypes.PVS_Synonym ds1 ds2 -> GHC.Types.True }) -}
d393f91cef7ce5ec861f89768a60deaa
  isWireOrFifo ::
    LexerTypes.PVSstateDec -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSstateDec) (w1 :: LexerTypes.ID_Path) ->
                 case w of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wisWireOrFifo ww2 w1 }) -}
b7167ada814a0c4b4afa1557d3d0de22
  isWireOrFifo' ::
    LexerTypes.ID_Path -> LexerTypes.PVSstate -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (i :: LexerTypes.ID_Path) (ds :: LexerTypes.PVSstate) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   LexerTypes.PVS_Fifo ds1 i' ds2 -> PVSGenerator.pathEq i i'
                   LexerTypes.PVS_DWire i' ds1 ds2 -> PVSGenerator.pathEq i i' }) -}
0e9fe1bdaf034ce76e59755dca73719f
  isWireOrFifo'' ::
    [LexerTypes.PVSstateDec] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                PVSGenerator.isWireOrFifo''1
                  `cast`
                (<[LexerTypes.PVSstateDec]>_R
                 ->_R <LexerTypes.ID_Path>_R
                 ->_R Data.Monoid.N:Any[0]) -}
8a542eac33ceadbf3cc07c46d3f3721a
  isWireOrFifo''1 ::
    [LexerTypes.PVSstateDec] -> LexerTypes.ID_Path -> Data.Monoid.Any
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ss :: [LexerTypes.PVSstateDec]) (i :: LexerTypes.ID_Path) ->
                 letrec {
                   go4 :: [(LexerTypes.Name, [LexerTypes.PVSstate])]
                          -> Data.Monoid.Any
                     <join 1> {- Arity: 1 -}
                   = \ (ds :: [(LexerTypes.Name, [LexerTypes.PVSstate])]) ->
                     case ds of wild {
                       [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                       : y ys
                       -> case PVSGenerator.isWireOrFifo y i of wild1 {
                            GHC.Types.False -> go4 ys
                            GHC.Types.True
                            -> GHC.Types.True
                                 `cast`
                               (Nth:3
                                    (Nth:3
                                         (Trans
                                              (Sym (Data.Monoid.N:Any[0])
                                               ->_R Sym (Data.Monoid.N:Any[0])
                                               ->_R <GHC.Types.Bool>_R)
                                              (<Data.Monoid.Any>_R
                                               ->_R <Data.Monoid.Any>_R
                                               ->_R Sym (Data.Monoid.N:Any[0]))))) } }
                 } in
                 go4 ss) -}
2b2efd78212a15af5175709065ee2be2
  isntIn ::
    GHC.Base.String -> [LexerTypes.PVS_Field] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
fa770f9297f9a65da87e507bdd8d79bb
  justTheMaybes :: [LexerTypes.PVSType] -> [LexerTypes.PVSType]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [LexerTypes.PVSType]) ->
                 case PVSGenerator.$wjustTheMaybes w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ LexerTypes.PVSType ww1 ww2 }) -}
8d81ccca210ec50fb41798cac80dca3c
  justTheName ::
    (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (LexerTypes.TransitionTable, [LexerTypes.ID_Path])) ->
                 case w of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wjustTheName ww1 ww2 }) -}
20e1d0c0124279466d730ea63f2e5071
  justTheName' :: LexerTypes.TransitionTable -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.TransitionTable) ->
                 case ds of wild {
                   LexerTypes.TransMod x ds1 -> x
                   LexerTypes.TransReg i ds1 -> LexerTypes.$fShowID_Path_$cshow i
                   LexerTypes.TransVect i ds1 ds2 -> LexerTypes.$fShowID_Path_$cshow i
                   LexerTypes.TransStruct x ds1 -> x
                   LexerTypes.TransDWire i ds1 ds2
                   -> LexerTypes.$fShowID_Path_$cshow i
                   LexerTypes.TransFIFO i ds1 ds2 ds3
                   -> LexerTypes.$fShowID_Path_$cshow i }) -}
4ab677e7d53f5d527c80d34f2dbb735e
  killRefs ::
    [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
    -> LexerTypes.ID_Path
    -> [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
eb535d9056f356dcd7674c894385f24d
  killRefsWithNoTransition ::
    [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
    -> [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (ts :: [(LexerTypes.TransitionTable,
                            [LexerTypes.ID_Path])]) ->
                 PVSGenerator.killRefsWithNoTransition_go
                   ts
                   (let {
                      noms :: [LexerTypes.ID_Path]
                      = GHC.Base.map
                          @ (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
                          @ LexerTypes.ID_Path
                          PVSGenerator.killRefsWithNoTransition1
                          ts
                    } in
                    let {
                      lvl568 :: LexerTypes.ID_Path -> GHC.Types.Bool
                        {- Arity: 1, Strictness: <L,U>,
                           Unfolding: InlineRule (1, True, False)
                                      (\ (x :: LexerTypes.ID_Path) ->
                                       GHC.List.elem
                                         @ LexerTypes.ID_Path
                                         LexerTypes.$fEqID_Path
                                         x
                                         noms) -}
                      = \ (x :: LexerTypes.ID_Path) ->
                        GHC.List.elem @ LexerTypes.ID_Path LexerTypes.$fEqID_Path x noms
                    } in
                    GHC.Base.map
                      @ (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
                      @ [LexerTypes.ID_Path]
                      (\ (x :: (LexerTypes.TransitionTable, [LexerTypes.ID_Path])) ->
                       case x of wild { (,) ds1 y ->
                       GHC.List.filter @ LexerTypes.ID_Path lvl568 y })
                      ts)) -}
6cb0ae747b969f639cd67fcb46e02b9c
  killRefsWithNoTransition1 ::
    (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
    -> LexerTypes.ID_Path
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (LexerTypes.TransitionTable, [LexerTypes.ID_Path])) ->
                 case w of ww { (,) ww1 ww2 -> PVSGenerator.$wlvl ww1 }) -}
dd645d2adcbc5bd0bb7aab01cd40daba
  killRefsWithNoTransition_go ::
    [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
    -> [[LexerTypes.ID_Path]]
    -> [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
82ba1fd8fbf8b076deaf15f121e23874
  killStateWires :: [LexerTypes.PVSstate] -> [LexerTypes.PVSstate]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
26e5b15118c4e52b0d7da8f095a27987
  killSurfaceWires ::
    [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [LexerTypes.TransitionTable]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ LexerTypes.TransitionTable
                   : ds1 xs
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> GHC.Types.:
                             @ LexerTypes.TransitionTable
                             wild1
                             (PVSGenerator.killWires xs)
                        LexerTypes.TransDWire ds2 ds3 ds4
                        -> PVSGenerator.killWires xs } }) -}
09c041cb9cad3f2cd6d0ee58e5f5034f
  killVoids :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c7c2bbcd9f39470ce0ad8e380e89b739
  killWires ::
    [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
720e0232488fa1ef4926f5af6fcc0bbc
  killWires' ::
    LexerTypes.TransitionTable -> LexerTypes.TransitionTable
  {- Arity: 1, Strictness: <S,1*U>m1,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.TransitionTable) ->
                 case ds of wild {
                   DEFAULT -> PVSGenerator.killWires'1
                   LexerTypes.TransMod x ts
                   -> LexerTypes.TransMod x (PVSGenerator.killWires ts) }) -}
3e3ec6225522542970a277a999623bae
  killWires'1 :: LexerTypes.TransitionTable
  {- Strictness: x -}
150c9fb3d03631fb87ed4f283118d6ae
  kludgeInit ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSType -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,1*U(A,A,U,A,A,U,A)><S,1*U> -}
9c244aa89e6e97d5046aed77b01a1497
  kludgeInit' ::
    LexerTypes.PVSPackage -> LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,A,U,A,A,U,A)><S,1*U> -}
2dfd2550c6749c44f423b472774bee37
  kludgeInit'' ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSType -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,1*U(A,A,U,A,A,U,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (uni :: LexerTypes.PVSPackage) (ds :: LexerTypes.PVSType) ->
                 case ds of wild {
                   DEFAULT -> PVSGenerator.kludgeInit uni wild
                   LexerTypes.PVS_Maybe x
                   -> LexerTypes.Tagged
                        (GHC.Base.Just @ LexerTypes.PVSType x)
                        LexerTypes.Invalid }) -}
204a9445a39a30fff5f341edf5b5891e
  lookupInst ::
    [LexerTypes.PVSInstDef]
    -> LexerTypes.PVSType -> GHC.Base.Maybe LexerTypes.PVSInstDef
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
b8a65a51586de87bb2cbea43f11cc68b
  lookupTable ::
    LexerTypes.ID_Path
    -> [LexerTypes.TransitionTable]
    -> GHC.Base.Maybe LexerTypes.TransitionTable
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
ceaa87f5e093190c7955ac6d4b7eb0b3
  lookupTable' ::
    LexerTypes.ID_Path
    -> [LexerTypes.TransitionTable]
    -> GHC.Base.Maybe LexerTypes.TransitionTable
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (i :: LexerTypes.ID_Path)
                   (ts :: [LexerTypes.TransitionTable]) ->
                 PVSGenerator.lookupTable i (PVSGenerator.lookupTable'_go ts)) -}
a8d66fcbec07f355c4e97693b3f626ff
  lookupTable'_go ::
    [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 1, Strictness: <S,1*U> -}
0b021a64ad0b0de0feea3b52234b7167
  lvLookup ::
    [LexerTypes.PVSTypeDef]
    -> LexerTypes.ID_Path
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 3, Strictness: <L,U><L,1*U><S,1*U> -}
181b71193ee8e1a559c0ae4b8bdfd4d8
  makeStateDepTuples ::
    LexerTypes.PVSstateDec
    -> [LexerTypes.PVSstateDec]
    -> ([GHC.Base.String], LexerTypes.PVSstateDec)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><L,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSstateDec)
                   (w1 :: [LexerTypes.PVSstateDec]) ->
                 case w of ww { (,) ww1 ww2 ->
                 case PVSGenerator.$wmakeStateDepTuples
                        ww1
                        ww2
                        w1 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
b2f7f192476abf1a7e45021d0f419f63
  makeStateDepTuples1 :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (y :: [GHC.Types.Char]) ->
                 GHC.CString.unpackAppendCString# "mk"# y) -}
122338ccd501dcc03b2561a4984df5e1
  needsHistory ::
    LexerTypes.PVSPackage -> LexerTypes.PVStransition -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,U(U,A,U,A,U,U,U)><S(LLLS),1*U(A,A,A,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVStransition) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 PVSGenerator.$wneedsHistory w ww4 }) -}
7d2341bcbc5351895f5a1e5d563bae31
  noStateTables :: [LexerTypes.TransitionTable] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
05f2a707fbd8a7915305568435a3302a
  notEmpty :: LexerTypes.PVSPackage -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLL),1*U(A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (uni :: LexerTypes.PVSPackage) ->
                 case uni of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 case PVSGenerator.wireFilter ds5 of wild1 {
                   [] -> GHC.Types.False : ds11 ds12 -> GHC.Types.True } }) -}
bbf950ed0997eadd7beee0dcc7290afe
  orderLets ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.TransitionTable]
  {- Arity: 5, Strictness: <L,A><L,U(A,U)><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: [LexerTypes.ID_Path])
                   (w3 :: [LexerTypes.TransitionTable])
                   (w4 :: [LexerTypes.TransitionTable]) ->
                 PVSGenerator.$worderLets w1 w2 w3 w4) -}
c63b1cfc77f3dfe1b769fef5dac45bd3
  orderLets1 ::
    (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
    -> (LexerTypes.TransitionTable, [LexerTypes.ID_Path])
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (LexerTypes.TransitionTable, [LexerTypes.ID_Path]))
                   (w1 :: (LexerTypes.TransitionTable, [LexerTypes.ID_Path])) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 PVSGenerator.$wlvl1 ww1 ww2 ww4 ww5 } }) -}
731e7dbc52b0a3073711cc01761bdbb0
  orderStates :: [LexerTypes.PVSstateDec] -> [LexerTypes.PVSstateDec]
  {- Arity: 1, Strictness: <S,1*U> -}
9750307fd94843c5fc7836c39214bf9b
  orderWires' ::
    [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
    -> [LexerTypes.TransitionTable]
  {- Arity: 1, Strictness: <S,1*U> -}
e63e78f70122b1c68f6dd282590bf238
  pathEq ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
5ae4117fdfe299d1b31b31382e6b2e04
  pickInfimum ::
    [(LexerTypes.TransitionTable, [LexerTypes.ID_Path])]
    -> GHC.Base.Maybe LexerTypes.TransitionTable
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
41b78a839648155ed3e0a0118936807d
  preproc :: LexerTypes.PVSPackage -> LexerTypes.PVSPackage
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,1*U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.PVSPackage) ->
                 case w of ww { LexerTypes.PVSPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 LexerTypes.PVSPackage
                   ww1
                   ww2
                   ww3
                   ww4
                   (GHC.Base.map
                      @ (LexerTypes.PackageName, [LexerTypes.PVSstate])
                      @ ([GHC.Types.Char], [LexerTypes.PVSstate])
                      (\ (ds :: (LexerTypes.PackageName, [LexerTypes.PVSstate])) ->
                       case ds of wild { (,) x xs ->
                       case GHC.Base.eqString x ww1 of wild1 {
                         GHC.Types.False -> (x, xs)
                         GHC.Types.True -> (PVSGenerator.addPreIfMissing1, xs) } })
                      ww5)
                   ww6
                   ww7 }) -}
231e7008b0c70ea41f754c7d456aa5f8
  readIntLit :: LexerTypes.Expression -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U> -}
de102b3d50428591292ccacbc7e84bb7
  removePathOverlaps :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (id :: LexerTypes.ID_Path) ->
                 case BSV2PVS.$widpath2strings id of ww { (#,#) ww1 ww2 ->
                 BSV2PVS.strings2idpath
                   (Data.OldList.nubBy
                      @ GHC.Base.String
                      GHC.Base.eqString
                      (GHC.Types.: @ GHC.Base.String ww1 ww2)) }) -}
0f34011ad46e134d7495bd72f8f955f4
  removePathOverlaps' :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (xs :: GHC.Base.String) ->
                 case Data.OldList.nubBy
                        @ [GHC.Types.Char]
                        GHC.Base.eqString
                        (GHC.Base.map
                           @ (Data.List.Split.Internals.Chunk GHC.Types.Char)
                           @ [GHC.Types.Char]
                           (Data.List.Split.Internals.fromElem @ GHC.Types.Char)
                           (Data.List.Split.Internals.$wpostProcess
                              @ GHC.Types.Char
                              Data.List.Split.Internals.Drop
                              Data.List.Split.Internals.KeepBlankFields
                              Data.List.Split.Internals.KeepBlank
                              Data.List.Split.Internals.KeepBlank
                              (Data.List.Split.Internals.splitInternal
                                 @ GHC.Types.Char
                                 PVSGenerator.removePathOverlaps'3
                                   `cast`
                                 (Sym (Data.List.Split.Internals.N:Delimiter[0] <GHC.Types.Char>_R))
                                 xs))) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.removePathOverlaps'1
                           xs1) }) -}
042496aed461ffaece4e684e79e814f6
  removePathOverlaps'1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.removePathOverlaps'2) -}
10ee1f3b20563029dc339b27148ae7dc
  removePathOverlaps'2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`"#) -}
2df6ca3f3aec703be446917ba22fdd93
  removePathOverlaps'3 :: [GHC.Types.Char -> GHC.Types.Bool]
  {- Unfolding: (GHC.CString.unpackFoldrCString#
                   @ [GHC.Types.Char -> GHC.Types.Bool]
                   PVSGenerator.removePathOverlaps'2
                   PVSGenerator.removePathOverlaps'4
                   (GHC.Types.[] @ (GHC.Types.Char -> GHC.Types.Bool))) -}
55bba55a18aceebe162ba1d90fab1bba
  removePathOverlaps'4 ::
    GHC.Types.Char
    -> [GHC.Types.Char -> GHC.Types.Bool]
    -> [GHC.Types.Char -> GHC.Types.Bool]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><L,U>m2,
     Unfolding: (\ (x :: GHC.Types.Char)
                   (ys :: [GHC.Types.Char -> GHC.Types.Bool])[OneShot] ->
                 GHC.Types.:
                   @ (GHC.Types.Char -> GHC.Types.Bool)
                   (GHC.Classes.eqChar x)
                   ys) -}
11bdeaceed9de392466add154855d095
  sameName ::
    LexerTypes.ValueMethod -> LexerTypes.ValueMethod -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,A,A,A,A,A)><S(SLLLLLL),1*U(1*U,1*U,A,A,A,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.ValueMethod) (w1 :: LexerTypes.ValueMethod) ->
                 case w of ww { (,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { (,,,,,,) ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 PVSGenerator.$wsameName ww1 ww2 ww9 ww10 } }) -}
d85a2d162ce7e997a2142b628e7b4f03
  seekTable ::
    [LexerTypes.TransitionTable]
    -> [GHC.Base.String] -> [LexerTypes.TransitionTable]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
c85ecea9b17ce1e3b723bf76a0cd6fc0
  showBinding ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.LocalVar
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><S(SSL),1*U(1*U,1*U,U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: [LexerTypes.LocalVar])
                   (w2 :: GHC.Base.Maybe (GHC.Base.String, GHC.Base.String))
                   (w3 :: LexerTypes.LocalVar)
                   (w4 :: GHC.Base.String) ->
                 case w3 of ww { (,,) ww1 ww2 ww3 ->
                 PVSGenerator.$wshowBinding w w1 w2 ww1 ww2 ww3 w4 }) -}
1b264e1d39ace17795e26bc5a474e902
  showClusterField' ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe LexerTypes.DefaultValue
    -> GHC.Base.Maybe LexerTypes.PVSType
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.PVSType
    -> (GHC.Base.String, LexerTypes.Expression)
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 8,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><L,A><L,U><L,1*U><S(SS),1*U(U,U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (8, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: [LexerTypes.LocalVar])
                   (w2 :: GHC.Base.Maybe LexerTypes.DefaultValue)
                   (w3 :: GHC.Base.Maybe LexerTypes.PVSType)
                   (w4 :: GHC.Base.Maybe (GHC.Base.String, GHC.Base.String))
                   (w5 :: LexerTypes.PVSType)
                   (w6 :: (GHC.Base.String, LexerTypes.Expression))
                   (w7 :: GHC.Base.String) ->
                 case w6 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowClusterField' w w1 w2 w4 w5 ww1 ww2 w7 }) -}
2d730a233c52037a48fb6323d4e6f004
  showIDPath ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><S,1*U><L,U> -}
efb136a48158578e8f1e68a63ce976e8
  showIDPath' ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><S,1*U><L,U> -}
a19b9fcca613e7a86d98d5ee0e8c32ff
  showLet ::
    LexerTypes.PVSPackage
    -> LexerTypes.TransitionTable
    -> GHC.Base.String
    -> GHC.Base.String
    -> [GHC.Base.String]
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U><L,U><L,U> -}
fc0a4758a9b5be520d7d9c068f038d14
  showLit ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe LexerTypes.DefaultValue
    -> GHC.Base.Maybe LexerTypes.PVSType
    -> LexerTypes.Lit
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,1*U><L,1*U><S,1*U><L,U><L,U>,
     Unfolding: (\ (ds :: LexerTypes.PVSPackage)
                   (ds1 :: [LexerTypes.LocalVar])
                   (ds2 :: GHC.Base.Maybe LexerTypes.DefaultValue)
                   (ds3 :: GHC.Base.Maybe LexerTypes.PVSType)
                   (ds4 :: LexerTypes.Lit)
                   (ds5 :: GHC.Base.Maybe (GHC.Base.String, GHC.Base.String))
                   (ds6 :: GHC.Base.String) ->
                 case ds4 of wild {
                   LexerTypes.LitString x -> GHC.Show.$fShow[]_$s$cshow1 x
                   LexerTypes.LitEnum x -> x
                   LexerTypes.LitInt x -> GHC.Show.$fShowInteger_$cshow x
                   LexerTypes.LitBool x -> GHC.Show.$fShowBool_$cshow x
                   LexerTypes.LitReal x -> GHC.Float.$fShowFloat_$cshow x
                   LexerTypes.LitChar x -> GHC.Show.$fShowChar_$cshow x
                   LexerTypes.LitSizedInt ds7 x -> GHC.Show.$fShowInteger_$cshow x
                   LexerTypes.LitStructConstructor
                   -> case ds2 of wild1 {
                        GHC.Base.Nothing
                        -> case ds3 of wild2 {
                             GHC.Base.Nothing -> PVSGenerator.showLit2
                             GHC.Base.Just typ
                             -> GHC.CString.unpackAppendCString#
                                  PVSGenerator.showLit1
                                  (PVSGenerator.$wshowPVSType typ) }
                        GHC.Base.Just x
                        -> case ds3 of wild2 {
                             GHC.Base.Nothing
                             -> PVSGenerator.showPVSExpression
                                  ds
                                  ds1
                                  wild1
                                  (GHC.Base.Nothing @ LexerTypes.PVSType)
                                  x
                                  ds5
                                  ds6
                             GHC.Base.Just typ
                             -> GHC.CString.unpackAppendCString#
                                  PVSGenerator.showLit1
                                  (PVSGenerator.$wshowPVSType typ) } }
                   LexerTypes.LitVoid -> GHC.Types.[] @ GHC.Types.Char }) -}
2b03931d587cb4aca4fa5d9923bd1dee
  showLit1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("mk"#) -}
557ac32707c104a5dbce8e8f134d906b
  showLit2 :: GHC.Base.String
  {- Strictness: x -}
3945d38beb3ff16763e7dcb2d4498fe3
  showOutTime :: LexerTypes.Temporal -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(S)),1*U(1*U(U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.Temporal) ->
                 case w of ww { LexerTypes.N_Time ww1 ->
                 case ww1 of ww2 { GHC.Types.I# ww3 ->
                 PVSGenerator.$wshowOutTime ww3 } }) -}
4ab0da99eb5815ccdc67e5863a4e8499
  showPVSArgument ::
    LexerTypes.PVSPackage -> LexerTypes.PVSArgument -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVSArgument) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSArgument ww1 ww2 }) -}
75ea24654baf513d2d76c9bcf339dee7
  showPVSConstantDeclaration ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSConstantDec -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S(SLL),1*U(1*U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSConstantDec) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 PVSGenerator.$wshowPVSConstantDeclaration w ww1 ww2 ww3 }) -}
dbcdbc281dfae625a97a2135e6aee702
  showPVSDefInst ::
    LexerTypes.PVSPackage -> LexerTypes.PVSInstDef -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S(LS),1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVSInstDef) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSDefInst w ww1 ww2 }) -}
7092bf83cab90d7db3de37f5ebf0ef1a
  showPVSDefInst1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.showPVSDefInst2
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
3cef6e28c615ffcfd4ed0c0610db4779
  showPVSDefInst2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSDefInst3) -}
9c1ef39e2e691bbb13ebd61662483e54
  showPVSDefInst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("#)"#) -}
d11b92e51502896f235079d968b07749
  showPVSDefInst4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSDefInst5) -}
13e281370bfbcd70d7481398a3d28339
  showPVSDefInst5 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \         , "#) -}
5656c7cf99e351f3df1b2f18c98aa1c5
  showPVSDefInst6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("= (# "#) -}
7561ce23fd78c68b19fa698293fd1d56
  showPVSExpression ::
    LexerTypes.PVSPackage
    -> [LexerTypes.LocalVar]
    -> GHC.Base.Maybe LexerTypes.DefaultValue
    -> GHC.Base.Maybe LexerTypes.PVSType
    -> LexerTypes.Expression
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><L,U><S,U><L,U><L,U> -}
da68c51ec9b8f2174ea8f1fa4d59695c
  showPVSFunc ::
    LexerTypes.PVSPackage -> LexerTypes.PVSFunction -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,U(U,A,U,A,U,U,U)><S(SLLL),1*U(1*U,U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVSFunction) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 PVSGenerator.$wshowPVSFunc w ww1 ww2 ww3 ww4 }) -}
bdb47fb732d4ad5a71f8ea1129e7223b
  showPVSFunc1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\t= "#) -}
5ad20ffd1f1778d3768e0fed19f13163
  showPVSInstanceDef ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> (GHC.Base.String, LexerTypes.Literal)
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><S(SL),1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.String)
                   (w2 :: (GHC.Base.String, LexerTypes.Literal)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSInstanceDef w w1 ww1 ww2 }) -}
4ae3a505ac725879433175438541ec04
  showPVSInstanceDef1 :: LexerTypes.PVSType
  {- Strictness: x -}
6cc386f639d18bf884f6732d72f9204c
  showPVSInstanceDef2 :: LexerTypes.PVSTypeDef
  {- Strictness: x -}
84afb0c52a617dc6c3aba3e5474fe473
  showPVSMethods ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVStransition] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (trans :: [LexerTypes.PVStransition]) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   PVSGenerator.showPVSMethods6
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.showPVSMethods4
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         (case GHC.Base.map
                                 @ (LexerTypes.MethodName, LexerTypes.ModuleName, GHC.Base.String,
                                    LexerTypes.Path, LexerTypes.PVSType, LexerTypes.Expression,
                                    [LexerTypes.ID_Path])
                                 @ [GHC.Types.Char]
                                 (\ (w :: LexerTypes.ValueMethod) ->
                                  case w of ww { (,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                                  PVSGenerator.$wshowValueMethod uni trans ww1 ww2 ww3 ww5 ww6 })
                                 (Data.OldList.nubBy
                                    @ LexerTypes.ValueMethod
                                    PVSGenerator.sameName
                                    (PVSGenerator.showPVSMethods_go trans)) of wild {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : x xs1
                            -> Data.OldList.intercalate_$spoly_go
                                 @ GHC.Types.Char
                                 x
                                 (Data.OldList.prependToAll
                                    @ [GHC.Types.Char]
                                    PVSGenerator.generateTabspecs1
                                    xs1) })
                         PVSGenerator.showPVSMethods1))) -}
b6a2650f65e75dc5941f25baafa787cc
  showPVSMethods1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.showPVSMethods2
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
f6e4c0297a0b20eae327032f60d1291a
  showPVSMethods2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSMethods3) -}
cd5ea3ae807a67b5ef4285f84fef0c3e
  showPVSMethods3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \end Methods"#) -}
73abbb496ef456e17c4f760a3f176ec0
  showPVSMethods4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSMethods5) -}
4a3731a4cbf1fc9f9007a9f947ffe293
  showPVSMethods5 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\n\
                 \\n\
                 \\t"#) -}
b5d0e894f73f3f160cb09f7f198ca4db
  showPVSMethods6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSMethods7) -}
43239f84a2d7277f40ff3365a7473b43
  showPVSMethods7 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Methods : theory\n\
                 \\n\
                 \begin\n\
                 \\n\
                 \\timporting State"#) -}
c14f0764ef071e49a51bbb1816260bf0
  showPVSMethods_go ::
    [(GHC.Integer.Type.Integer,
      [(LexerTypes.MethodName,
        [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
      [LexerTypes.ValueMethod], [LexerTypes.TransitionTable])]
    -> [LexerTypes.ValueMethod]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
3850dba28f87abcdc155c19a0d85e57d
  showPVSPackage ::
    LexerTypes.PVSPackage
    -> GHC.Base.Maybe LexerTypes.TSPpackage -> [LexerTypes.File]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U)><L,U>m2, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: GHC.Base.Maybe LexerTypes.TSPpackage) ->
                 case PVSGenerator.$wshowPVSPackage w w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ LexerTypes.File ww1 ww2 }) -}
810d68fc5cfe25c72465dbabef661dbb
  showPVSPackage1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage2) -}
ed9b087e53bf5da4a0d92e332e2ee12f
  showPVSPackage10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage11) -}
a67409147d44b66d5ebc2e56dd1c4800
  showPVSPackage11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("State.pvs"#) -}
f27f9b0474dff6e98dbfb6fe2740edb6
  showPVSPackage12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage13) -}
06bdc9fa1d904e8d974c02b0918b77bb
  showPVSPackage13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (".pvs"#) -}
942c4dd0af5b29f3ce8065d998fb4be4
  showPVSPackage14 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.showPVSPackage15
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
e856a1fea5439a23d39e02137852f517
  showPVSPackage15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage16) -}
038e16bfb09324044940c15f51c7cdbb
  showPVSPackage16 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \end TypeDefinitions"#) -}
0d34f6eae34a5121625f4c00dded0a06
  showPVSPackage17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage18) -}
9c3f48da26fba667a31bd026e616abb6
  showPVSPackage18 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("TypeDefinitions : theory\n\
                 \\n\
                 \begin\n\
                 \\n\
                 \\timporting arith_bitwise\n\
                 \\timporting Maybe\n\
                 \\timporting FIFO\n\
                 \\n\
                 \\tInt(n : int): TYPE = {i:int | -(2^(n-1)) <= i AND i < 2^(n-1)}\n\
                 \\tUInt(n : int): TYPE = {i:int | 0 <= i AND i < 2^n}\n\
                 \\tBit(n : int): TYPE = {i:int | 0 <= i AND i < 2^n}\n\
                 \\n\
                 \\tmkInt(n : int) : Int(n) = 0\n\
                 \\tmkUInt(n : int) : UInt(n) = 0\n\
                 \\tmkBit(n : int) : Bit(n) = 0"#) -}
d1e415fc1f166f1ad04ed97dbe152624
  showPVSPackage19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage20) -}
325fef7dd16a3dd992a594fa103df6dd
  showPVSPackage2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Transitions.pvs"#) -}
915ec91e2c1c8f945e648828a84f48a5
  showPVSPackage20 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TypeDefinitions.pvs"#) -}
da7a9f55cd7244112055c109735730be
  showPVSPackage3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage4) -}
121bee869cad8ec5800020de9d5ae6e6
  showPVSPackage4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Methods.pvs"#) -}
0ee438d4b6b113e8c1391d9a09583060
  showPVSPackage5 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.showPVSPackage6
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
c1b72bb54f1c4953c40524de80cd4e51
  showPVSPackage6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage7) -}
63f3b401cceae3da10170d6a22087989
  showPVSPackage7 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \end State"#) -}
834a2a630de6683389f206cb584003da
  showPVSPackage8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSPackage9) -}
dd14d270a22818de8c3587cfbed73de1
  showPVSPackage9 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("State : theory\n\
                 \\n\
                 \begin\n\
                 \\n\
                 \\timporting TypeDefinitions"#) -}
5bde7a332c3965da5ece55505b526d84
  showPVSPackages :: [LexerTypes.PVSPackage] -> [LexerTypes.File]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [LexerTypes.PVSPackage]) ->
                 PVSGenerator.showPVSPackages_go x) -}
b193954b0e25c0e468b842ef79e4b03f
  showPVSPackages_go :: [LexerTypes.PVSPackage] -> [LexerTypes.File]
  {- Arity: 1, Strictness: <S,1*U> -}
f36b1bc0af73e780371bb02d7b41d969
  showPVSStateDef' ::
    LexerTypes.PVSPackage -> LexerTypes.PVSstate -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (ds :: LexerTypes.PVSstate) ->
                 case ds of wild {
                   LexerTypes.PVS_Reg nom typ init
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (PVSGenerator.showIDPath
                           uni
                           (GHC.Types.[] @ LexerTypes.LocalVar)
                           (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                           nom
                           (GHC.Types.[] @ GHC.Types.Char))
                        (GHC.CString.unpackAppendCString#
                           PVSGenerator.displayArgs1
                           (PVSGenerator.$wshowPVSType typ))
                   LexerTypes.PVS_Fifo f nom typ
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (PVSGenerator.showIDPath
                           uni
                           (GHC.Types.[] @ LexerTypes.LocalVar)
                           (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                           nom
                           (GHC.Types.[] @ GHC.Types.Char))
                        (GHC.CString.unpackAppendCString#
                           PVSGenerator.showPVSStateDef'5
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (PVSGenerator.$wshowPVSType typ)
                              PVSGenerator.showPVSStateDef'3))
                   LexerTypes.PVS_Vector nom typ size i
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (PVSGenerator.showIDPath
                           uni
                           (GHC.Types.[] @ LexerTypes.LocalVar)
                           (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                           nom
                           (GHC.Types.[] @ GHC.Types.Char))
                        (GHC.CString.unpackAppendCString#
                           PVSGenerator.showPVSStateDef'2
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (PVSGenerator.$wshowPVSType typ)
                              PVSGenerator.showPVSStateDef'3))
                   LexerTypes.PVS_SubModuleDec interface nom inst
                   -> case nom of wild1 {
                        []
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             inst
                             (GHC.CString.unpackAppendCString#
                                PVSGenerator.displayArgs1
                                interface)
                        : ds1 ds2
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             inst
                             (GHC.CString.unpackAppendCString#
                                PVSGenerator.displayArgs1
                                (case ds2 of wild2 {
                                   [] -> GHC.List.scanl2 @ GHC.Types.Char : ds4 xs -> xs })) }
                   LexerTypes.PVS_DWire ipv ipv1 ipv2
                   -> PVSGenerator.showPVSStateDef'1 }) -}
d50b8603a1383cc0fd73cbf556c13d21
  showPVSStateDef'1 :: GHC.Base.String
  {- Strictness: x -}
16935a4676f535a1309889f11b1dc9d6
  showPVSStateDef'2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : [ nat -> "#) -}
66adc454d19c7176de10b7dd52219f1f
  showPVSStateDef'3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSStateDef'4) -}
29e77426fdae984b5d24bb79256e61ca
  showPVSStateDef'4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("]"#) -}
1c2a060340b97e46e328c44f88c04cd3
  showPVSStateDef'5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : FIFO["#) -}
c42dc28edf06130ce3c72eb71e4b6fe2
  showPVSStateInstance ::
    LexerTypes.PVSPackage -> LexerTypes.PVSstateDec -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U,A,U,A,U,U,U)><S(SL),1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVSstateDec) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSStateInstance w ww1 ww2 }) -}
9ac67a3fffcb9e3f699beda2a71b2475
  showPVSStateInstance' ::
    LexerTypes.PVSPackage
    -> GHC.Base.String -> LexerTypes.PVSstate -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><S,1*U> -}
0a0f9fd5930b87e0468fe0e149987f0f
  showPVSStateInstance1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSStateInstance2) -}
e4e93b7e3b6c92040feca9299c06812e
  showPVSStateInstance10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_var : var "#) -}
10c0f49e4420aab1a54e242d1ab9bf9d
  showPVSStateInstance2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\tAND\t"#) -}
1836ea32031dcd1aa204307b9683904e
  showPVSStateInstance3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSStateInstance4) -}
62e3a34053c84997fc8704d813e95e7b
  showPVSStateInstance4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
b42dfed053ceb309bc33adc3e7706691
  showPVSStateInstance5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   PVSGenerator.showPVSStateInstance6
                   PVSGenerator.showPVSStateInstance3) -}
6aa14ff45a1cfd77f868cb2dfd608e25
  showPVSStateInstance6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSStateInstance7) -}
3ec5f0ea0b3903d6fd73018883020629
  showPVSStateInstance7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("True"#) -}
8da51c142df24ac8dedaf873de37d923
  showPVSStateInstance8 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("_var) : bool\n\
                 \\t=\t"#) -}
03d795ce99c8824476922316d8093c5b
  showPVSStateInstance9 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\n\
                 \\tmk"#) -}
7b8035897671665211fea2a8b495694f
  showPVSStateTypes ::
    LexerTypes.PVSPackage -> LexerTypes.PVSstateDec -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S(SL),1*U(1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVSstateDec) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSStateTypes w ww1 ww2 }) -}
7f9d7ff9fb9fff7b8cc66529b4270cc2
  showPVSStateTypes1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSStateTypes2) -}
6977f1d06e679173ae02a04e0debefa1
  showPVSStateTypes2 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t , "#) -}
a9bb045881fbad1913fd07eb00292274
  showPVSStateTypes3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSStateTypes4) -}
cc5666845423b87854baf8ed60eb7069
  showPVSStateTypes4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t#]"#) -}
fe56c12d437e61d44ea2d1eaee09203c
  showPVSStateTypes5 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: (" : type =\n\
                 \\t\t[# "#) -}
42e7691723b44b26effa70fb576205af
  showPVSStates ::
    LexerTypes.PVSPackage
    -> LexerTypes.PackageName
    -> [LexerTypes.PVSstateDec]
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,A,U,U,U)><L,A><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PackageName)
                   (w2 :: [LexerTypes.PVSstateDec]) ->
                 PVSGenerator.$wshowPVSStates w w2) -}
522d56b2bb019fb6308cf7fb32e28adc
  showPVSTop ::
    LexerTypes.PVSPackage
    -> LexerTypes.PackageName
    -> [LexerTypes.PVStransition]
    -> GHC.Base.Maybe LexerTypes.TSPpackage
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (nom :: LexerTypes.PackageName)
                   (ts :: [LexerTypes.PVStransition])
                   (tsp :: GHC.Base.Maybe LexerTypes.TSPpackage) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   PVSGenerator.showPVSTop11
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.generateTabspecs1
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         (case ts of wild {
                            [] -> PVSGenerator.showPVSTop9
                            : ds1 ds2 -> PVSGenerator.showPVSTop7 })
                         (GHC.Types.:
                            @ [GHC.Types.Char]
                            (case ts of wild {
                               [] -> GHC.Types.[] @ GHC.Types.Char
                               : ds1 ds2
                               -> case uni of wild1 { LexerTypes.PVSPackage ds4 ds5 ds3 ds6 ds7 ds8 ds9 ->
                                  case GHC.List.lookup
                                         @ GHC.Base.String
                                         @ [LexerTypes.PVSstate]
                                         GHC.Classes.$fEq[]_$s$fEq[]1
                                         ds4
                                         ds7 of wild2 {
                                    GHC.Base.Nothing
                                    -> case PVSGenerator.genConsTheorems1 ds4
                                       ret_ty [GHC.Types.Char]
                                       of {}
                                    GHC.Base.Just x
                                    -> case PVSGenerator.stateless' x of wild3 {
                                         GHC.Types.False
                                         -> Data.OldList.intercalate_$spoly_go
                                              @ GHC.Types.Char
                                              (GHC.CString.unpackAppendCString#
                                                 PVSGenerator.showPVSTop6
                                                 (GHC.Base.++
                                                    @ GHC.Types.Char
                                                    nom
                                                    PVSGenerator.showPVSStateDef'3))
                                              (Data.OldList.prependToAll
                                                 @ [GHC.Types.Char]
                                                 PVSGenerator.genTabVars1
                                                 (GHC.Types.:
                                                    @ [GHC.Types.Char]
                                                    (GHC.CString.unpackAppendCString#
                                                       PVSGenerator.showPVSTop5
                                                       (GHC.Base.++
                                                          @ GHC.Types.Char
                                                          nom
                                                          (GHC.CString.unpackAppendCString#
                                                             PVSGenerator.showPVSTop4
                                                             nom)))
                                                    (GHC.Types.[] @ [GHC.Types.Char])))
                                         GHC.Types.True -> GHC.Types.[] @ GHC.Types.Char } } } })
                            (GHC.Types.:
                               @ [GHC.Types.Char]
                               (PVSGenerator.generateTabspecs uni tsp)
                               (GHC.Types.:
                                  @ [GHC.Types.Char]
                                  (PVSGenerator.genDocumentation uni ts)
                                  (GHC.Types.:
                                     @ [GHC.Types.Char]
                                     (PVSGenerator.showProofTheory uni nom ts tsp)
                                     (GHC.Types.:
                                        @ [GHC.Types.Char]
                                        (case PVSGenerator.genConsTheorems uni ts nom of wild {
                                           [] -> GHC.Types.[] @ GHC.Types.Char
                                           : x xs1
                                           -> Data.OldList.intercalate_$spoly_go
                                                @ GHC.Types.Char
                                                x
                                                (Data.OldList.prependToAll
                                                   @ [GHC.Types.Char]
                                                   PVSGenerator.generateTabspecs1
                                                   xs1) })
                                        PVSGenerator.showPVSTop1)))))))) -}
10afb6cedf5b02d209a1a20e190ef61a
  showPVSTop1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.showPVSTop2
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
e6dd178a1c3cf514d02a5b18a2e6c651
  showPVSTop10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("importing TypeDefinitions"#) -}
9bce66d13ec1792fd044d7cbca9a1051
  showPVSTop11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSTop12) -}
eaf078bc1ca90fc4aa14ced87b317e79
  showPVSTop12 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Theorems[(IMPORTING Time) delta_t:posreal] : theory\n\
                 \\n\
                 \begin"#) -}
b0c9f99a82356a4957c0126fa832ac65
  showPVSTop2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSTop3) -}
0507059e0425f26fedcafb6f927c0974
  showPVSTop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \end Theorems"#) -}
610d90a4a92010af3a74230d4056b369
  showPVSTop4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_var : VAR "#) -}
5ba0a4778f72f5afeb3d3829e9865ae8
  showPVSTop5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pre, post, "#) -}
7ec5579b210233555a9ff1ce656e15cd
  showPVSTop6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("s : VAR [tick -> "#) -}
fca1d2009db9499d1415483e3ef3dfa7
  showPVSTop7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSTop8) -}
a4729b4e5bd6c4df087b4c2cc316a856
  showPVSTop8 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("importing Transitions\n\
                 \\timporting ClockTick[delta_t]\n\
                 \\n\
                 \\tt: VAR tick"#) -}
07a464f93b4e192883a41d30803a81d2
  showPVSTop9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSTop10) -}
5afec7eec9c490d226371766db30b888
  showPVSTrans ::
    LexerTypes.PVSPackage
    -> LexerTypes.PackageName
    -> [LexerTypes.PVStransition]
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U,A,U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (nom :: LexerTypes.PackageName)
                   (trans :: [LexerTypes.PVStransition]) ->
                 Data.OldList.intercalate_$spoly_go
                   @ GHC.Types.Char
                   PVSGenerator.showPVSTrans4
                   (Data.OldList.prependToAll
                      @ [GHC.Types.Char]
                      PVSGenerator.showPVSMethods4
                      (GHC.Types.:
                         @ [GHC.Types.Char]
                         (PVSGenerator.showPVSTransition' uni nom GHC.Types.True trans)
                         (GHC.Types.:
                            @ [GHC.Types.Char]
                            (PVSGenerator.showPVSTransition' uni nom GHC.Types.False trans)
                            PVSGenerator.showPVSTrans1)))) -}
2312f8f5cb2cdcf835111cbd80c5615c
  showPVSTrans1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   PVSGenerator.showPVSTrans2
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
472336687f2702cba566a1dd2a4451c6
  showPVSTrans2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSTrans3) -}
1e50b86957af15abe0621b8a4a793bca
  showPVSTrans3 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \end Transitions"#) -}
7ccbb6f69ae65dbb918cc2bd3c1bb7de
  showPVSTrans4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   PVSGenerator.showPVSTrans5) -}
93c44f03a5b14765ca0b9429965f5071
  showPVSTrans5 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Transitions : theory\n\
                 \\n\
                 \begin\n\
                 \\n\
                 \\timporting Methods"#) -}
421dd80ca9fb1643a03e46b91e4b8107
  showPVSTransState ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.ID_Path]
    -> LexerTypes.TransitionTable
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6,
     Strictness: <L,U(U,A,U,U,U,U,U)><L,U><L,U><L,U><S,1*U><L,U> -}
d884ef081dfdaa15658f36d3b6290b16
  showPVSTransStateCluster ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.ID_Path]
    -> LexerTypes.TransitionTable
    -> GHC.Base.String
    -> GHC.Types.Bool
    -> GHC.Base.String
  {- Arity: 8,
     Strictness: <L,U(U,A,U,U,U,U,U)><L,U(A,U)><L,U><L,U><L,U><S,1*U><L,U><L,1*U> -}
960fa08bf8c5c9997e2e571276e0a986
  showPVSTransStates ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.TransitionTable]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6,
     Strictness: <L,U(U,A,U,U,U,U,U)><L,U><L,U><L,U><S,1*U><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (prefix :: GHC.Base.String)
                   (spacer :: GHC.Base.String)
                   (ex :: [LexerTypes.ID_Path])
                   (tables :: [LexerTypes.TransitionTable])
                   (i :: GHC.Base.String) ->
                 case PVSGenerator.killVoids
                        (GHC.Base.map
                           @ LexerTypes.TransitionTable
                           @ [GHC.Types.Char]
                           (\ (a :: LexerTypes.TransitionTable) ->
                            PVSGenerator.showPVSTransState uni prefix spacer ex a i)
                           tables) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           (GHC.CString.unpackAppendCString#
                              PVSGenerator.showPVSTransStates1
                              (GHC.Base.++ @ GHC.Types.Char spacer PVSGenerator.genConsProof13))
                           xs1) }) -}
6ea92db5eccd91a586538cd6b888202e
  showPVSTransStates1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t  "#) -}
101edd4c515356aab62fe00f46db6532
  showPVSTransTree ::
    LexerTypes.PVSPackage
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Base.Maybe LexerTypes.DefaultValue
    -> LexerTypes.PVSType
    -> LexerTypes.SpecificTree
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 8,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><L,U><L,U><L,U><S,1*U><L,U> -}
08d36901356f9a70fbc938d8d7761106
  showPVSTransition' ::
    LexerTypes.PVSPackage
    -> GHC.Base.String
    -> GHC.Types.Bool
    -> [LexerTypes.PVStransition]
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(U,A,U,U,U,U,U)><L,U><L,U><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (nom :: GHC.Base.String)
                   (mode :: GHC.Types.Bool)
                   (transitions :: [LexerTypes.PVStransition]) ->
                 case GHC.Base.map
                        @ [LexerTypes.PVStransition]
                        @ [GHC.Types.Char]
                        (let {
                           w :: LexerTypes.PVSstateDec
                           = case uni of wild { LexerTypes.PVSPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                             case GHC.List.lookup
                                    @ GHC.Base.String
                                    @ [LexerTypes.PVSstate]
                                    GHC.Classes.$fEq[]_$s$fEq[]1
                                    nom
                                    ds5 of wild1 {
                               GHC.Base.Nothing -> PVSGenerator.showPVSTransition'1
                               GHC.Base.Just x -> (nom, x) } }
                         } in
                         \ (w1 :: [LexerTypes.PVStransition]) ->
                         case uni of ww { LexerTypes.PVSPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                         PVSGenerator.$wgenNewTransition
                           ww1
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           w
                           nom
                           mode
                           w1 })
                        (PVSGenerator.groupByArgs uni transitions) of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.generateTabspecs1
                           xs1) }) -}
9c165acea10afe8dbfc8347633a9fc36
  showPVSTransition'1 :: (GHC.Base.String, [LexerTypes.PVSstate])
  {- Strictness: x -}
3733a4c687a5e8e960da7cdcb2b512d4
  showPVSTransitionTable ::
    LexerTypes.PVSPackage
    -> LexerTypes.PVSstateDec
    -> GHC.Base.String
    -> [LexerTypes.ID_Path]
    -> GHC.Types.Bool
    -> LexerTypes.PVStransition
    -> GHC.Base.String
  {- Arity: 6,
     Strictness: <L,U(U,A,U,U,U,U,U)><L,U(A,U)><L,A><L,U><L,1*U><S,1*U(U,A,A,U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PVSstateDec)
                   (w2 :: GHC.Base.String)
                   (w3 :: [LexerTypes.ID_Path])
                   (w4 :: GHC.Types.Bool)
                   (w5 :: LexerTypes.PVStransition) ->
                 case w5 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 PVSGenerator.$wshowPVSTransitionTable w w1 w3 w4 ww1 ww4 }) -}
12b54fa4cb1e1da05495aecd0583127f
  showPVSType ::
    LexerTypes.PVSPackage -> LexerTypes.PVSType -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.PVSType) ->
                 PVSGenerator.$wshowPVSType w1) -}
244e93c2f770bdf06e584156a16e1c4f
  showPVSTypedef ::
    LexerTypes.PVSPackage -> LexerTypes.PVSTypeDef -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U> -}
3c8b620478821cb73ce96b9cd9fd51fa
  showPVSTypedefs ::
    LexerTypes.PVSPackage
    -> LexerTypes.PackageName
    -> [LexerTypes.PVSConstantDec]
    -> [LexerTypes.PVSTypeDef]
    -> [LexerTypes.PVSInstDef]
    -> [LexerTypes.PVSFunction]
    -> GHC.Base.String
  {- Arity: 6,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,A><L,1*U><L,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (6, True, True)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: LexerTypes.PackageName)
                   (w2 :: [LexerTypes.PVSConstantDec])
                   (w3 :: [LexerTypes.PVSTypeDef])
                   (w4 :: [LexerTypes.PVSInstDef])
                   (w5 :: [LexerTypes.PVSFunction]) ->
                 PVSGenerator.$wshowPVSTypedefs w w2 w3 w4 w5) -}
65463a6d37c2c0af34068518ac58602b
  showPVSTypedefs' ::
    LexerTypes.PVSPackage -> [LexerTypes.PVSTypeDef] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,U> -}
9121aa26e708e2a53ce7283553700bf9
  showPVSVectorState ::
    LexerTypes.PVSPackage
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> GHC.Base.String
    -> LexerTypes.PVSType
    -> [(LexerTypes.Expression, LexerTypes.SpecificTree)]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 7,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,U><L,U><L,U><S,1*U><L,U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (nom :: LexerTypes.ID_Path)
                   (prefix :: GHC.Base.String)
                   (spacer :: GHC.Base.String)
                   (typ :: LexerTypes.PVSType)
                   (xs :: [(LexerTypes.Expression, LexerTypes.SpecificTree)])
                   (i :: GHC.Base.String) ->
                 let {
                   lvl568 :: GHC.Base.Maybe LexerTypes.PVSType
                   = GHC.Base.Just @ LexerTypes.PVSType typ
                 } in
                 let {
                   lvl569 :: GHC.Base.String
                   = PVSGenerator.showIDPath
                       uni
                       (GHC.Types.[] @ LexerTypes.LocalVar)
                       (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                       nom
                       i
                 } in
                 let {
                   lvl570 :: (GHC.Base.String, GHC.Base.String) = (prefix, lvl569)
                 } in
                 let {
                   lvl571 :: GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
                   = GHC.Base.Just @ (GHC.Base.String, GHC.Base.String) lvl570
                 } in
                 case GHC.Base.map
                        @ (LexerTypes.Expression, LexerTypes.SpecificTree)
                        @ [GHC.Types.Char]
                        (\ (ds :: (LexerTypes.Expression, LexerTypes.SpecificTree)) ->
                         case ds of wild { (,) y z ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (PVSGenerator.showPVSExpression
                              uni
                              (GHC.Types.[] @ LexerTypes.LocalVar)
                              (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                              lvl568
                              y
                              lvl571
                              i)
                           (GHC.CString.unpackAppendCString#
                              PVSGenerator.getVectorInit'1
                              (PVSGenerator.showPVSTransTree
                                 uni
                                 (PVSGenerator.addVectExptoID nom y)
                                 prefix
                                 spacer
                                 (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                                 typ
                                 z
                                 i)) })
                        xs of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           (GHC.CString.unpackAppendCString#
                              PVSGenerator.showPVSVectorState1
                              (GHC.Base.++ @ GHC.Types.Char spacer PVSGenerator.genConsProof13))
                           xs1) }) -}
53badc8353b737b9d67f6d5af05e2e90
  showPVSVectorState1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \\t\t"#) -}
c0614fbc0dc3c6d456fa819e3d0e0d74
  showPVSvariable ::
    LexerTypes.PVSPackage
    -> LexerTypes.TransitionVar -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><S(LS),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.PVSPackage) (w1 :: LexerTypes.TransitionVar) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 PVSGenerator.$wshowPVSvariable ww1 ww2 }) -}
ff287121c79eb70ce1668c46df1d0f76
  showPVSvariable1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : var "#) -}
239ccc698041cabfbb5342db394a8054
  showProofTheory ::
    LexerTypes.PVSPackage
    -> LexerTypes.PackageName
    -> [LexerTypes.PVStransition]
    -> GHC.Base.Maybe LexerTypes.TSPpackage
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U(U,A,U,A,U,U,U)><L,U><L,1*U><S,1*U> -}
1ac6e8bed5a00c4dd389bcd6b0a9bbb0
  showReplacementsAsEquations ::
    LexerTypes.PVSPackage
    -> [LexerTypes.Replacement] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(U,A,U,A,U,U,U)><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.PVSPackage)
                   (rs :: [LexerTypes.Replacement]) ->
                 case GHC.Base.map
                        @ (LexerTypes.Expression, LexerTypes.Expression)
                        @ [GHC.Types.Char]
                        (\ (ds :: (LexerTypes.Expression, LexerTypes.Expression)) ->
                         case ds of wild { (,) exp1 exp2 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (PVSGenerator.showPVSExpression
                              uni
                              (GHC.Types.[] @ LexerTypes.LocalVar)
                              (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                              PVSGenerator.badType
                              exp1
                              (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                              (GHC.Types.[] @ GHC.Types.Char))
                           (GHC.CString.unpackAppendCString#
                              PVSGenerator.genValueMethodHeader8
                              (PVSGenerator.showPVSExpression
                                 uni
                                 (GHC.Types.[] @ LexerTypes.LocalVar)
                                 (GHC.Base.Nothing @ LexerTypes.DefaultValue)
                                 PVSGenerator.badType
                                 exp2
                                 (GHC.Base.Nothing @ (GHC.Base.String, GHC.Base.String))
                                 (GHC.Types.[] @ GHC.Types.Char))) })
                        rs of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.genConsProof13
                           xs1) }) -}
5657f6d8dd977cb20476c69860a971b3
  showTransitionHierarchy ::
    [LexerTypes.TransitionTable] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ts :: [LexerTypes.TransitionTable])
                   (spacer :: GHC.Base.String) ->
                 case GHC.Base.map
                        @ LexerTypes.TransitionTable
                        @ [GHC.Types.Char]
                        (PVSGenerator.sth spacer)
                        ts of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : x xs1
                   -> Data.OldList.intercalate_$spoly_go
                        @ GHC.Types.Char
                        x
                        (Data.OldList.prependToAll
                           @ [GHC.Types.Char]
                           PVSGenerator.showPVSStateInstance3
                           xs1) }) -}
5c52a89c56d7cefeba1832899b80a89f
  showValueMethod ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSstateDec]
    -> [LexerTypes.PVStransition]
    -> LexerTypes.ValueMethod
    -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,U(U,A,U,A,U,U,U)><L,A><S,1*U><S,1*U(U,U,U,A,U,U,A)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.PVSPackage)
                   (w1 :: [LexerTypes.PVSstateDec])
                   (w2 :: [LexerTypes.PVStransition])
                   (w3 :: LexerTypes.ValueMethod) ->
                 case w3 of ww { (,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PVSGenerator.$wshowValueMethod w w2 ww1 ww2 ww3 ww5 ww6 }) -}
5ddcad6bc22708f3b00ce0317464e82f
  sortDefInsts ::
    [LexerTypes.PVSInstDef]
    -> [LexerTypes.PVSTypeDef] -> [LexerTypes.PVSInstDef]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (xs :: [LexerTypes.PVSInstDef])
                   (ys :: [LexerTypes.PVSTypeDef]) ->
                 GHC.Base.map
                   @ LexerTypes.PVSTypeDef
                   @ (LexerTypes.Name, [(LexerTypes.Name, LexerTypes.Literal)])
                   (\ (x :: LexerTypes.PVSTypeDef) ->
                    let {
                      x1 :: LexerTypes.Name
                      = case x of wild {
                          DEFAULT -> PVSGenerator.sortDefInsts1
                          LexerTypes.PVS_Struct z ds -> z }
                    } in
                    (x1,
                     case GHC.List.lookup
                            @ LexerTypes.Name
                            @ [(LexerTypes.Name, LexerTypes.Literal)]
                            GHC.Classes.$fEq[]_$s$fEq[]1
                            x1
                            xs of wild {
                       GHC.Base.Nothing
                       -> GHC.Types.[] @ (LexerTypes.Name, LexerTypes.Literal)
                       GHC.Base.Just x2 -> x2 }))
                   (PVSGenerator.sortStructs (PVSGenerator.sortDefInsts_go ys))) -}
3b94cacb0417a3502229a0b3fc12589e
  sortDefInsts1 :: LexerTypes.Name
  {- Strictness: x -}
a4918d9d1988ed71e8f31318335d8ba6
  sortDefInsts_go ::
    [LexerTypes.PVSTypeDef] -> [LexerTypes.PVSTypeDef]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d22130ea0b662d3e176b24938b4a05cd
  sortStructs :: [LexerTypes.PVSTypeDef] -> [LexerTypes.PVSTypeDef]
  {- Arity: 1, Strictness: <S,1*U> -}
3076447faa0efde26e5e827c2fd603a0
  splitAtFifoMethod ::
    LexerTypes.ID_Path
    -> (GHC.Base.String, [GHC.Base.String], [GHC.Base.String])
    -> (GHC.Base.String, [GHC.Base.String], [GHC.Base.String])
  {- Arity: 2, Strictness: <S,1*U><S,1*U(A,U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.ID_Path)
                   (w1 :: (GHC.Base.String, [GHC.Base.String], [GHC.Base.String])) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case PVSGenerator.$wsplitAtFifoMethod
                        w
                        ww2
                        ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 (ww5, ww6, ww7) } }) -}
fcf7822b8950af2015e0ea4dce650585
  splitAtFifoMethod' ::
    LexerTypes.ID_Path
    -> (GHC.Base.String, [GHC.Base.String], [GHC.Base.String])
    -> (GHC.Base.String, [GHC.Base.String], [GHC.Base.String])
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.ID_Path)
                   (w1 :: (GHC.Base.String, [GHC.Base.String], [GHC.Base.String])) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case PVSGenerator.$wsplitAtFifoMethod'
                        w
                        ww1
                        ww2
                        ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 (ww5, ww6, ww7) } }) -}
24f1698dc48045d0d20889d694a92b51
  stGlobalLookup ::
    [LexerTypes.PVSTypeDef]
    -> LexerTypes.ID_Path
    -> [LexerTypes.PVSstateDec]
    -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 3, Strictness: <L,U><L,1*U><S,1*U>,
     Unfolding: (\ (tds :: [LexerTypes.PVSTypeDef])
                   (i :: LexerTypes.ID_Path)
                   (sts :: [LexerTypes.PVSstateDec]) ->
                 let {
                   findings :: [LexerTypes.PVSType]
                   = Data.OldList.nubBy
                       @ LexerTypes.PVSType
                       LexerTypes.$fEqPVSType_$c==
                       (Data.Maybe.catMaybes1
                          @ LexerTypes.PVSType
                          (GHC.Base.map
                             @ (LexerTypes.Name, [LexerTypes.PVSstate])
                             @ (GHC.Base.Maybe LexerTypes.PVSType)
                             (let {
                                f :: GHC.Base.String = BSV2PVS.lastID i
                              } in
                              let {
                                f1 :: LexerTypes.ID_Path = LexerTypes.ID f
                              } in
                              \ (x :: (LexerTypes.Name, [LexerTypes.PVSstate])) ->
                              case x of wild { (,) ds1 y -> PVSGenerator.stLookup' tds f1 y })
                             sts))
                 } in
                 case GHC.List.$wlenAcc
                        @ LexerTypes.PVSType
                        findings
                        0# of ww2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 1#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# ww2 1#) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Just
                             @ LexerTypes.PVSType
                             (GHC.List.head @ LexerTypes.PVSType findings)
                        GHC.Types.True -> GHC.Base.Nothing @ LexerTypes.PVSType }
                   GHC.Types.True -> GHC.Base.Nothing @ LexerTypes.PVSType } }) -}
d88f911f69f99582059442d2693d319a
  stLookup ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSTypeDef]
    -> LexerTypes.ID_Path
    -> [LexerTypes.PVSstateDec]
    -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 4,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A)><L,U><L,1*U><S,1*U> -}
4847696abc002fc360b9246fe2510edd
  stLookup' ::
    [LexerTypes.PVSTypeDef]
    -> LexerTypes.ID_Path
    -> [LexerTypes.PVSstate]
    -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
fb5228208230fe1946670f04eb81df5a
  stLookup'' ::
    GHC.Base.String
    -> [LexerTypes.PVSstate] -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
13d0b767e322937dd6fb688cd012cfcc
  stateless ::
    GHC.Base.String -> [LexerTypes.PVSstateDec] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (n :: GHC.Base.String)
                   (xs :: [LexerTypes.PVSstateDec]) ->
                 case GHC.List.lookup
                        @ GHC.Base.String
                        @ [LexerTypes.PVSstate]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        n
                        xs of wild {
                   GHC.Base.Nothing
                   -> case PVSGenerator.genConsTheorems1 n ret_ty GHC.Types.Bool of {}
                   GHC.Base.Just x -> PVSGenerator.stateless' x }) -}
7cebbd41dd3d12d7b5f3b2d3b1edcc9d
  stateless' :: [LexerTypes.PVSstate] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f10716957b69cedf4a8bb7928ae4d910
  sth ::
    GHC.Base.String -> LexerTypes.TransitionTable -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
e8bd02c3590ce1c4e0f1db13a6afdce2
  tailEq ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: LexerTypes.ID_Path) (y :: LexerTypes.ID_Path) ->
                 PVSGenerator.tailEq'
                   (PVSGenerator.invertID x)
                   (PVSGenerator.invertID y)) -}
d0141c7ac9e71cb2c5b8f2b2009c3004
  tailEq' :: [GHC.Base.String] -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
053cad71470f4b367c4429b660fd4c83
  tdLookup ::
    [LexerTypes.PVSTypeDef] -> GHC.Base.String -> LexerTypes.PVSType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
ef1c1e77301b79482e528cc2e11ce62e
  tripleConc ::
    [GHC.Base.String]
    -> [GHC.Base.String] -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U> -}
8dd204bf5e710c5b432beee6bdd55385
  truplePad :: (a, b) -> (a, b, [c])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ c (ds :: (a, b)) ->
                 case ds of wild { (,) x y -> (x, y, GHC.Types.[] @ c) }) -}
54274374a762908dd789602168e87580
  unMaybeList :: [GHC.Base.Maybe a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c2e90479f8d585bfc48db34b89ebb2e7
  wireFilter :: [LexerTypes.PVSstateDec] -> [LexerTypes.PVSstateDec]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a2a3f0c63696ad821879ce56036a4858
  wireLookup ::
    LexerTypes.PVSPackage
    -> [LexerTypes.PVSTypeDef]
    -> [LexerTypes.PVSstateDec]
    -> GHC.Base.Maybe (GHC.Base.String, GHC.Base.String)
    -> LexerTypes.ID_Path
    -> GHC.Base.Maybe LexerTypes.PVSType
  {- Arity: 5,
     Strictness: <L,U(U,A,A,A,A,A,A)><L,U><L,1*U><S,1*U><L,U>,
     Unfolding: (\ (ds :: LexerTypes.PVSPackage)
                   (ds1 :: [LexerTypes.PVSTypeDef])
                   (ds2 :: [LexerTypes.PVSstateDec])
                   (ds3 :: GHC.Base.Maybe (GHC.Base.String, GHC.Base.String))
                   (ds4 :: LexerTypes.ID_Path) ->
                 case ds3 of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ LexerTypes.PVSType
                   GHC.Base.Just ds5
                   -> case ds5 of wild1 { (,) prefix ds6 ->
                      PVSGenerator.stLookup
                        ds
                        ds1
                        (LexerTypes.ID_Submod_Struct
                           (case GHC.Base.eqString
                                   prefix
                                   PVSGenerator.addPreIfMissing1 of wild2 {
                              GHC.Types.False -> prefix
                              GHC.Types.True -> LexerTypes.pvs_packageName ds })
                           ds4)
                        ds2 } }) -}
"SPEC crunchTruples @ Integer @ String @ [(MethodArg, PVSType)]" forall ($dEq :: GHC.Classes.Eq
                                                                                   [(LexerTypes.MethodArg,
                                                                                     LexerTypes.PVSType)])
                                                                        ($dEq1 :: GHC.Classes.Eq
                                                                                    GHC.Base.String)
                                                                        ($dEq2 :: GHC.Classes.Eq
                                                                                    GHC.Integer.Type.Integer)
  PVSGenerator.crunchTruples @ GHC.Integer.Type.Integer
                             @ [GHC.Types.Char]
                             @ [(LexerTypes.MethodArg, LexerTypes.PVSType)]
                             $dEq2
                             $dEq1
                             $dEq
  = PVSGenerator.crunchTruples_$scrunchTruples
"SPEC crunchTuples @ Integer @ String" forall ($dEq :: GHC.Classes.Eq
                                                         GHC.Base.String)
                                              ($dEq1 :: GHC.Classes.Eq GHC.Integer.Type.Integer)
  PVSGenerator.crunchTuples @ GHC.Integer.Type.Integer
                            @ [GHC.Types.Char]
                            $dEq1
                            $dEq
  = PVSGenerator.crunchTuples_$scrunchTuples
"SPEC/PVSGenerator $fEq(,) @ [Char] @ PVSType" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                        LexerTypes.PVSType)
                                                               (v :: GHC.Classes.Eq
                                                                       [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char] @ LexerTypes.PVSType v v1
  = PVSGenerator.$s$fEq(,)
"SPEC/PVSGenerator $fShowMaybe @ BSVType" [orphan] forall (v :: GHC.Show.Show
                                                                  LexerTypes.BSVType)
  GHC.Show.$fShowMaybe @ LexerTypes.BSVType v
  = PVSGenerator.$s$fShow(,,)_$cshowsPrec_$s$fShowMaybe
"SPEC/PVSGenerator $fShowMaybe @ PVSType" [orphan] forall (v :: GHC.Show.Show
                                                                  LexerTypes.PVSType)
  GHC.Show.$fShowMaybe @ LexerTypes.PVSType v
  = PVSGenerator.$s$fShow(,,)_$cshowsPrec_$s$fShowMaybe1
"SPEC/PVSGenerator $fShowMaybe_$cshowList @ BSVType" [orphan] forall ($dShow :: GHC.Show.Show
                                                                                  LexerTypes.BSVType)
  GHC.Show.$fShowMaybe_$cshowList @ LexerTypes.BSVType $dShow
  = PVSGenerator.$s$fShowMaybe_$cshowList
"SPEC/PVSGenerator $fShowMaybe_$cshowList @ PVSType" [orphan] forall ($dShow :: GHC.Show.Show
                                                                                  LexerTypes.PVSType)
  GHC.Show.$fShowMaybe_$cshowList @ LexerTypes.PVSType $dShow
  = PVSGenerator.$s$fShowMaybe_$cshowList1
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

