
==================== FINAL INTERFACE ====================
2022-04-26 13:57:48.354525099 UTC

interface BAPIP-0.1.0.0-IeoLXJJUcqyHz2cFv4cIMD:BSV2PVS 8022
  interface hash: 684aaa43c86538a51f153d9bb9b4037c
  ABI hash: 30286a8fbec138891fd845ec4c231c76
  export-list hash: 878cf3fe588260c7f372a78e427d849f
  orphan hash: 8e15c2efbf85be1778a4d11a3544a4a8
  flag hash: aa1a6078e28560b315026c49539ca393
  sig of: Nothing
  used TH splices: False
  where
exports:
  BSV2PVS.addLVmoduleInfo
  BSV2PVS.addModuleInfo
  BSV2PVS.addPathToMethBody
  BSV2PVS.addStructPrefix
  BSV2PVS.addTagModuleInfo
  BSV2PVS.addressesAllConflicts
  BSV2PVS.addressesAllConflicts'
  BSV2PVS.amalgamateLets
  BSV2PVS.amalgamateRules
  BSV2PVS.amalgamateRules'
  BSV2PVS.andChainExps
  BSV2PVS.ap2string
  BSV2PVS.applyFieldAccesses
  BSV2PVS.applyFieldAccessesXP
  BSV2PVS.applyIDPrefix
  BSV2PVS.applyInterfaceReferences
  BSV2PVS.applyLocalDecs
  BSV2PVS.applyNumbering
  BSV2PVS.applyNumbersToArgs
  BSV2PVS.applyNumbersToArgs'
  BSV2PVS.applyNumbersToArgsCD
  BSV2PVS.applyRepl
  BSV2PVS.applyRepl'
  BSV2PVS.applyRepl''
  BSV2PVS.applyReplacement
  BSV2PVS.applyReplacement'
  BSV2PVS.applyReplacementCase
  BSV2PVS.applyReplacementExp
  BSV2PVS.applyReplacementStmt
  BSV2PVS.applyReplacementUStmt
  BSV2PVS.applyReplacements
  BSV2PVS.applyRootPrefix
  BSV2PVS.applyRootPrefix'
  BSV2PVS.applyRootPrefixStmt
  BSV2PVS.applyRootPrefixStmts
  BSV2PVS.arbitrateRuleSchemes
  BSV2PVS.b2pArgument
  BSV2PVS.b2pConstDecl
  BSV2PVS.b2pFuncs
  BSV2PVS.b2pInstDef
  BSV2PVS.b2pInstDef'
  BSV2PVS.b2pState
  BSV2PVS.b2pStateDecs
  BSV2PVS.b2pType
  BSV2PVS.b2pTypeDef
  BSV2PVS.bsv2pvs
  BSV2PVS.bubbleUpLets
  BSV2PVS.check4imps
  BSV2PVS.cleanup
  BSV2PVS.collateMods
  BSV2PVS.combineLDecs
  BSV2PVS.condenseLDecs
  BSV2PVS.consolidateLDecs
  BSV2PVS.constructDefaultValue
  BSV2PVS.containsLVarDec
  BSV2PVS.convertMethodToRule
  BSV2PVS.convertMethodToRule'
  BSV2PVS.convertModAttsR
  BSV2PVS.convertModAttsS
  BSV2PVS.convertToFunction
  BSV2PVS.convertVectors
  BSV2PVS.crunchLDecs
  BSV2PVS.crushModAttsCases
  BSV2PVS.crushModAttsR
  BSV2PVS.crushModAttsRA
  BSV2PVS.crushModAttsS
  BSV2PVS.crushModAttsSA
  BSV2PVS.cvAct
  BSV2PVS.cvExp
  BSV2PVS.cvID
  BSV2PVS.cvInter
  BSV2PVS.cvMet
  BSV2PVS.cvRul
  BSV2PVS.cvStmt
  BSV2PVS.deReferenceStructure
  BSV2PVS.deStruct
  BSV2PVS.def2exp
  BSV2PVS.dinvExp
  BSV2PVS.dinvFunc
  BSV2PVS.dinvStmt
  BSV2PVS.elemWith
  BSV2PVS.eliminateSingletonSBs
  BSV2PVS.encapsulateUrgs
  BSV2PVS.encapsulateUrgs'
  BSV2PVS.expandSubInterfaces
  BSV2PVS.expressionize
  BSV2PVS.expressionizeSpecificTree
  BSV2PVS.extractConstructor
  BSV2PVS.extractExpression
  BSV2PVS.extractGuardExpression
  BSV2PVS.extractSubmods
  BSV2PVS.fetchGuardByRule
  BSV2PVS.filterActionMethodsByInstance
  BSV2PVS.filterCases
  BSV2PVS.filterDesUrgs
  BSV2PVS.filterDesUrgsForName
  BSV2PVS.filterForModule
  BSV2PVS.filterForWires
  BSV2PVS.finalIDPathEqWithStrings
  BSV2PVS.findAction
  BSV2PVS.findCallStmt
  BSV2PVS.findDescendingUrgency
  BSV2PVS.findInterface
  BSV2PVS.findLVarsWithName
  BSV2PVS.findMatchingStatement
  BSV2PVS.findMethod
  BSV2PVS.findMethod'
  BSV2PVS.findMod
  BSV2PVS.findModbyInst
  BSV2PVS.findPreemptedByList
  BSV2PVS.findPreemptingList
  BSV2PVS.findRule
  BSV2PVS.findStmt
  BSV2PVS.findSubModbyInst
  BSV2PVS.findSubModbyInst'
  BSV2PVS.findSupremum
  BSV2PVS.fixMaybeDefaults
  BSV2PVS.fixedInit
  BSV2PVS.gatherValueMethods
  BSV2PVS.genArgumentVars
  BSV2PVS.genArgumentVars'
  BSV2PVS.genFakeReg
  BSV2PVS.genFakeRegs
  BSV2PVS.genIfExp
  BSV2PVS.genInterfaces
  BSV2PVS.genInterfaces'
  BSV2PVS.genMethVars
  BSV2PVS.genMethVars'
  BSV2PVS.genRuleHeap
  BSV2PVS.genRuleSchedule
  BSV2PVS.genRuleSchedules
  BSV2PVS.genSubmodVars
  BSV2PVS.genTotalTree
  BSV2PVS.genTrans
  BSV2PVS.genTransTable
  BSV2PVS.genTransitionVars
  BSV2PVS.genTransitions
  BSV2PVS.genTreeHeap
  BSV2PVS.genValueMethods
  BSV2PVS.getAPPath
  BSV2PVS.getAllInvokationsOf
  BSV2PVS.getAnteriors
  BSV2PVS.getCaseMatches
  BSV2PVS.getCasesMatching
  BSV2PVS.getConflicts
  BSV2PVS.getDeps
  BSV2PVS.getHeap
  BSV2PVS.getHigherUrgencies
  BSV2PVS.getImplicitConditions
  BSV2PVS.getInstDef
  BSV2PVS.getLVarName
  BSV2PVS.getLetVars
  BSV2PVS.getLets
  BSV2PVS.getLowerUrgencies
  BSV2PVS.getMCalls
  BSV2PVS.getMCallsOverTree
  BSV2PVS.getMDecs
  BSV2PVS.getMatchingCaseStatements
  BSV2PVS.getMethCalls
  BSV2PVS.getMethCallsCases
  BSV2PVS.getMethCallsExp
  BSV2PVS.getMethCallsLVar
  BSV2PVS.getMethNames
  BSV2PVS.getMethNames'
  BSV2PVS.getMethodDependencies
  BSV2PVS.getMod
  BSV2PVS.getModAttsRM
  BSV2PVS.getModAttsS
  BSV2PVS.getModAttsSR
  BSV2PVS.getModByInst
  BSV2PVS.getNonConflicts
  BSV2PVS.getPreempts
  BSV2PVS.getPreempts'
  BSV2PVS.getPriors
  BSV2PVS.getReadsBy
  BSV2PVS.getReadsByCases
  BSV2PVS.getReadsByLVs
  BSV2PVS.getReadsByOverStatements
  BSV2PVS.getRegFiles
  BSV2PVS.getRelevantSchedules
  BSV2PVS.getReplacements
  BSV2PVS.getReturnExp
  BSV2PVS.getStateType
  BSV2PVS.getStatement
  BSV2PVS.getStatementPairs
  BSV2PVS.getStruct
  BSV2PVS.getStructType
  BSV2PVS.getSubinterfaceNames
  BSV2PVS.getTheTopMod
  BSV2PVS.getTopPackageName'
  BSV2PVS.getTotalReturnExp
  BSV2PVS.getTransitionName
  BSV2PVS.getTypeBitSize
  BSV2PVS.getTypeDef
  BSV2PVS.getVectIndex
  BSV2PVS.getVectSize
  BSV2PVS.getVectorWrites
  BSV2PVS.getWireMCalls
  BSV2PVS.getWireNames
  BSV2PVS.getWrites
  BSV2PVS.groupByType
  BSV2PVS.idInit
  BSV2PVS.idTopLevel
  BSV2PVS.idpath2string
  BSV2PVS.idpath2strings
  BSV2PVS.instantiateSubmod
  BSV2PVS.instantiateSubmods
  BSV2PVS.instantiateSubmods'
  BSV2PVS.interfaceLookup
  BSV2PVS.isAboveOrAt
  BSV2PVS.isAction
  BSV2PVS.isClearAnterior
  BSV2PVS.isDWire
  BSV2PVS.isDWire'
  BSV2PVS.isDeqAnterior
  BSV2PVS.isFullySplit
  BSV2PVS.isFullySplitCase
  BSV2PVS.isIDPrefix
  BSV2PVS.isInSubmod
  BSV2PVS.isInWhichSubmod
  BSV2PVS.isLocalDec
  BSV2PVS.isMethod
  BSV2PVS.isNext
  BSV2PVS.isReferencedAnywhere
  BSV2PVS.isReferencedin
  BSV2PVS.isReferencedinExp
  BSV2PVS.isRule
  BSV2PVS.isStatementMatch
  BSV2PVS.isSubMethod
  BSV2PVS.isThisLDec
  BSV2PVS.isWire
  BSV2PVS.isWireAnterior
  BSV2PVS.keepLDec
  BSV2PVS.killDeadRefs
  BSV2PVS.killNonreferencedMethods
  BSV2PVS.killSidewaysReferences
  BSV2PVS.killSupremumReference
  BSV2PVS.killSupremumReferences
  BSV2PVS.killVoids
  BSV2PVS.lDecExpressionize
  BSV2PVS.lDecExpressionize'
  BSV2PVS.lastAP
  BSV2PVS.lastID
  BSV2PVS.letPreproc
  BSV2PVS.lookupBy
  BSV2PVS.lookupInst
  BSV2PVS.lookupInst'
  BSV2PVS.lookupWireTable
  BSV2PVS.lpAct
  BSV2PVS.lpFun
  BSV2PVS.lpInter
  BSV2PVS.lpMet
  BSV2PVS.lpMod
  BSV2PVS.lpRul
  BSV2PVS.lpStmt
  BSV2PVS.lpStmts
  BSV2PVS.mBody2MDec
  BSV2PVS.makeActionPath
  BSV2PVS.makeActionPath'
  BSV2PVS.makeCallSpecificTree
  BSV2PVS.makeCallTreesSpecific
  BSV2PVS.makeSpecificTree
  BSV2PVS.makeStateFromStruct
  BSV2PVS.makeStatesFromStruct
  BSV2PVS.makeTreesSpecific
  BSV2PVS.matchLVs
  BSV2PVS.matchingExp
  BSV2PVS.maybeToEmpty
  BSV2PVS.mergeAP
  BSV2PVS.mergeActionPaths
  BSV2PVS.mergeDeeperLets
  BSV2PVS.mergeIDPaths
  BSV2PVS.mergeLocalVars
  BSV2PVS.methDescUrgPragma
  BSV2PVS.methDescUrgPragmaInverse
  BSV2PVS.migrateAttributes
  BSV2PVS.migrateModAttributes
  BSV2PVS.migrateRuleAttributes
  BSV2PVS.notNothing
  BSV2PVS.nubPath
  BSV2PVS.omniFlatten
  BSV2PVS.onlyInputMethods
  BSV2PVS.orderLDecs
  BSV2PVS.orderLDecs'
  BSV2PVS.orderValueMethods
  BSV2PVS.p2bType
  BSV2PVS.pathEq
  BSV2PVS.pathPrefixEq
  BSV2PVS.pathPrefixReplacement
  BSV2PVS.pathTerminalEq
  BSV2PVS.prependIDPath
  BSV2PVS.preprocMidModInts
  BSV2PVS.propagateMethodCalls
  BSV2PVS.purgeMidModDecs
  BSV2PVS.rcCvLocal
  BSV2PVS.rcDinvLocal
  BSV2PVS.recCvCase
  BSV2PVS.recDinvCase
  BSV2PVS.recRfCase
  BSV2PVS.reclpCase
  BSV2PVS.recordifyBSV
  BSV2PVS.recordifyPVS
  BSV2PVS.removeActionPath
  BSV2PVS.removeAtIndex
  BSV2PVS.removeIRefs
  BSV2PVS.removeLDec
  BSV2PVS.removeLDecReference
  BSV2PVS.removeLDecReferences
  BSV2PVS.removeNonConflicts
  BSV2PVS.removeSelf
  BSV2PVS.removeStructPrefix
  BSV2PVS.removeVoids
  BSV2PVS.replaceLetWith
  BSV2PVS.replaceSkips
  BSV2PVS.resolveMultipleStatements
  BSV2PVS.returnTypeToBSVType
  BSV2PVS.rf2Vec
  BSV2PVS.rfAct
  BSV2PVS.rfExp
  BSV2PVS.rfInterfaces
  BSV2PVS.rfLocal
  BSV2PVS.rfMet
  BSV2PVS.rfMod
  BSV2PVS.rfRul
  BSV2PVS.rfState
  BSV2PVS.rfStmt
  BSV2PVS.rfStructCase
  BSV2PVS.rmInstanceDef
  BSV2PVS.rmLDecs
  BSV2PVS.rmRF
  BSV2PVS.ruleCorrespondance
  BSV2PVS.ruleMerge
  BSV2PVS.rulizeMethods
  BSV2PVS.safeGetMod
  BSV2PVS.samAct
  BSV2PVS.samInt
  BSV2PVS.samMet
  BSV2PVS.samMod
  BSV2PVS.samRul
  BSV2PVS.samStmt
  BSV2PVS.scrubDwireSkips
  BSV2PVS.scrubDwireSkips'
  BSV2PVS.scrubValueMethods
  BSV2PVS.searchFieldsOf
  BSV2PVS.showIDPath
  BSV2PVS.showIDexpr
  BSV2PVS.simplifySpecificTree
  BSV2PVS.simplifySpecificTree'
  BSV2PVS.simplifySpecificTree2
  BSV2PVS.simplifySpecificTree3
  BSV2PVS.simplifySpecificTree4
  BSV2PVS.simplifyVoidCases
  BSV2PVS.simplifyVoids
  BSV2PVS.sortUrgency
  BSV2PVS.sortWires
  BSV2PVS.splitCase
  BSV2PVS.splitFunctions
  BSV2PVS.splitPreprocAction
  BSV2PVS.splitPreprocInterface
  BSV2PVS.splitPreprocMethod
  BSV2PVS.splitPreprocRule
  BSV2PVS.splitStatementBlock
  BSV2PVS.splitStatementBlocks
  BSV2PVS.splitStatementBlocks'
  BSV2PVS.splitStatementPreprocModule
  BSV2PVS.splitStatementPreprocPackage
  BSV2PVS.stepIntoCases
  BSV2PVS.stepIntoStatement
  BSV2PVS.strangeMerge
  BSV2PVS.string2IDPath
  BSV2PVS.stringPathEq
  BSV2PVS.stringPathEq'
  BSV2PVS.strings2idpath
  BSV2PVS.stripIDPrefix
  BSV2PVS.substituteActionMethods
  BSV2PVS.switchToIf
  BSV2PVS.tailID
  BSV2PVS.treefilter
  BSV2PVS.typos
  BSV2PVS.ultimateModuleFinder
  BSV2PVS.unMaybeList
  BSV2PVS.unMaybeWithDefault
  BSV2PVS.utArg2Arg
  BSV2PVS.vectorDecision
  BSV2PVS.vectorNames
  BSV2PVS.vectorNames'
  BSV2PVS.vectorProcess
  BSV2PVS.weirdFold
  BSV2PVS.winnowRuleSchedules
  BSV2PVS.winnowRuleSchedules'
module dependencies: LexerTypes
package dependencies: base-4.10.1.0 extra-1.6.8 ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  LexerTypes ea2837b19066a45c4d666600c2728879
  exports: 24099e1d1a603a4b110bad9ae51c8629
  Action e0098cb1d9678619d5aeab522d9aa7d4
  ActionCall 5f00c2c285beee0562ba8fcf273c888d
  ActionDec 36a81895e6f17b2fffb92c53815c425d
  ActionNameAP ed1d67a670c74523be0781098de637f5
  ActionPath 75d03845d9b5153ed1f38098fefa25af
  ActionValue cfc33ec4ed956b78136d21dfb4a7b1e8
  Add 36538cb76d628c0acd4a4cf71078cdb4
  And e22c6395cd4b23e2790ce49d4543b755
  Argument 93c68e38876debf7336af4b4cf3614b5
  BSVConstantDec b88fa7e6b37f6f00493a89357f127044
  BSVFunction 543f7b92bb23936b640d985e609f9f1f
  BSVInstDef d4c3f0df3b23e82596dcee695e4732f4
  BSVMacro 150b9413fc0ca585963b402f9a2b8cb8
  BSVModuleDec 074780e36a5923bf79c4d10eacc7b193
  BSVModuleDec 6a9e148802acadaa54114400a09553a4
  BSVPackage 3a2e6daacdb9fafe12eb62fa2818e2c8
  BSVPackage dca7bfb1a37746d89b662b651361e667
  BSVType 4a6fa266ef9464fb93f2d34d394bedde
  BSVTypeDef 8e4fa46f3b3e0dfb841487fd74787a36
  BSV_Bit b7bdba10c8eb1b1e91e90f40be229e2c
  BSV_Bool 01eddf3beaa8c7925d8ccb76e15f4fc4
  BSV_Custom 3e037feb3dae439d4704b3fad55dd49b
  BSV_Enumeration bedc0fcd727049aa2e0541fbd11f84b4
  BSV_Field 63031b90c7604d4fb2a78460ad181c92
  BSV_Fifo 03f2d7df610a9ffc10dbe487dc910e79
  BSV_Int 4204bd688ea42600a7a56fbf7a805572
  BSV_Maybe 1426229b0098b4a14cf6baa02436b871
  BSV_Real 74fd7cf943d91608036060a198b78300
  BSV_Reg bebd524f4e8ace342acec9513d4ad26a
  BSV_RegFile 6a666ae32d2fb0eb369a76cf007b7f25
  BSV_Struct e68a86d94ad261d6d0d40e01c97f4031
  BSV_SubModuleDec 4cfcb5f0ea07b81fd12b2088e2957c5e
  BSV_Synonym dcaabe3758db3247f01951246c828702
  BSV_UInt 188b355edf0c4b3f1e8d57c4aeebe56f
  BSV_Vector 3ee79272024b25ce68888eea8399c371
  BSVstateDec 8c52b7703dbf130a1d71c377ab4031f7
  Binding a73de62264e667fab5ce9150342bfbb0
  BitConcat ce09575274ede88737a0901dbf5bea16
  BitSelect 679dead99df4296b229e1d1889f748e3
  BitSelectRange 589edace8d5eec8af5245f487ee43fc4
  BitwiseAND 7e507419ece991ad7ce0f2956c9aa213
  BitwiseOR 302153d3c58ce21102a7455a65b88105
  BitwiseXOR c9cc2432ec74bae8bc7895c9ccd99e77
  Case cadc4dd88ae52d1939dfeb3e511aff3a
  CasesOf bdd2bd759473940f256fcd9ae669ae8c
  DWire 760a4217288639166f942799447c28b7
  DeclAssign 441df763bd5b6dee0b7aca2740e5a2b2
  Descending_Urgency c3d7b3e2fe1741bd5b0c7b40a1155a91
  Divide 4e0e22b926cf6cc14d39a04fc286fe36
  Equals 61c8e1ea5b6b779f6da6a09d78deda00
  ExpCase 6b58178d3226f5dcfa379df74cd7f6b5
  Exp_FunctionCall e2d5fa7c978122cee21bc7c2633d698e
  Exp_If 8f8ce8dc133821fef9f9cd8882f50996
  Exp_MethodCall e0fa569420d352ff8a5c69ead86bec0f
  Explicit fff7810158b75b46dc5a65736647c0a3
  Expression 6b58178d3226f5dcfa379df74cd7f6b5
  FieldAccess c2642295d71416d9cf7ea37b886f9d15
  Fire_When_Enabled af1d9e688b6c93667f1e1dd76470ee52
  ForLoop 9f373b5c95392dade3a453dbcd756f31
  FromMaybe ba67a205c79eed67f02da6f0a827eec3
  Greater 6b9689f45536195da18383e5326b97a8
  GreaterEquals 6d9a338a7609c353aeb3bdce17362ec6
  Guard 6b58178d3226f5dcfa379df74cd7f6b5
  HexFile d5583e90e36cd3f094dbc709feddd25d
  ID 162ab617d5709f209b382d729b114647
  ID_Path 6b58178d3226f5dcfa379df74cd7f6b5
  ID_Submod_Struct 463de23e5c7996a7d7e8c379f21535c2
  ID_Vect ac4504a9362ebe24ddb26ea1baec8978
  Identifier f34a421e3991b38924384ea37d474049
  If 32fa666fb38bd1ab23f33b637083b1ac
  InterfaceDec 1499c0615b3c44798666b03c4c00ca8f
  InterfaceRef e3860765508607c28be1ec3e51cc1625
  Invalid ed1ca468e26ed28115951dd040fb4279
  IsValid 86cdbf08e2e7a3d893fc5ab943e94310
  LShift a6a4b281298d1b8a75f764462c15d6a1
  Less d59e317442af542f318ae1618692d2bb
  LessEquals 0253bd2afe07783f24a5580881609c67
  LitBool f9036459d5bfa3180b25936630b48534
  LitStructConstructor a91bdcbd8e359522c690b7666c6b98b4
  Literal 337aee2c7f9cd9dd951f930c9b9dbe73
  Literal 6b58178d3226f5dcfa379df74cd7f6b5
  LocalDec dc53dbce61592dc7be3f1947b4964070
  LocalVar 6b58178d3226f5dcfa379df74cd7f6b5
  MaybeContainer 672d36bd151398507ab3b4acf991b824
  MaybeIf 34bc4228cd97532add7324e8063547f0
  MaybeTag 6b58178d3226f5dcfa379df74cd7f6b5
  MaybeValue b4406f5978a10fdfe189d8f0d74eb951
  MethodArg 3690921074a8037a0b7e5c576e714940
  MethodBody b57efcbb684bd3a4b73bc89a60f4ae60
  MethodCall 6bfa118d40a28636a7c1093e08fceffa
  MethodDec d322641a77af09ae68c30d0c7b8ae44a
  MethodNameAP 90170f9dfb8fbb02ecf113b23a14484d
  MidModInterfaceDec 7ae7083e06da3778a95f7bf117e81599
  Mod_Conflict_Free d4986d564e3e3b31465e372f7bf1d438
  Mod_Execution_Order 9046f61fa63b7900b715414af9787383
  Mod_Mutually_Exclusive 1bf8807f93263dd15548a7cc35984646
  Mod_Preempts d00b425747f1b6bc6c7e35c1766ce7a9
  ModuleAttribute 38c8cfc922a8b6609d6630c27049fe7f
  Modulo ef51c13e1735d14b66d320257e21a593
  Multiply 2e1955b341ad5724899f6d2460f61d10
  Name 7c6cc0f4ece946a46df101a52b2e2642
  Negative 9890405dd1a0c5764d6155433ae9484e
  NoSplit c647b54d6c1e7d413d15b3a44d2dc445
  No_Implicit_Conditions 5d4fe9142fa6b81ef9c295f6475e45aa
  Not 22d1103f357094a67193828970d4b051
  NotEquals ca898c161ed932983a471d3d692c86bf
  Or 29cc9a489f4941fb8f760730dd0dff52
  PMatchIf 52813831d49d9ee564934467e47528ea
  PVSArgument 7d8a7e836795cb9d22f15bbe05b0f092
  PVSConstantDec 2f2405ef76e2fdf81a05bdc6a4655ac9
  PVSFunction bd8391fe6aa4b9aeeace864d9f179cb4
  PVSInstDef 4cd52ce8483a87744e359b1843bfd9d3
  PVSPackage dc3bf8ecc9848020fdad1884e49329c4
  PVSPackage 2ebe3fda021fa922603a337269985adf
  PVSType 5293579e9cbbf6986dcf46fee97434cb
  PVSTypeDef 263d5987ddec79fadf35563de5be9f0c
  PVS_Bit 22acc7100431b38432c9c3c07d2b2a41
  PVS_Bool 9e0621e80245a1f11c51a0ee4357c949
  PVS_Custom 3b7a0ad00510c97e677113fc5dcc2393
  PVS_DWire 828e6ea5d731fd0010e348a66b7108a2
  PVS_Enumeration 4c8f7f14ccc0ee1299e205bd31c7048b
  PVS_Fifo 6d6da14962836ca13ef4dabaa82408b6
  PVS_Int 00b5ec9b246ed8c7086e269060a6072e
  PVS_Maybe 3847bfcf37f5af07138f72f8f928732b
  PVS_Real 92e906bfc31d0cbaed8d7427f91679ca
  PVS_Reg fe7cd9f9365abb666cc495e6b8106326
  PVS_Struct 3e464b1a1f5a13bed37a0a89c99f7fb7
  PVS_SubModuleDec dbe1e226acd2b6511ad77f6aa920087a
  PVS_Synonym 8a9d46d2cacf21d3788db9f5d6b38bde
  PVS_UInt db0d5cc35fbfe6395496e1c360f6dd95
  PVS_Vector 28aa2de41cd2f5bbe33ceea566b39929
  PVSstate 27e7de08b1523caab97202618cf8bce6
  PVSstateDec 10d0986ecfd076e695b49c5e94e87c77
  PVStransition 74cf04055f6193fb2cf856c4b138a104
  PackageName 6454d16386f2f0fea028840e593a69c1
  RHeap 6529ee399a877868b88cf1e330e2b3dd
  RPFlag fd68b5813118d833864d10cc9b8844fd
  RShift 6a6e1d65a10e1f1cbb73413d5cb25175
  RegFileLoad 1e8ecec511b5c077f2965cc0e0b0f5f2
  Replacement e8e0dabb470ed6767d6eeba2a104c650
  Return 469e4383a60a510108937994587a9aec
  ReturnType edbdd3627cba53012a786daa322eb050
  Rul_Conflict_Free aefa06c95a2e66037eba4b353858ddef
  Rul_Descending_Urgency 1fa42a52e33757f1d4226f5693925bcf
  Rul_Doc 6b9522f4dc9be3f4faef9836a72687f6
  Rul_Execution_Order 85efe91879f19663eb0bf2a0b5cf7e04
  Rul_Mutually_Exclusive f7d96a49ebc106db423d281b616d874d
  Rul_Preempts 4fc6ba0be2c16875a8ea7da3f039897c
  RuleAttribute 2bdb464ecda2ca4646f2cafd65165658
  RuleDec bdce4999eb06aa1f9b7a13dd2d78793f
  RuleHeap 269d6e12c984e7a4de1bdae43d808778
  RuleNameAP bb64fa397fcce0c5cadaec7600c325d2
  RuleNode ddeb31f34917776cd2fdbfa14f75aa2d
  RuleNode 08b3b374ca9923e08b3d8f295257edb0
  RuleSchedule ef3e60e95e7da304161fd95cc062d833
  RuleSchedule 7b3adb9e814c886706bb5c400eeb330c
  Skip c4d4e47795a29b6972a451ca43a86c1a
  SpecEx 26637e3bd58c473091b6566a0fbdc641
  SpecLeaf e32e60e0336d77e475456485973057be
  SpecStem f6a722964cf9c3795146efc8eea95e68
  SpecificTree 6a668caddf4b8e9677117e2028b195e2
  Split df8f6e79a78ac0faed13b537105b8d25
  Sta_Conflict_Free bcfdff681b96a2ec3702e425d2fcc235
  Sta_Descending_Urgency 160b16b9fa3b5ccdc3b013f529d49726
  Sta_Doc fd17a69e5644ba2644feebad619ea0e1
  Sta_Execution_Order 2a55531ba0fb345b36b47a66fb7a2e78
  Sta_Mutually_Exclusive a203853c00f71328fd3f6dd705be4bff
  Sta_Preempts 85ea85b7bede5725034fe50e49268bb1
  Statement cadc4dd88ae52d1939dfeb3e511aff3a
  StatementAttribute 5526f020d66208751c85b3afb1bd43de
  StatementBlock e0394f1e71d4f57b59055b8757ecbfbf
  StructCluster d1d9a321e54a65adb8a23ae2be47bd44
  StructReturn 59bd8795163c7bd7010f2f7568e5d5cc
  SubmoduleNameAP 6805540e6cf984bb60a992b485593520
  Subtract 8f6065598203e3e8d21db427badb1bf6
  Switch e42c16c106ee6bcb283f690c7a3d4cb9
  THeap 7b02b0f6ef8da2229d70ae397596f85c
  Tagged 0103ea8b59c5429e51d36d50c470f390
  TotalLeaf 16dd25f76e3a36db8072fa013452729f
  TotalStem 24c5c08de3354ae1eb494c7e3dee7222
  TotalTree f37fc1f7f628e396311833bcccc3658f
  TransDWire d4795ee85497c0ff1208c1fea07f1eae
  TransFIFO 54f039d20fa6c537ed219c894a3c864f
  TransMod b2295ed615c13bc8edb9b75da1874a04
  TransReg 66e3d25125f674da894bdf36a2c2da3d
  TransStruct 751ab6f0525a7c9d2168f4a413caf775
  TransVect 8cad7a999fbf903557bc2dbec666d39e
  TransitionTable 321d4bb033873a046e1650695f529c57
  TransitionVar 853751140af520152685e71ddf0e992f
  TreeHeap 48110a9cdd317f7d31f7d5382813e9a4
  UAssign 0195556360eda39554390b675e822912
  UStatement 4d08ca0e73729c67fbd812bf662e0e37
  UTArgs 8a1cde95035b2dfb2cead8c0bc76f244
  Valid a42292174e949ee84846f4697e0a0816
  Value 32de6853cb64c8109f36358d63ce8808
  ValueMethod 162bf9d0bb1089190de24d16b16617f0
  ValueMethodCall 6e178be71a4412cc4bda1ba94fdf869f
  Void cda459ef3d6a19157711e69f6b75291b
  Write 9fdf095920f28fc4f1944f4c4fbe9211
  actionMethodsCalled 7b3adb9e814c886706bb5c400eeb330c
  actions 6a9e148802acadaa54114400a09553a4
  attributes 6a9e148802acadaa54114400a09553a4
  bsv_constants dca7bfb1a37746d89b662b651361e667
  bsv_functions dca7bfb1a37746d89b662b651361e667
  bsv_instDefs dca7bfb1a37746d89b662b651361e667
  bsv_macros dca7bfb1a37746d89b662b651361e667
  bsv_modules dca7bfb1a37746d89b662b651361e667
  bsv_packageName dca7bfb1a37746d89b662b651361e667
  bsv_typedefs dca7bfb1a37746d89b662b651361e667
  conflictsWith 7b3adb9e814c886706bb5c400eeb330c
  dWireReads 7b3adb9e814c886706bb5c400eeb330c
  dWireWrites 7b3adb9e814c886706bb5c400eeb330c
  executesAfter 7b3adb9e814c886706bb5c400eeb330c
  executesBefore 7b3adb9e814c886706bb5c400eeb330c
  fifoClears 7b3adb9e814c886706bb5c400eeb330c
  fifoDeqs 7b3adb9e814c886706bb5c400eeb330c
  fifoEnqs 7b3adb9e814c886706bb5c400eeb330c
  fifoFirsts 7b3adb9e814c886706bb5c400eeb330c
  hexFiles dca7bfb1a37746d89b662b651361e667
  implicitConditions 7b3adb9e814c886706bb5c400eeb330c
  imports dca7bfb1a37746d89b662b651361e667
  including dca7bfb1a37746d89b662b651361e667
  instanceName 6a9e148802acadaa54114400a09553a4
  instances 6a9e148802acadaa54114400a09553a4
  interfaceDecs 6a9e148802acadaa54114400a09553a4
  interfaceName 6a9e148802acadaa54114400a09553a4
  interfaces dca7bfb1a37746d89b662b651361e667
  isPreemptedBy 7b3adb9e814c886706bb5c400eeb330c
  mName 6a9e148802acadaa54114400a09553a4
  methods 6a9e148802acadaa54114400a09553a4
  noConflictsWith 7b3adb9e814c886706bb5c400eeb330c
  preempts 7b3adb9e814c886706bb5c400eeb330c
  pvs_constants 2ebe3fda021fa922603a337269985adf
  pvs_functions 2ebe3fda021fa922603a337269985adf
  pvs_instantiations 2ebe3fda021fa922603a337269985adf
  pvs_packageName 2ebe3fda021fa922603a337269985adf
  pvs_state 2ebe3fda021fa922603a337269985adf
  pvs_typedefs 2ebe3fda021fa922603a337269985adf
  rGuard 7b3adb9e814c886706bb5c400eeb330c
  rName 7b3adb9e814c886706bb5c400eeb330c
  rStatements 7b3adb9e814c886706bb5c400eeb330c
  rnName 08b3b374ca9923e08b3d8f295257edb0
  rnPreempts 08b3b374ca9923e08b3d8f295257edb0
  rules 6a9e148802acadaa54114400a09553a4
  state 6a9e148802acadaa54114400a09553a4
  transitions 2ebe3fda021fa922603a337269985adf
  writesTo 7b3adb9e814c886706bb5c400eeb330c
import  -/  base-4.10.1.0:Data.Bits e0790a03e1e51e2d053ee3f563937f85
import  -/  base-4.10.1.0:Data.Either d7dae5d9bf298dee616e465c14b5d60e
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:Data.List 4ab7fa2a1b87502b23af891a384f0506
import  -/  base-4.10.1.0:Data.Maybe 07738c5485acb328136bb15596f8b845
import  -/  base-4.10.1.0:Data.OldList 555420b092ca8cf0a8f9666bc0e07dcf
import  -/  base-4.10.1.0:Data.Tuple 8fa1305aa5032ea35e2a54fa5f1e78f9
import  -/  base-4.10.1.0:Debug.Trace d6b92a67d41f66511d3d35c0713fec79
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Err 514b3a24b22e9d7d731c2d0d02d10842
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:GHC.Show 0a8ce2b5e533d1c2cfb7954e6736be45
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  extra-1.6.8:Data.List.Extra d9fcdf87b33e152395b478ba3262da0c
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
import  -/  integer-gmp-1.0.1.0:GHC.Integer.Type 5fa81108482c33b62ec3ac7464eece96
422fbde340753aad907a67a0e96d4c04
  $s$fEq(,) ::
    GHC.Classes.Eq
      ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe LexerTypes.BSVType)
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     BSV2PVS.$s$fEq(,)_$s$fEqMaybe)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe LexerTypes.BSVType)
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     BSV2PVS.$s$fEq(,)_$s$fEqMaybe) -}
c08e53a65adeeb0bc24a9330c95a2d8c
  $s$fEq(,)_$s$fEqMaybe ::
    GHC.Classes.Eq (GHC.Base.Maybe LexerTypes.BSVType)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe LexerTypes.BSVType)
                  (\ (ds :: GHC.Base.Maybe LexerTypes.BSVType)
                     (ds1 :: GHC.Base.Maybe LexerTypes.BSVType) ->
                   case ds of wild {
                     GHC.Base.Nothing
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just ipv -> GHC.Types.False }
                     GHC.Base.Just a1
                     -> case ds1 of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just b1 -> LexerTypes.$fEqBSVType_$c== a1 b1 } })
                  (\ (a1 :: GHC.Base.Maybe LexerTypes.BSVType)
                     (b :: GHC.Base.Maybe LexerTypes.BSVType) ->
                   case a1 of wild {
                     GHC.Base.Nothing
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.False
                          GHC.Base.Just ipv -> GHC.Types.True }
                     GHC.Base.Just a2
                     -> case b of wild1 {
                          GHC.Base.Nothing -> GHC.Types.True
                          GHC.Base.Just b1
                          -> case LexerTypes.$fEqBSVType_$c== a2 b1 of wild2 {
                               GHC.Types.False -> GHC.Types.True
                               GHC.Types.True -> GHC.Types.False } } }) -}
e00d4752ec57a4a7258c5e2131599f01
  $s$fEqMaybe_$c== ::
    GHC.Base.Maybe LexerTypes.BSVType
    -> GHC.Base.Maybe LexerTypes.BSVType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe LexerTypes.BSVType)
                   (ds1 :: GHC.Base.Maybe LexerTypes.BSVType) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> LexerTypes.$fEqBSVType_$c== a1 b1 } }) -}
8bc23e0f00064203648a54e9f4a19d74
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   BSV2PVS.$trModule3
                   BSV2PVS.$trModule1) -}
8d0a8473560c2b1ce6337b1002fa9f6a
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS BSV2PVS.$trModule2) -}
921b9f553d093abb7c7d4c35f3fc532f
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BSV2PVS"#) -}
1ce378fad590c6753f69cb2a37719764
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS BSV2PVS.$trModule4) -}
fabd7a47c01d7eae3703972176882833
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("BAPIP-0.1.0.0-IeoLXJJUcqyHz2cFv4cIMD"#) -}
283f574b9e0bd3132cd07637013e5b3c
  $waddModuleInfo ::
    [GHC.Base.String] -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
1cddbaa826852cc7977f5d7e80685896
  $wamalgamateLets ::
    [LexerTypes.Statement]
    -> [LexerTypes.Statement]
    -> (# [LexerTypes.LocalVar], LexerTypes.Statement,
          [LexerTypes.StatementAttribute] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.Statement])
                   (w1 :: [LexerTypes.Statement]) ->
                 let {
                   lets :: [LexerTypes.Statement]
                   = case BSV2PVS.$wmergeDeeperLets w w1 w1 of ww { (#,#) ww1 ww2 ->
                     ww1 }
                 } in
                 (# BSV2PVS.amalgamateLets_go1 lets,
                    case BSV2PVS.$wmergeDeeperLets w w1 w1 of ww { (#,#) ww1 ww2 ->
                    case GHC.List.$wlenAcc @ LexerTypes.Statement ww2 0# of ww3 {
                      DEFAULT
                      -> LexerTypes.StatementBlock
                           (GHC.Base.++
                              @ LexerTypes.Statement
                              ww2
                              (GHC.Base.map
                                 @ LexerTypes.Statement
                                 @ LexerTypes.Statement
                                 BSV2PVS.amalgamateLets1
                                 lets))
                      1# -> GHC.List.head @ LexerTypes.Statement ww2 } },
                    BSV2PVS.amalgamateLets_go lets #)) -}
6646bc0e6b9b5645e4caffe740636697
  $wamalgamateRules ::
    [LexerTypes.RuleSchedule]
    -> [LexerTypes.RuleSchedule]
    -> [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
    -> (# [LexerTypes.RuleSchedule],
          [([LexerTypes.ActionPath], LexerTypes.ActionPath)] #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0] -}
cf585d8da44500190f36140aa0cc5e7c
  $wapplyNumbering ::
    GHC.Types.Int
    -> LexerTypes.MethodName
    -> LexerTypes.ReturnType
    -> LexerTypes.UTArgs
    -> LexerTypes.Guard
    -> [LexerTypes.Statement]
    -> [LexerTypes.MethodBodyAttribute]
    -> (# LexerTypes.MethodName, LexerTypes.ReturnType,
          LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
          [LexerTypes.MethodBodyAttribute] #)
  {- Arity: 7,
     Strictness: <L,1*U(U)><L,U><L,U><L,U><L,U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int)
                   (ww1 :: LexerTypes.MethodName)
                   (ww2 :: LexerTypes.ReturnType)
                   (ww3 :: LexerTypes.UTArgs)
                   (ww4 :: LexerTypes.Guard)
                   (ww5 :: [LexerTypes.Statement])
                   (ww6 :: [LexerTypes.MethodBodyAttribute]) ->
                 let {
                   newArgs :: [([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)]
                   = let {
                       lvl564 :: [GHC.Types.Char]
                       = GHC.CString.unpackAppendCString#
                           BSV2PVS.applyNumbering2
                           (case ww of ww7 { GHC.Types.I# ww8 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   ww8
                                   (GHC.Types.[] @ GHC.Types.Char) of ww9 { (#,#) ww10 ww11 ->
                            GHC.Types.: @ GHC.Types.Char ww10 ww11 } })
                     } in
                     GHC.Base.map
                       @ ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)
                       @ ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)
                       (\ (ds :: ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)) ->
                        case ds of wild { (,) afst asnd ->
                        (GHC.Base.++ @ GHC.Types.Char afst lvl564, asnd) })
                       ww3
                 } in
                 (# ww1, ww2, newArgs, ww4,
                    let {
                      reps :: [(LexerTypes.Expression, LexerTypes.Expression)]
                      = BSV2PVS.applyNumbering_go1
                          ww3
                          (GHC.Base.map
                             @ ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)
                             @ LexerTypes.Expression
                             BSV2PVS.applyNumbering1
                             newArgs)
                    } in
                    GHC.Base.map
                      @ LexerTypes.Statement
                      @ LexerTypes.Statement
                      (\ (z :: LexerTypes.Statement) -> BSV2PVS.applyNumbering_go reps z)
                      ww5,
                    ww6 #)) -}
9b06c6c91b54dc883d70b03307d482f9
  $wapplyReplacementExp ::
    LexerTypes.Expression
    -> LexerTypes.Expression
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 3, Strictness: <S,U><L,U><S,1*U>, Inline: [0] -}
20e379d281a0755cbbd54ed95e942e3c
  $wbsv2pvs ::
    LexerTypes.BSVPackage
    -> GHC.Base.Maybe GHC.Base.String
    -> [[LexerTypes.ID_Path]]
    -> (# LexerTypes.PackageName, [LexerTypes.PVSConstantDec],
          [LexerTypes.PVSTypeDef], [LexerTypes.PVStransition],
          [LexerTypes.PVSstateDec], [LexerTypes.PVSInstDef],
          [LexerTypes.PVSFunction] #)
  {- Arity: 3,
     Strictness: <L,U(1*U,A,A,U,1*U,U,U,U,1*U,A,A)><S,1*U><L,U>,
     Inline: [0] -}
3273e42b9593cc9c248af3b86cc26b27
  $wcombineLDecs ::
    LexerTypes.ID_Path
    -> Data.Either.Either
         (GHC.Base.Maybe LexerTypes.BSVType)
         (GHC.Base.Maybe LexerTypes.PVSType)
    -> LexerTypes.Expression
    -> [LexerTypes.Statement]
    -> (# LexerTypes.ID_Path,
          Data.Either.Either
            (GHC.Base.Maybe LexerTypes.BSVType)
            (GHC.Base.Maybe LexerTypes.PVSType),
          LexerTypes.Expression #)
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0] -}
be1e8498e2c92fafa5d8a6795e259d88
  $wcondenseLDecs ::
    LexerTypes.ID_Path
    -> Data.Either.Either
         (GHC.Base.Maybe LexerTypes.BSVType)
         (GHC.Base.Maybe LexerTypes.PVSType)
    -> LexerTypes.Expression
    -> [LexerTypes.Statement]
    -> (# LexerTypes.ID_Path,
          Data.Either.Either
            (GHC.Base.Maybe LexerTypes.BSVType)
            (GHC.Base.Maybe LexerTypes.PVSType),
          LexerTypes.Expression #)
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0] -}
472f4e74ec850f75a739a59852da3f60
  $wconvertToFunction ::
    LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> LexerTypes.MethodName
    -> LexerTypes.ReturnType
    -> LexerTypes.Guard
    -> [LexerTypes.Statement]
    -> (# LexerTypes.MethodName, LexerTypes.ModuleName,
          GHC.Base.String, LexerTypes.Path, LexerTypes.PVSType,
          LexerTypes.Expression, [LexerTypes.ID_Path] #)
  {- Arity: 7,
     Strictness: <L,U(U,U,U,U,A,A,1*U,U,U,U)><L,U><L,U><L,U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: GHC.Base.String)
                   (w2 :: [GHC.Base.String])
                   (ww :: LexerTypes.MethodName)
                   (ww1 :: LexerTypes.ReturnType)
                   (ww2 :: LexerTypes.Guard)
                   (ww3 :: [LexerTypes.Statement]) ->
                 case ww1 of wild {
                   DEFAULT
                   -> case BSV2PVS.convertToFunction6
                      ret_ty (# LexerTypes.MethodName, LexerTypes.ModuleName,
                                GHC.Base.String, LexerTypes.Path, LexerTypes.PVSType,
                                LexerTypes.Expression, [LexerTypes.ID_Path] #)
                      of {}
                   LexerTypes.Value typ
                   -> let {
                        exp :: LexerTypes.Expression
                        = case BSV2PVS.getReturnExp ww3 of wild1 {
                            GHC.Base.Nothing -> BSV2PVS.convertToFunction5
                            GHC.Base.Just x -> x }
                      } in
                      (# ww, LexerTypes.mName w, w1, w2, BSV2PVS.b2pType typ,
                         BSV2PVS.applyRootPrefix
                           (case w of wild1 { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                            BSV2PVS.getWireNames ds7 })
                           BSV2PVS.convertToFunction2
                           exp,
                         GHC.Base.++
                           @ LexerTypes.ID_Path
                           (BSV2PVS.getReadsBy
                              w
                              BSV2PVS.convertToFunction1
                              (GHC.Types.[] @ GHC.Base.String)
                              exp)
                           (BSV2PVS.getReadsBy
                              w
                              BSV2PVS.convertToFunction1
                              (GHC.Types.[] @ GHC.Base.String)
                              ww2) #) }) -}
99fedf85375989085c016de5f78d6029
  $wconvertVectors ::
    LexerTypes.BSVModuleDec
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,1*U,1*U,1*U,1*U,U,1*U,1*U,1*U)>,
     Inline: [0] -}
7fe25cb38df8ac7fa5494b981047dd33
  $wdinvExp :: LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
677024140bee879e9c783bbb5db7d817
  $wdinvStmt :: LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
7d3f0dfc3f282280e7e03ea57fa23516
  $welemWith ::
    a -> [a] -> (a -> a -> GHC.Types.Bool) -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,C(C1(U))>,
     Inline: [0] -}
78a9a43c8c725196247b2f2c04d7b7fa
  $wencapsulateUrgs ::
    [GHC.Base.String]
    -> [([GHC.Base.String], [GHC.Base.String])]
    -> (# [LexerTypes.ActionPath], [LexerTypes.ActionPath] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Base.String])
                   (w1 :: [([GHC.Base.String], [GHC.Base.String])]) ->
                 (# GHC.Base.map
                      @ [GHC.Types.Char]
                      @ LexerTypes.ActionPath
                      (\ (q :: GHC.Base.String) ->
                       BSV2PVS.makeActionPath
                         (GHC.Base.++
                            @ [GHC.Types.Char]
                            w
                            (GHC.Types.:
                               @ GHC.Base.String
                               q
                               (GHC.Types.[] @ GHC.Base.String))))
                      (Data.OldList.nubBy
                         @ GHC.Base.String
                         GHC.Base.eqString
                         (BSV2PVS.encapsulateUrgs_go1 w1)),
                    GHC.Base.map
                      @ [GHC.Types.Char]
                      @ LexerTypes.ActionPath
                      (\ (q :: GHC.Base.String) ->
                       BSV2PVS.makeActionPath
                         (GHC.Base.++
                            @ [GHC.Types.Char]
                            w
                            (GHC.Types.:
                               @ GHC.Base.String
                               q
                               (GHC.Types.[] @ GHC.Base.String))))
                      (Data.OldList.nubBy
                         @ GHC.Base.String
                         GHC.Base.eqString
                         (BSV2PVS.encapsulateUrgs_go w1)) #)) -}
08e7d742ea7e2d92aca8f2fabf8440e6
  $wextractGuardExpression ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.Expression
    -> [LexerTypes.ActionPath]
    -> LexerTypes.Expression
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,A,A,A,A,U,A,U,U)><L,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (ww :: LexerTypes.Expression)
                   (ww1 :: [LexerTypes.ActionPath]) ->
                 let {
                   baseGuard :: LexerTypes.Expression
                   = BSV2PVS.applyRootPrefix
                       (GHC.Types.[] @ LexerTypes.MethodArg)
                       (GHC.Types.:
                          @ [GHC.Types.Char]
                          (case w1 of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                           GHC.Base.++ @ GHC.Types.Char ds1 BSV2PVS.extractGuardExpression1 })
                          (GHC.Types.[] @ [GHC.Types.Char]))
                       ww
                 } in
                 case ww1 of wild {
                   [] -> baseGuard
                   : ds1 ds2
                   -> LexerTypes.And
                        baseGuard
                        (LexerTypes.Not
                           (BSV2PVS.applyRootPrefix
                              (GHC.Types.[] @ LexerTypes.MethodArg)
                              (GHC.Types.:
                                 @ [GHC.Types.Char]
                                 (case w1 of wild1 { LexerTypes.BSVModuleDec ds4 ds5 ds3 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ->
                                  GHC.Base.++
                                    @ GHC.Types.Char
                                    ds4
                                    BSV2PVS.extractGuardExpression1 })
                                 (GHC.Types.[] @ [GHC.Types.Char]))
                              (BSV2PVS.andChainExps
                                 (GHC.Base.map
                                    @ LexerTypes.ActionPath
                                    @ LexerTypes.Expression
                                    (BSV2PVS.fetchGuardByRule w w1)
                                    wild)))) }) -}
b5a89a33eceda63fb0fd7a77c8494076
  $wfilterCases ::
    LexerTypes.Statement
    -> [LexerTypes.Case] -> (# [LexerTypes.Case], [LexerTypes.Case] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: LexerTypes.Statement)
                   (w1 :: [LexerTypes.Case]) ->
                 (# letrec {
                      go16 :: [LexerTypes.Case] -> [LexerTypes.Case]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [LexerTypes.Case]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ LexerTypes.Case
                          : y ys
                          -> case y of wild1 { (,) ds1 q ->
                             case BSV2PVS.isStatementMatch w q of wild2 {
                               GHC.Types.False -> go16 ys
                               GHC.Types.True
                               -> GHC.Types.: @ LexerTypes.Case wild1 (go16 ys) } } }
                    } in
                    go16 w1,
                    letrec {
                      go16 :: [LexerTypes.Case] -> [LexerTypes.Case]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [LexerTypes.Case]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ LexerTypes.Case
                          : y ys
                          -> case y of wild1 { (,) ds1 q ->
                             case BSV2PVS.isStatementMatch w q of wild2 {
                               GHC.Types.False -> GHC.Types.: @ LexerTypes.Case wild1 (go16 ys)
                               GHC.Types.True -> go16 ys } } }
                    } in
                    go16 w1 #)) -}
7698776892f96dcd50bfd31795a39df4
  $wfindAction ::
    [LexerTypes.ActionDec]
    -> GHC.Base.String
    -> (# LexerTypes.ActionName, [LexerTypes.Statement],
          [LexerTypes.ActionAttribute] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
f3fb98c5702c1b04cc22fab63b7dbdd4
  $wfindLVarsWithName ::
    [LexerTypes.Statement]
    -> LexerTypes.ID_Path
    -> (# [LexerTypes.LocalVar], LexerTypes.Statement,
          [LexerTypes.StatementAttribute] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
45be1e85b76d5c0329aef50798791f5d
  $wfindRule ::
    [LexerTypes.RuleDec]
    -> GHC.Base.String
    -> (# LexerTypes.RuleName, LexerTypes.Guard,
          [LexerTypes.Statement], [LexerTypes.RuleAttribute] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
583627496e985fa73670f682c170ce8b
  $wfindSupremum ::
    [LexerTypes.RuleSchedule]
    -> (# LexerTypes.RuleSchedule, [LexerTypes.RuleSchedule],
          [LexerTypes.RuleSchedule] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.RuleSchedule]) ->
                 case w of wild {
                   []
                   -> case BSV2PVS.findSupremum3
                      ret_ty (# LexerTypes.RuleSchedule, [LexerTypes.RuleSchedule],
                                [LexerTypes.RuleSchedule] #)
                      of {}
                   : ipv ipv1
                   -> let {
                        supremum :: LexerTypes.RuleSchedule
                        = BSV2PVS.arbitrateRuleSchemes
                            (GHC.List.filter
                               @ LexerTypes.RuleSchedule
                               BSV2PVS.findSupremum2
                               wild)
                            (GHC.List.filter
                               @ LexerTypes.RuleSchedule
                               BSV2PVS.findSupremum1
                               wild)
                      } in
                      let {
                        baseSet :: [LexerTypes.RuleSchedule]
                        = case Data.OldList.deleteBy
                                 @ LexerTypes.RuleSchedule
                                 LexerTypes.$fEqRuleSchedule_$c==
                                 supremum
                                 wild of wild1 {
                            [] -> GHC.Types.[] @ LexerTypes.RuleSchedule
                            : ipv2 ipv3
                            -> GHC.Base.map
                                 @ LexerTypes.RuleSchedule
                                 @ LexerTypes.RuleSchedule
                                 (BSV2PVS.killSupremumReference (LexerTypes.rName supremum))
                                 wild1 }
                      } in
                      (# supremum,
                         BSV2PVS.winnowRuleSchedules'
                           (LexerTypes.rName supremum)
                           baseSet
                           baseSet,
                         baseSet #) }) -}
f1f89d4af4d41c65f1c6bbbe708544a5
  $wgenRuleHeap ::
    [LexerTypes.RuleSchedule]
    -> [GHC.Base.String]
    -> (# GHC.Base.String, [LexerTypes.RuleSchedule],
          [LexerTypes.RuleHeap] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
1981e42395c7fbc19ce9bdd1787c2da5
  $wgenRuleSchedule ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.RuleName
    -> LexerTypes.Guard
    -> [LexerTypes.Statement]
    -> [LexerTypes.RuleAttribute]
    -> LexerTypes.RuleSchedule
  {- Arity: 8,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,U,U,U,U,U,U,U,U,U)><L,U><L,U><L,U><L,U><L,U><L,1*U>,
     Inline: [0] -}
e3f9eb3b66ce3285171a6de420fd279d
  $wgenTotalTree :: [LexerTypes.RuleSchedule] -> LexerTypes.TotalTree
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
9ca7ac957efc8669474ecea0eb8dfd44
  $wgenTrans ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.TotalTree
    -> [LexerTypes.TreeHeap]
    -> LexerTypes.BSVstateDec
    -> LexerTypes.TransitionTable
  {- Arity: 8,
     Strictness: <L,U(A,A,A,A,A,U,U,A,A,A,A)><L,U(A,A,U,A,A,A,A,U,A,A)><L,U><L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
58bee86c5651f6a3e1b98fe1555b9558
  $wgenTransitionVars ::
    LexerTypes.BSVPackage
    -> GHC.Base.String
    -> [LexerTypes.BSVstateDec]
    -> [LexerTypes.MethodBody]
    -> [(LexerTypes.PVSType, [GHC.Base.String])]
  {- Arity: 4,
     Strictness: <L,1*U(A,A,A,1*U,A,A,A,A,A,A,A)><L,U><L,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVPackage)
                   (ww :: GHC.Base.String)
                   (ww1 :: [LexerTypes.BSVstateDec])
                   (ww2 :: [LexerTypes.MethodBody]) ->
                 GHC.Base.++
                   @ (LexerTypes.PVSType, [GHC.Base.String])
                   (BSV2PVS.groupByType
                      (Data.OldList.nubBy
                         @ (LexerTypes.PVSType, GHC.Base.String)
                         BSV2PVS.genTransitionVars3
                         (BSV2PVS.genMethVars
                            ww2
                            (case w of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                             case BSV2PVS.findInterface ds4 ww of wild1 {
                               GHC.Base.Nothing
                               -> case BSV2PVS.genTransitionVars2
                                  ret_ty [LexerTypes.MethodDec]
                                  of {}
                               GHC.Base.Just x
                               -> case x of wild2 { (,,,) ds x1 ds16 ds17 -> x1 } } }))))
                   (BSV2PVS.groupByType
                      (Data.OldList.nubBy
                         @ (LexerTypes.PVSType, GHC.Base.String)
                         BSV2PVS.genTransitionVars1
                         (BSV2PVS.maybeToEmpty
                            @ (LexerTypes.PVSType, GHC.Base.String)
                            (GHC.Base.map
                               @ LexerTypes.BSVstateDec
                               @ (GHC.Base.Maybe (LexerTypes.PVSType, GHC.Base.String))
                               BSV2PVS.genSubmodVars
                               ww1))))) -}
24e03c32df14acdf60bdd53ed244b335
  $wgenTransitions ::
    LexerTypes.BSVPackage
    -> GHC.Base.String
    -> GHC.Integer.Type.Integer
    -> [LexerTypes.ID_Path]
    -> (# GHC.Integer.Type.Integer,
          [(LexerTypes.MethodName,
            [(LexerTypes.MethodArg, LexerTypes.PVSType)])],
          [LexerTypes.ValueMethod], [LexerTypes.TransitionTable] #)
  {- Arity: 4,
     Strictness: <L,U(A,A,A,U,A,U,U,U,A,A,A)><L,U><L,U><L,U>,
     Inline: [0] -}
ee816fa9b1ec58451c163a233cdc7ddb
  $wgenTreeHeap ::
    GHC.Base.String
    -> [LexerTypes.RuleSchedule]
    -> [LexerTypes.RuleHeap]
    -> (# GHC.Base.String, LexerTypes.TotalTree,
          [LexerTypes.TreeHeap] #)
  {- Arity: 3, Strictness: <L,U><L,1*U><L,1*U>, Inline: [0] -}
67d4d4d31b73d6be7a9ffdb77deb0f8e
  $wgenValueMethods ::
    GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.BSVModuleDec]
    -> GHC.Base.String
    -> [LexerTypes.BSVstateDec]
    -> [LexerTypes.ActionDec]
    -> [LexerTypes.RuleDec]
    -> [LexerTypes.MethodBody]
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [(LexerTypes.MethodName, LexerTypes.ModuleName, GHC.Base.String,
         LexerTypes.Path, LexerTypes.PVSType, LexerTypes.Expression,
         [LexerTypes.ID_Path])]
  {- Arity: 10,
     Strictness: <L,U><L,U><S,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
27a2d56d36222ef161ff823dc9247d74
  $wgetCasesMatching :: [LexerTypes.Case] -> [[LexerTypes.Case]]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
354b305de30e676d4e3f104c8efb0a60
  $wgetMethodDependencies ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.TransitionTable]
    -> LexerTypes.MethodName
    -> LexerTypes.ModuleName
    -> GHC.Base.String
    -> LexerTypes.Path
    -> LexerTypes.PVSType
    -> LexerTypes.Expression
    -> [LexerTypes.ID_Path]
    -> (# [GHC.Base.String], LexerTypes.ValueMethod #)
  {- Arity: 10,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [LexerTypes.TransitionTable])
                   (ww :: LexerTypes.MethodName)
                   (ww1 :: LexerTypes.ModuleName)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: LexerTypes.Path)
                   (ww4 :: LexerTypes.PVSType)
                   (ww5 :: LexerTypes.Expression)
                   (ww6 :: [LexerTypes.ID_Path]) ->
                 (# letrec {
                      go16 :: [LexerTypes.Expression] -> [[GHC.Types.Char]]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [LexerTypes.Expression]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ [GHC.Types.Char]
                          : y ys
                          -> let {
                               ys1 :: [[GHC.Types.Char]] = go16 ys
                             } in
                             letrec {
                               go17 :: [LexerTypes.Expression] -> [[GHC.Types.Char]]
                                 {- Arity: 1, Strictness: <S,1*U> -}
                               = \ (ds1 :: [LexerTypes.Expression]) ->
                                 case ds1 of wild1 {
                                   [] -> ys1
                                   : y1 ys2
                                   -> GHC.Types.:
                                        @ [GHC.Types.Char]
                                        (case y1 of wild2 {
                                           DEFAULT -> BSV2PVS.getMethodDependencies2
                                           LexerTypes.Exp_MethodCall x y2 ds2 ds3
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                (BSV2PVS.lastID x)
                                                (GHC.CString.unpackAppendCString#
                                                   BSV2PVS.getMethodDependencies1
                                                   y2) })
                                        (go17 ys2) }
                             } in
                             go17 (BSV2PVS.getMethCallsExp w w1 GHC.Types.True y) }
                    } in
                    go16
                      (GHC.Types.:
                         @ LexerTypes.Expression
                         ww5
                         (BSV2PVS.getWireMCalls w w1 w2 ww3 ww5)),
                    (ww, ww1, ww2, ww3, ww4, ww5, ww6) #)) -}
c66794d46a666fd3ac84f6f0650b992f
  $wgetPreempts ::
    LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.ActionPath]
    -> (# [LexerTypes.ActionPath], [LexerTypes.ActionPath] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,A,A,A,A,1*U,A,A,A,A)><L,U><L,U><L,U><L,1*U><L,1*U>,
     Inline: [0] -}
6c9c49373e4b9c2d33be096be92ce84a
  $wgetPreempts' ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.ActionPath]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
624b8f614b48cb8330b56cc7e0a0e97c
  $wgetReplacements ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.Expression] -> [LexerTypes.Replacement]
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,A,A,A,U)><S,1*U>,
     Inline: [0] -}
ef16797228d93c1ceda8cf2fc9b87893
  $wgetStructType ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVType
    -> (# LexerTypes.Name, [LexerTypes.BSV_Field] #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
10819e4d65877bdc2063bb1d8bee53b4
  $wgetTypeDef ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.Name -> (# LexerTypes.Name, [LexerTypes.BSV_Field] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
9c86d107ddddb76a73a79646272cbe7a
  $widpath2strings ::
    LexerTypes.ID_Path -> (# GHC.Base.String, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
369650227d9389609394258a1c21b54e
  $winstantiateSubmod ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVstateDec -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 2, Strictness: <L,1*U(A,A,A,A,A,A,A,1*U,A,A,A)><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVstateDec) ->
                 case w1 of wild {
                   DEFAULT -> GHC.Base.Nothing @ LexerTypes.BSVModuleDec
                   LexerTypes.BSV_SubModuleDec inter nom inst
                   -> GHC.Base.Just
                        @ LexerTypes.BSVModuleDec
                        (case w of wild1 { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                         case BSV2PVS.getMod inter ds8 of wild2 {
                           GHC.Base.Nothing -> BSV2PVS.instantiateSubmod1
                           GHC.Base.Just x
                           -> case x of wild3 { LexerTypes.BSVModuleDec ds ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ->
                              LexerTypes.BSVModuleDec
                                ds
                                inst
                                ds17
                                ds18
                                ds19
                                ds20
                                ds21
                                ds22
                                ds23
                                ds24 } } }) }) -}
61fdee515e3192196c636ee88a30789b
  $winstantiateSubmods' ::
    LexerTypes.BSVPackage
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.MidModInterfaceDec]
    -> [LexerTypes.ModuleAttribute]
    -> [LexerTypes.BSVstateDec]
    -> [LexerTypes.ActionDec]
    -> [LexerTypes.RuleDec]
    -> [LexerTypes.MethodBody]
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 10,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
e00ca7f5555f3c1e1b863dc747f0512b
  $winterfaceLookup ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> [LexerTypes.MidModInterfaceDec]
    -> GHC.Base.Maybe [LexerTypes.MethodBody]
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: GHC.Base.String)
                   (w1 :: [LexerTypes.MidModInterfaceDec]) ->
                 case ww of ds {
                   DEFAULT -> BSV2PVS.interfaceLookup3
                   1#
                   -> GHC.List.lookup
                        @ GHC.Base.String
                        @ [LexerTypes.MethodBody]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        w
                        (GHC.Base.map
                           @ (GHC.Base.String, GHC.Base.String, [LexerTypes.MethodBody])
                           @ (GHC.Base.String, [LexerTypes.MethodBody])
                           BSV2PVS.interfaceLookup2
                           w1)
                   2#
                   -> GHC.List.lookup
                        @ GHC.Base.String
                        @ [LexerTypes.MethodBody]
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        w
                        (GHC.Base.map
                           @ (GHC.Base.String, GHC.Base.String, [LexerTypes.MethodBody])
                           @ (GHC.Base.String, [LexerTypes.MethodBody])
                           BSV2PVS.interfaceLookup1
                           w1) }) -}
8490b5cd4a3e39f83d495df8172b8c7a
  $wisClearAnterior ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.Statement]
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,U,A,A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (ww :: [LexerTypes.Statement])
                   (w2 :: [LexerTypes.ID_Path]) ->
                 let {
                   lvl564 :: [LexerTypes.ID_Path]
                   = let {
                       z :: [LexerTypes.ID_Path]
                       = let {
                           z1 :: [LexerTypes.ID_Path]
                           = BSV2PVS.getAllInvokationsOf
                               (BSV2PVS.getMethCalls w w1 GHC.Types.False ww)
                               BSV2PVS.isClearAnterior5
                         } in
                         letrec {
                           go16 :: [LexerTypes.Statement] -> [LexerTypes.ID_Path]
                             {- Arity: 1, Strictness: <S,1*U> -}
                           = \ (ds :: [LexerTypes.Statement]) ->
                             case ds of wild {
                               [] -> z1
                               : y ys
                               -> GHC.Base.++
                                    @ LexerTypes.ID_Path
                                    (BSV2PVS.getMCalls w w1 BSV2PVS.isClearAnterior3 y)
                                    (go16 ys) }
                         } in
                         go16 ww
                     } in
                     letrec {
                       go16 :: [LexerTypes.Statement] -> [LexerTypes.ID_Path]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [LexerTypes.Statement]) ->
                         case ds of wild {
                           [] -> z
                           : y ys
                           -> GHC.Base.++
                                @ LexerTypes.ID_Path
                                (BSV2PVS.getMCalls w w1 BSV2PVS.isClearAnterior1 y)
                                (go16 ys) }
                     } in
                     go16 ww
                 } in
                 GHC.List.filter
                   @ LexerTypes.ID_Path
                   (\ (x :: LexerTypes.ID_Path) ->
                    GHC.List.elem @ LexerTypes.ID_Path LexerTypes.$fEqID_Path x lvl564)
                   w2) -}
e4caa42953f6436aacffff942e795b67
  $wisDeqAnterior ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.Statement]
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,U,A,A)><L,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (ww :: [LexerTypes.Statement])
                   (w2 :: [LexerTypes.ID_Path]) ->
                 let {
                   firsts :: [LexerTypes.ID_Path]
                   = BSV2PVS.getAllInvokationsOf
                       (BSV2PVS.getMethCalls w w1 GHC.Types.False ww)
                       BSV2PVS.isClearAnterior5
                 } in
                 GHC.List.filter
                   @ LexerTypes.ID_Path
                   (\ (x :: LexerTypes.ID_Path) ->
                    GHC.List.elem @ LexerTypes.ID_Path LexerTypes.$fEqID_Path x firsts)
                   w2) -}
a17046383873e19c281aae7251b5f3df
  $wisInSubmod ::
    LexerTypes.BSVPackage
    -> [LexerTypes.BSVstateDec] -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S,1*U><L,U>,
     Inline: [0] -}
6401812d503a3715f942952ecb435149
  $wisInWhichSubmod ::
    [LexerTypes.BSVModuleDec]
    -> LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 2, Strictness: <S,U><L,1*U(A,A,A,A,A,A,U,A,A,A)>,
     Inline: [0],
     Unfolding: (\ (ww :: [LexerTypes.BSVModuleDec])
                   (w :: LexerTypes.BSVModuleDec) ->
                 case BSV2PVS.getMod
                        (case w of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                         let {
                           modList :: [GHC.Base.String] = BSV2PVS.extractSubmods ds7
                         } in
                         let {
                           universe :: LexerTypes.BSVPackage
                           = LexerTypes.BSVPackage
                               BSV2PVS.isInWhichSubmod20
                               BSV2PVS.isInWhichSubmod18
                               BSV2PVS.isInWhichSubmod16
                               BSV2PVS.isInWhichSubmod14
                               BSV2PVS.isInWhichSubmod12
                               BSV2PVS.isInWhichSubmod10
                               BSV2PVS.isInWhichSubmod8
                               ww
                               BSV2PVS.isInWhichSubmod6
                               BSV2PVS.isInWhichSubmod4
                               BSV2PVS.isInWhichSubmod2
                         } in
                         BSV2PVS.isInWhichSubmod_go2
                           modList
                           (GHC.Base.map
                              @ [GHC.Types.Char]
                              @ GHC.Types.Bool
                              (\ (w1 :: GHC.Base.String) -> BSV2PVS.$wisInSubmod universe ds7 w1)
                              modList) })
                        ww of wild {
                   GHC.Base.Nothing -> BSV2PVS.isInWhichSubmod1
                   GHC.Base.Just x -> x }) -}
c555a9c55639ce0e82ac15ed8ec416fa
  $wisReferencedAnywhere ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> [LexerTypes.LocalVar]
    -> LexerTypes.Statement
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,U><S,1*U><L,U>,
     Inline: [0] -}
585fd7e360db8e97601f579ecafda35f
  $wisReferencedin ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path -> LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVModuleDec)
                   (ww :: LexerTypes.ID_Path)
                   (w1 :: LexerTypes.Statement) ->
                 GHC.List.elem
                   @ LexerTypes.ID_Path
                   LexerTypes.$fEqID_Path
                   ww
                   (BSV2PVS.getReadsByOverStatements
                      w
                      BSV2PVS.convertToFunction1
                      (GHC.Types.[] @ GHC.Base.String)
                      (GHC.Types.:
                         @ LexerTypes.Statement
                         w1
                         (GHC.Types.[] @ LexerTypes.Statement)))) -}
df9f4d66a9d2c7cd914e43321528d12a
  $wisSubMethod ::
    [LexerTypes.MethodBody] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
0188b6314ed647ad57aae20cdfee8dee
  $wisWireAnterior ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.Guard
    -> [LexerTypes.Statement]
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVModuleDec)
                   (ww :: LexerTypes.Guard)
                   (ww1 :: [LexerTypes.Statement])
                   (w1 :: [LexerTypes.ID_Path]) ->
                 GHC.Base.++
                   @ LexerTypes.ID_Path
                   (BSV2PVS.getReadsBy
                      w
                      (\ (x :: LexerTypes.ID_Path) ->
                       GHC.List.elem @ LexerTypes.ID_Path LexerTypes.$fEqID_Path x w1)
                      (GHC.Types.[] @ GHC.Base.String)
                      ww)
                   (BSV2PVS.getReadsByOverStatements
                      w
                      (\ (x :: LexerTypes.ID_Path) ->
                       GHC.List.elem @ LexerTypes.ID_Path LexerTypes.$fEqID_Path x w1)
                      (GHC.Types.[] @ GHC.Base.String)
                      ww1)) -}
83f5984224aaf1eb2183583799ed4d49
  $wkillNonreferencedMethods ::
    [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.ValueMethod
    -> (# [GHC.Base.String], LexerTypes.ValueMethod #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,U(U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: [GHC.Base.String])
                   (ww :: [GHC.Base.String])
                   (ww1 :: LexerTypes.ValueMethod) ->
                 (# let {
                      refs' :: [[GHC.Types.Char]]
                      = Data.OldList.deleteBy
                          @ [GHC.Types.Char]
                          GHC.Base.eqString
                          (case ww1 of wild { (,,,,,,) x ds ds1 y ds2 ds3 ds4 ->
                           case y of wild1 {
                             [] -> case GHC.List.scanl2 ret_ty [GHC.Types.Char] of {}
                             : ds5 xs
                             -> case xs of wild2 {
                                  []
                                  -> GHC.CString.unpackAppendCString#
                                       BSV2PVS.getMethodDependencies1
                                       x
                                  : x1 xs1
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       (Data.OldList.intercalate_$spoly_go
                                          @ GHC.Types.Char
                                          x1
                                          (Data.OldList.prependToAll
                                             @ [GHC.Types.Char]
                                             BSV2PVS.killNonreferencedMethods1
                                             xs1))
                                       (GHC.CString.unpackAppendCString#
                                          BSV2PVS.getMethodDependencies1
                                          x) } } })
                          w
                    } in
                    GHC.List.filter
                      @ [GHC.Types.Char]
                      (\ (x :: [GHC.Types.Char]) ->
                       GHC.List.elem
                         @ [GHC.Types.Char]
                         GHC.Classes.$fEq[]_$s$fEq[]1
                         x
                         refs')
                      ww,
                    ww1 #)) -}
13c7e9ed8ea8b740a0ff6be3ce2d969f
  $wlDecExpressionize' ::
    [LexerTypes.Statement]
    -> LexerTypes.ID_Path
    -> Data.Either.Either
         (GHC.Base.Maybe LexerTypes.BSVType)
         (GHC.Base.Maybe LexerTypes.PVSType)
    -> LexerTypes.Expression
    -> (# LexerTypes.LocalVar, [LexerTypes.Statement] #)
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.Statement])
                   (ww :: LexerTypes.ID_Path)
                   (ww1 :: Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType))
                   (ww2 :: LexerTypes.Expression) ->
                 let {
                   ldecStmts :: [LexerTypes.Statement]
                   = GHC.List.filter @ LexerTypes.Statement (BSV2PVS.isThisLDec ww) w
                 } in
                 (# case BSV2PVS.$wcombineLDecs
                           ww
                           ww1
                           ww2
                           (BSV2PVS.removeVoids
                              (GHC.Base.map
                                 @ LexerTypes.Statement
                                 @ LexerTypes.Statement
                                 (BSV2PVS.keepLDec ww)
                                 ldecStmts)) of ww3 { (#,,#) ww4 ww5 ww6 ->
                    (ww4, ww5, ww6) },
                    GHC.Base.++
                      @ LexerTypes.Statement
                      (BSV2PVS.removeVoids
                         (GHC.Base.map
                            @ LexerTypes.Statement
                            @ LexerTypes.Statement
                            (BSV2PVS.removeLDec ww)
                            ldecStmts))
                      (GHC.List.filter
                         @ LexerTypes.Statement
                         (\ (x :: LexerTypes.Statement) ->
                          case BSV2PVS.isThisLDec ww x of wild {
                            GHC.Types.False -> GHC.Types.True
                            GHC.Types.True -> GHC.Types.False })
                         w) #)) -}
8326b90b3d58c71c7b6ab98c73857864
  $wlookupInst ::
    [LexerTypes.BSVInstDef]
    -> GHC.Base.String
    -> (# LexerTypes.Name, [(LexerTypes.Name, LexerTypes.Literal)] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
8213b639cc530ec18f44543b898df405
  $wlookupInst' ::
    [LexerTypes.BSVInstDef]
    -> LexerTypes.BSVType
    -> (# LexerTypes.Name, [(LexerTypes.Name, LexerTypes.Literal)] #)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
b36bddb8170d290495f733d79c9606fc
  $wlpMod ::
    LexerTypes.BSVModuleDec
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Inline: [0] -}
cae14e68821456c17f602a6543306a77
  $wlvl ::
    LexerTypes.PVSType
    -> [GHC.Types.Char]
    -> LexerTypes.PVSType
    -> [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.PVSType)
                   (ww1 :: [GHC.Types.Char])
                   (ww2 :: LexerTypes.PVSType)
                   (ww3 :: [GHC.Types.Char]) ->
                 case LexerTypes.$fEqPVSType_$c== ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Base.eqString ww1 ww3 }) -}
0ba8cc7b39b34349a147c709624d575b
  $wlvl1 ::
    LexerTypes.PVSType
    -> [GHC.Types.Char]
    -> LexerTypes.PVSType
    -> [GHC.Types.Char]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.PVSType)
                   (ww1 :: [GHC.Types.Char])
                   (ww2 :: LexerTypes.PVSType)
                   (ww3 :: [GHC.Types.Char]) ->
                 case LexerTypes.$fEqPVSType_$c== ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Base.eqString ww1 ww3 }) -}
90446f0eb5987689a8cff4e0e8a85983
  $wlvl2 ::
    LexerTypes.Statement
    -> LexerTypes.Statement
    -> LexerTypes.Statement
    -> LexerTypes.Statement
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: LexerTypes.Statement)
                   (ww1 :: LexerTypes.Statement)
                   (ww2 :: LexerTypes.Statement)
                   (ww3 :: LexerTypes.Statement) ->
                 case LexerTypes.$fEqStatement_$c== ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> LexerTypes.$fEqStatement_$c== ww1 ww3 }) -}
f1f66a60a75ce7c637b200f1f2177c93
  $wlvl3 ::
    [LexerTypes.HexFile]
    -> LexerTypes.FileName -> LexerTypes.BSVstateDec
  {- Arity: 2, Strictness: <B,1*U><B,U>x, Inline: [0] -}
1e85fece371da6ae330f5a737b87d47e
  $wmakeActionPath' ::
    LexerTypes.BSVPackage
    -> GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.BSVModuleDec]
    -> GHC.Base.String
    -> [LexerTypes.BSVstateDec]
    -> [LexerTypes.ActionDec]
    -> [LexerTypes.RuleDec]
    -> [LexerTypes.MethodBody]
    -> GHC.Base.String
    -> LexerTypes.ActionPath
  {- Arity: 10,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,1*U><L,1*U><L,1*U><L,1*U><L,U><S,U><L,U><L,U><L,U>,
     Inline: [0] -}
59e64fdcd679880799861a5e73d94777
  $wmergeDeeperLets ::
    [LexerTypes.Statement]
    -> [LexerTypes.Statement]
    -> [LexerTypes.Statement]
    -> (# [LexerTypes.Statement], [LexerTypes.Statement] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
4cd43bab05c5b804bc584e53bb6ca231
  $wmergeIDPaths ::
    LexerTypes.ID_Path
    -> LexerTypes.ID_Path
    -> (# LexerTypes.ModuleInst, LexerTypes.ID_Path #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
90893884d55495e29709bc38699266f4
  $wmethDescUrgPragma ::
    [LexerTypes.ModuleAttribute]
    -> GHC.Base.String -> [GHC.Base.String] -> [LexerTypes.ActionPath]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [LexerTypes.ModuleAttribute])
                   (w :: GHC.Base.String)
                   (w1 :: [GHC.Base.String]) ->
                 letrec {
                   go16 :: [[GHC.Base.String]] -> [LexerTypes.ActionPath]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Base.String]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ LexerTypes.ActionPath
                       : y ys
                       -> let {
                            ys1 :: [LexerTypes.ActionPath] = go16 ys
                          } in
                          letrec {
                            go17 :: [GHC.Base.String] -> [LexerTypes.ActionPath]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Base.String]) ->
                              case ds1 of wild1 {
                                [] -> ys1
                                : y1 ys2
                                -> GHC.Types.:
                                     @ LexerTypes.ActionPath
                                     (BSV2PVS.makeActionPath
                                        (GHC.Base.++
                                           @ [GHC.Types.Char]
                                           w1
                                           (GHC.Types.:
                                              @ GHC.Base.String
                                              y1
                                              (GHC.Types.[] @ GHC.Base.String))))
                                     (go17 ys2) }
                          } in
                          go17 (BSV2PVS.getLowerUrgencies w y) }
                 } in
                 go16
                   (BSV2PVS.filterDesUrgsForName (BSV2PVS.filterDesUrgs ww) w)) -}
ed2f9a9a3e7ed3951832dd0354ce98ca
  $wmethDescUrgPragmaInverse ::
    [LexerTypes.ModuleAttribute]
    -> GHC.Base.String -> [GHC.Base.String] -> [LexerTypes.ActionPath]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [LexerTypes.ModuleAttribute])
                   (w :: GHC.Base.String)
                   (w1 :: [GHC.Base.String]) ->
                 letrec {
                   go16 :: [[GHC.Types.Char]] -> [[GHC.Types.Char]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Types.Char]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [GHC.Types.Char]
                       : y ys
                       -> case GHC.Classes.$fEqModule_$s$c== w y of wild1 {
                            GHC.Types.False -> GHC.Types.: @ [GHC.Types.Char] y (go16 ys)
                            GHC.Types.True -> GHC.Types.[] @ [GHC.Types.Char] } }
                 } in
                 letrec {
                   go17 :: [[GHC.Base.String]] -> [LexerTypes.ActionPath]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [[GHC.Base.String]]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ LexerTypes.ActionPath
                       : y ys
                       -> let {
                            ys1 :: [LexerTypes.ActionPath] = go17 ys
                          } in
                          letrec {
                            go18 :: [GHC.Base.String] -> [LexerTypes.ActionPath]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Base.String]) ->
                              case ds1 of wild1 {
                                [] -> ys1
                                : y1 ys2
                                -> GHC.Types.:
                                     @ LexerTypes.ActionPath
                                     (BSV2PVS.makeActionPath
                                        (GHC.Base.++
                                           @ [GHC.Types.Char]
                                           w1
                                           (GHC.Types.:
                                              @ GHC.Base.String
                                              y1
                                              (GHC.Types.[] @ GHC.Base.String))))
                                     (go18 ys2) }
                          } in
                          case y of wild1 {
                            [] -> go18 (GHC.Types.[] @ GHC.Base.String)
                            : ipv ipv1 -> go18 (go16 wild1) } }
                 } in
                 go17
                   (BSV2PVS.filterDesUrgsForName (BSV2PVS.filterDesUrgs ww) w)) -}
adf3f18599487d1abcb0d071c58894b9
  $wremoveAtIndex :: GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a (ww :: GHC.Prim.Int#) (w :: [a]) ->
                 let {
                   n3 :: [a]
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 0#) of wild1 {
                       GHC.Types.False
                       -> case w of wild {
                            [] -> GHC.Types.[] @ a
                            : ipv ipv1
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> case GHC.List.splitAt_$s$wsplitAt'
                                           @ a
                                           ipv1
                                           (GHC.Prim.-# ds1 1#) of ww1 { (#,#) ww2 ww3 ->
                                    case ww3 of wild2 { [] -> GHC.Types.[] @ a : ds2 ds3 -> ds3 } }
                                 1#
                                 -> case ipv1 of wild2 {
                                      [] -> GHC.Types.[] @ a : ds2 ds3 -> ds3 } } }
                       GHC.Types.True
                       -> case w of wild { [] -> GHC.Types.[] @ a : ds1 ds2 -> ds2 } }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0#) of wild1 {
                   GHC.Types.False
                   -> case w of wild {
                        [] -> GHC.Base.++ @ a (GHC.Types.[] @ a) n3
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> GHC.Base.++
                                  @ a
                                  (GHC.Types.:
                                     @ a
                                     ipv
                                     (case GHC.List.splitAt_$s$wsplitAt'
                                             @ a
                                             ipv1
                                             (GHC.Prim.-# ds1 1#) of ww1 { (#,#) ww2 ww3 ->
                                      ww2 }))
                                  n3
                             1#
                             -> GHC.Base.++ @ a (GHC.Types.: @ a ipv (GHC.Types.[] @ a)) n3 } }
                   GHC.Types.True -> n3 }) -}
1d1e014a554a0bb217da3aba175329b1
  $wremoveLDecReference ::
    LexerTypes.ID_Path -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
20ea8a276c1f3215cfc970299b0ab9c9
  $wrfMod ::
    [LexerTypes.BSVTypeDef]
    -> [LexerTypes.HexFile]
    -> [GHC.Base.String]
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.BSVModuleDec
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 5,
     Strictness: <L,U><L,U><L,1*U><L,U><L,U(U,U,U,U,1*U,1*U,U,U,U,U)>,
     Inline: [0] -}
a4b8cc5e88a743dd7bfab0a6ffd0e505
  $wrfState ::
    [LexerTypes.HexFile]
    -> LexerTypes.BSVstateDec -> LexerTypes.BSVstateDec
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.HexFile])
                   (w1 :: LexerTypes.BSVstateDec) ->
                 case w1 of wild {
                   DEFAULT -> wild
                   LexerTypes.BSV_RegFile i w2 t l
                   -> case BSV2PVS.lookupBy
                             @ [GHC.Types.Char]
                             @ [GHC.Types.Char]
                             @ [LexerTypes.Literal]
                             BSV2PVS.rfState4
                             (case l of wild1 { LexerTypes.RegFileLoad n3 x y -> n3 })
                             w of wild1 {
                        GHC.Base.Nothing -> BSV2PVS.rfState3 w l
                        GHC.Base.Just z
                        -> LexerTypes.BSV_Vector
                             i
                             t
                             (case w2 of wild2 {
                                DEFAULT -> BSV2PVS.getTypeBitSize2
                                LexerTypes.BSV_Bool -> BSV2PVS.rfState2
                                LexerTypes.BSV_Bit n3 -> GHC.Real.^_$s^ BSV2PVS.rfState1 n3
                                LexerTypes.BSV_Int n3 -> GHC.Real.^_$s^ BSV2PVS.rfState1 n3
                                LexerTypes.BSV_UInt n3 -> GHC.Real.^_$s^ BSV2PVS.rfState1 n3 })
                             (LexerTypes.Explicit z) } }) -}
cdc7e50283f2f578d7620d8ced1f0eca
  $wrfStructCase ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.BSVType
    -> [LexerTypes.InterfaceRef]
    -> GHC.Base.String
    -> LexerTypes.Expression
    -> (# GHC.Base.String, LexerTypes.Expression #)
  {- Arity: 8,
     Strictness: <L,U><L,U(U,U,U,U,A,A,A,U,U,U)><L,U><L,U><S,1*U><L,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.BSVTypeDef])
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: LexerTypes.BSVType)
                   (w5 :: [LexerTypes.InterfaceRef])
                   (ww :: GHC.Base.String)
                   (ww1 :: LexerTypes.Expression) ->
                 case w4 of wild {
                   DEFAULT
                   -> case BSV2PVS.rfStructCase1
                      ret_ty (# GHC.Base.String, LexerTypes.Expression #)
                      of {}
                   LexerTypes.BSV_Custom btyp
                   -> (# ww,
                         BSV2PVS.rfExp
                           w
                           w1
                           w2
                           w3
                           (GHC.Base.Just
                              @ LexerTypes.BSVType
                              (case BSV2PVS.$wgetTypeDef w btyp of ww2 { (#,#) ww3 ww4 ->
                               case GHC.List.lookup
                                      @ LexerTypes.Name
                                      @ LexerTypes.BSVType
                                      GHC.Classes.$fEq[]_$s$fEq[]1
                                      ww
                                      ww4 of wild1 {
                                 GHC.Base.Nothing -> BSV2PVS.b2pInstDef'2 GHC.Base.Just x -> x } }))
                           w5
                           ww1 #) }) -}
f302b8a0e1ef83c91c8529935cecd444
  $wrightMeth ::
    [LexerTypes.MethodDec]
    -> GHC.Base.String
    -> (# LexerTypes.Name, LexerTypes.ReturnType,
          [LexerTypes.Argument], [LexerTypes.MethodDecAttribute] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
5f78c67e95de3c65e69027505360e1bf
  $wruleMerge ::
    [LexerTypes.RuleSchedule]
    -> (# LexerTypes.RuleSchedule,
          ([LexerTypes.ActionPath], LexerTypes.ActionPath) #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [LexerTypes.RuleSchedule]) ->
                 case w of wild {
                   []
                   -> case BSV2PVS.ruleMerge1
                      ret_ty (# LexerTypes.RuleSchedule,
                                ([LexerTypes.ActionPath], LexerTypes.ActionPath) #)
                      of {}
                   : r rs
                   -> let {
                        names :: [LexerTypes.ActionPath]
                        = Data.OldList.nubBy
                            @ LexerTypes.ActionPath
                            LexerTypes.$fEqActionPath_$c==
                            (GHC.Base.map
                               @ LexerTypes.RuleSchedule
                               @ LexerTypes.ActionPath
                               LexerTypes.rName
                               wild)
                      } in
                      let {
                        nom :: LexerTypes.ActionPath = BSV2PVS.mergeActionPaths names
                      } in
                      (# LexerTypes.RuleSchedule
                           nom
                           (LexerTypes.rGuard r)
                           (BSV2PVS.ruleMerge_go8 wild)
                           (LexerTypes.implicitConditions r)
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go7 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go6 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go5 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go4 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go3 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go2 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.ID_Path
                              LexerTypes.$fEqID_Path_$c==
                              (BSV2PVS.ruleMerge_go1 wild))
                           (Data.OldList.nubBy
                              @ LexerTypes.Expression
                              LexerTypes.$fEqExpression_$c==
                              (BSV2PVS.ruleMerge_go wild))
                           (LexerTypes.conflictsWith r)
                           (LexerTypes.noConflictsWith r)
                           (LexerTypes.preempts r)
                           (LexerTypes.isPreemptedBy r)
                           (LexerTypes.executesAfter r)
                           (LexerTypes.executesBefore r),
                         (names, nom) #) }) -}
81f28b0bd44d8fb6fb28f2f95abd17b5
  $wsamMod ::
    LexerTypes.BSVModuleDec
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Inline: [0] -}
f5710b0fe65027b4b92fcea666d811a0
  $wsortWires ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.ID_Path]
    -> (# [LexerTypes.ID_Path], [LexerTypes.ID_Path] #)
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: [LexerTypes.ID_Path]) ->
                 (# letrec {
                      go16 :: [LexerTypes.ID_Path] -> [LexerTypes.ID_Path]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [LexerTypes.ID_Path]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ LexerTypes.ID_Path
                          : y ys
                          -> case BSV2PVS.isDWire w y of wild1 {
                               GHC.Types.False -> GHC.Types.: @ LexerTypes.ID_Path y (go16 ys)
                               GHC.Types.True -> go16 ys } }
                    } in
                    go16 w1,
                    letrec {
                      go16 :: [LexerTypes.ID_Path] -> [LexerTypes.ID_Path]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [LexerTypes.ID_Path]) ->
                        case ds of wild {
                          [] -> GHC.Types.[] @ LexerTypes.ID_Path
                          : y ys
                          -> case BSV2PVS.isDWire w y of wild1 {
                               GHC.Types.False -> go16 ys
                               GHC.Types.True -> GHC.Types.: @ LexerTypes.ID_Path y (go16 ys) } }
                    } in
                    go16 w1 #)) -}
983957325e20bbca484ef1fdaeb3410f
  $wsplitCase ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.Literal -> LexerTypes.Statement -> [LexerTypes.Case]
  {- Arity: 3, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: LexerTypes.BSVModuleDec)
                   (ww :: LexerTypes.Literal)
                   (ww1 :: LexerTypes.Statement) ->
                 GHC.Base.map
                   @ LexerTypes.Statement
                   @ (LexerTypes.Literal, LexerTypes.Statement)
                   (\ (x :: LexerTypes.Statement) -> (ww, x))
                   (BSV2PVS.removeVoids (BSV2PVS.splitStatementBlock w ww1))) -}
afa20199aca8e9a87f718a2e0c115a53
  $wsplitStatementPreprocModule ::
    LexerTypes.BSVModuleDec
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 1, Strictness: <L,U(U,U,U,U,1*U,1*U,1*U,U,U,U)>,
     Inline: [0] -}
2064d33de73fe81a81aea556e2003bda
  $wtopMod' ::
    [LexerTypes.BSVModuleDec]
    -> (# GHC.Base.String, GHC.Base.String, [LexerTypes.BSVModuleDec],
          GHC.Base.String, [LexerTypes.MidModInterfaceDec],
          [LexerTypes.ModuleAttribute], [LexerTypes.BSVstateDec],
          [LexerTypes.ActionDec], [LexerTypes.RuleDec],
          [LexerTypes.MethodBody] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f3927f90d81ecd8a32a70b049411c77d
  $wtypos ::
    [LexerTypes.InterfaceDec]
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> [LexerTypes.PVSType]
  {- Arity: 3,
     Strictness: <S,1*U><L,1*U(A,A,A,1*U,A,A,A,A,A,A)><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: [LexerTypes.InterfaceDec])
                   (w :: LexerTypes.BSVModuleDec)
                   (w1 :: GHC.Base.String) ->
                 case BSV2PVS.findInterface
                        ww
                        (LexerTypes.interfaceName w) of wild {
                   GHC.Base.Nothing
                   -> case BSV2PVS.typos2 ret_ty [LexerTypes.PVSType] of {}
                   GHC.Base.Just x
                   -> case x of wild1 { (,,,) ds x1 ds1 ds2 ->
                      case BSV2PVS.$wrightMeth x1 w1 of ww1 { (#,,,#) ww2 ww3 ww4 ww5 ->
                      GHC.Base.map
                        @ (LexerTypes.Name, LexerTypes.BSVType,
                           [LexerTypes.ArgumentAttribute])
                        @ LexerTypes.PVSType
                        BSV2PVS.typos1
                        ww4 } } }) -}
040fdbccdd5b6e179eb19e96e641b083
  $wunMaybeList :: [GHC.Base.Maybe a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
7fc0b75de70dafd471ebd9dab0503afc
  $wvectorProcess :: LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: LexerTypes.Expression) ->
                 case w of wild {
                   DEFAULT -> wild
                   LexerTypes.Identifier ds
                   -> case ds of wild1 {
                        DEFAULT -> wild
                        LexerTypes.ID_Vect n3 i
                        -> case GHC.List.elem
                                  @ GHC.Base.String
                                  GHC.Classes.$fEq[]_$s$fEq[]1
                                  n3
                                  (GHC.Types.[] @ GHC.Base.String) of wild2 {
                             GHC.Types.False
                             -> LexerTypes.BitSelect
                                  (LexerTypes.Identifier (LexerTypes.ID n3))
                                  i
                             GHC.Types.True -> wild } } }) -}
018624f6db0418b3fae2de9645f0b455
  $wweirdFold ::
    ([a] -> b -> (b, [a])) -> [a] -> [b] -> [b] -> (# [b], [a] #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U(1*U,1*U)))><L,U><S,1*U><L,U>, Inline: [0] -}
5fc37e76f93404156860257a2481cc3e
  addLVmoduleInfo ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> LexerTypes.LocalVar
    -> LexerTypes.LocalVar
  {- Arity: 4, Strictness: <L,A><L,A><L,U><S,1*U(U,U,1*U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ (u :: LexerTypes.BSVPackage)
                   (s :: LexerTypes.BSVModuleDec)
                   (p :: [GHC.Base.String])
                   (ds :: (LexerTypes.ID_Path,
                           Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType),
                           LexerTypes.Expression)) ->
                 case ds of wild { (,,) x y exp ->
                 (x, y, BSV2PVS.addModuleInfo u s p exp) }) -}
ffd5732d58121b8e801e4f4ec340c8ec
  addModuleInfo ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 4, Strictness: <L,A><L,A><L,U><S,1*U>, Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: LexerTypes.Expression) ->
                 BSV2PVS.$waddModuleInfo w2 w3) -}
9c99794d865c4b2d79463a8a36710ac8
  addPathToMethBody ::
    LexerTypes.MethodBody
    -> LexerTypes.ID_Path -> LexerTypes.MethodBody
  {- Arity: 2, Strictness: <S,1*U(U,U,U,1*U,1*U,U)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.MethodBody) (w1 :: LexerTypes.ID_Path) ->
                 case w of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 (ww1, ww2, ww3,
                  BSV2PVS.applyRootPrefix
                    (GHC.Base.map
                       @ (GHC.Base.String, GHC.Base.Maybe LexerTypes.BSVType)
                       @ [GHC.Types.Char]
                       (Data.Tuple.fst
                          @ GHC.Base.String
                          @ (GHC.Base.Maybe LexerTypes.BSVType))
                       ww3)
                    (BSV2PVS.idpath2strings w1)
                    ww4,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    (BSV2PVS.applyRootPrefixStmt
                       (GHC.Base.map
                          @ (GHC.Base.String, GHC.Base.Maybe LexerTypes.BSVType)
                          @ [GHC.Types.Char]
                          (Data.Tuple.fst
                             @ GHC.Base.String
                             @ (GHC.Base.Maybe LexerTypes.BSVType))
                          ww3)
                       (BSV2PVS.idpath2strings w1))
                    ww5,
                  ww6) }) -}
de8f95c1e8f683d14607bab3bbc1962f
  addStructPrefix ::
    LexerTypes.ID_Path
    -> [LexerTypes.TransitionTable] -> [LexerTypes.TransitionTable]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
58a79e5859be52cb0a0ca5d275d9db3e
  addTagModuleInfo ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> LexerTypes.MaybeTag
    -> LexerTypes.MaybeTag
  {- Arity: 4, Strictness: <L,A><L,A><L,U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ (u :: LexerTypes.BSVPackage)
                   (s :: LexerTypes.BSVModuleDec)
                   (p :: [GHC.Base.String])
                   (ds :: LexerTypes.MaybeTag) ->
                 case ds of wild {
                   LexerTypes.Valid x
                   -> LexerTypes.Valid (BSV2PVS.addModuleInfo u s p x)
                   LexerTypes.Invalid -> LexerTypes.Invalid
                   LexerTypes.MaybeContainer ipv -> BSV2PVS.addTagModuleInfo1 }) -}
2ab656cda3a897e3419f0edbd2c3eb14
  addTagModuleInfo1 :: LexerTypes.MaybeTag
  {- Strictness: x -}
42b69623d71dc7ecef51803648be2cb2
  addressesAllConflicts ::
    [GHC.Base.String]
    -> ([GHC.Base.String], [GHC.Base.String]) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
938fd9f38c4f5e4bbd2cd5bc6d9e7ed1
  addressesAllConflicts' ::
    [GHC.Base.String]
    -> [GHC.Base.String] -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
63fb6ae0f6604c3f2886150891e901b0
  amalgamateLets ::
    [LexerTypes.Statement]
    -> [LexerTypes.Statement] -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><L,U>m10, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.Statement]) (w1 :: [LexerTypes.Statement]) ->
                 case BSV2PVS.$wamalgamateLets w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 LexerTypes.LocalDec ww1 ww2 ww3 }) -}
dbc2ec42be220c45098ebfe226adfd26
  amalgamateLets1 :: LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.Statement) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.amalgamateLets2
                   LexerTypes.LocalDec ds1 x ds2 -> x }) -}
ff5546f012e2e45c67d6a5ca04146b95
  amalgamateLets2 :: LexerTypes.Statement
  {- Strictness: x -}
94f1fbc0a83fa42b83ce7acb3ea304e7
  amalgamateLets_go ::
    [LexerTypes.Statement] -> [LexerTypes.StatementAttribute]
  {- Arity: 1, Strictness: <S,1*U> -}
72943f8a41d898ddb4bf73133ce764ad
  amalgamateLets_go1 ::
    [LexerTypes.Statement] -> [LexerTypes.LocalVar]
  {- Arity: 1, Strictness: <S,1*U> -}
56e6b2c98815c3a9b3c8814a89e53475
  amalgamateRules ::
    [LexerTypes.RuleSchedule]
    -> ([LexerTypes.RuleSchedule],
        [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
    -> ([LexerTypes.RuleSchedule],
        [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.RuleSchedule])
                   (w1 :: ([LexerTypes.RuleSchedule],
                           [([LexerTypes.ActionPath], LexerTypes.ActionPath)])) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case BSV2PVS.$wamalgamateRules w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
77e85fd1c46a67b051a9bc040ba301f1
  amalgamateRules' ::
    [LexerTypes.RuleSchedule] -> [LexerTypes.RuleSchedule]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (rs :: [LexerTypes.RuleSchedule]) ->
                 case BSV2PVS.$wamalgamateRules
                        rs
                        (GHC.Types.[] @ LexerTypes.RuleSchedule)
                        (GHC.Types.[]
                           @ ([LexerTypes.ActionPath],
                              LexerTypes.ActionPath)) of ww { (#,#) ww1 ww2 ->
                 GHC.Base.map
                   @ LexerTypes.RuleSchedule
                   @ LexerTypes.RuleSchedule
                   (BSV2PVS.applyRepl'' ww2)
                   ww1 }) -}
a9b3504b4e03ab7e4eda5f55c33da069
  andChainExps :: [LexerTypes.Expression] -> LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U> -}
3568a30c17cd661b30d9d18bc8b86e6d
  ap2string :: LexerTypes.ActionPath -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (BSV2PVS.getAPPath) -}
88b21d231aa0e7de3f3ba9475b6cd006
  applyFieldAccesses ::
    LexerTypes.SpecificTree
    -> LexerTypes.ID_Path -> LexerTypes.SpecificTree
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
fa4b236acd22cb66e94cca22870b0245
  applyFieldAccessesXP ::
    LexerTypes.Expression
    -> LexerTypes.ID_Path -> LexerTypes.Expression
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: LexerTypes.Expression)
                   (id' :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   DEFAULT -> LexerTypes.FieldAccess wild id'
                   LexerTypes.Identifier id
                   -> let {
                        ns :: [GHC.Base.String] = BSV2PVS.idpath2strings id'
                      } in
                      let {
                        hs :: [GHC.Base.String]
                        = case BSV2PVS.$widpath2strings id of ww { (#,#) ww1 ww2 ->
                          GHC.Types.: @ GHC.Base.String ww1 ww2 }
                      } in
                      case Data.OldList.dropLengthMaybe
                             @ GHC.Base.String
                             @ GHC.Base.String
                             ns
                             hs of wild1 {
                        GHC.Base.Nothing -> LexerTypes.FieldAccess wild id'
                        GHC.Base.Just x
                        -> case GHC.Classes.$fEq[]_$s$c==1
                                  ns
                                  (Data.OldList.dropLength
                                     @ GHC.Base.String
                                     @ GHC.Base.String
                                     x
                                     hs) of wild2 {
                             GHC.Types.False -> LexerTypes.FieldAccess wild id'
                             GHC.Types.True -> wild } }
                   LexerTypes.Skip -> LexerTypes.Skip }) -}
4505e56712fed9dd49b60282f965be71
  applyIDPrefix ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
c6027a2f76ed4e9c4b1ed222dcfc351c
  applyInterfaceReferences ::
    [LexerTypes.InterfaceRef]
    -> LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (irefs :: [LexerTypes.InterfaceRef])
                   (x :: LexerTypes.ID_Path) ->
                 case GHC.List.elem
                        @ GHC.Base.String
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        (BSV2PVS.lastID x)
                        (GHC.Base.map
                           @ (LexerTypes.InterfaceName, GHC.Base.String)
                           @ [GHC.Types.Char]
                           (Data.Tuple.snd @ LexerTypes.InterfaceName @ GHC.Base.String)
                           irefs) of wild {
                   GHC.Types.False -> x GHC.Types.True -> BSV2PVS.idInit x }) -}
d76be42b2ba4fd298ed63d05ae7c38a0
  applyLocalDecs :: [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (xs :: [LexerTypes.Statement]) ->
                 case BSV2PVS.applyLocalDecs_go xs of wild {
                   [] -> BSV2PVS.removeVoids (BSV2PVS.rmLDecs xs)
                   : ds1 ds2
                   -> let {
                        lvars :: [LexerTypes.LocalVar] = BSV2PVS.crunchLDecs wild
                      } in
                      GHC.Base.map
                        @ LexerTypes.Statement
                        @ LexerTypes.Statement
                        (\ (stmt :: LexerTypes.Statement) ->
                         LexerTypes.LocalDec
                           lvars
                           stmt
                           (GHC.Types.[] @ LexerTypes.StatementAttribute))
                        (BSV2PVS.removeVoids (BSV2PVS.rmLDecs xs)) }) -}
ba1d5b6784c0b0be6387c012dea409c5
  applyLocalDecs_go ::
    [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a28cf78ed4bf0f69dbe1c90aff3c540e
  applyNumbering ::
    (GHC.Types.Int, LexerTypes.MethodBody) -> LexerTypes.MethodBody
  {- Arity: 1, Strictness: <S(LS),1*U(1*U(U),1*U(U,U,U,U,1*U,U))>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Types.Int, LexerTypes.MethodBody)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { (,,,,,) ww4 ww5 ww6 ww7 ww8 ww9 ->
                 case BSV2PVS.$wapplyNumbering
                        ww1
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9 of ww10 { (#,,,,,#) ww11 ww12 ww13 ww14 ww15 ww16 ->
                 (ww11, ww12, ww13, ww14, ww15, ww16) } } }) -}
ea7d58a8061a69b2f62f4384a2011fec
  applyNumbering1 ::
    ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)
    -> LexerTypes.Expression
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(1*U,A)>m25,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: ([GHC.Types.Char], GHC.Base.Maybe LexerTypes.BSVType)) ->
                 LexerTypes.Identifier
                   (LexerTypes.ID
                      (Data.Tuple.fst
                         @ [GHC.Types.Char]
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         x))) -}
e26492179adc431d6df1b7d13625737b
  applyNumbering2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_"#) -}
ceaea7f13a3151cccdd09f83ebaca12b
  applyNumbering_go ::
    [LexerTypes.Replacement]
    -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
98f04a0ce7547281d089bf36740569c4
  applyNumbering_go1 ::
    [(GHC.Base.String, GHC.Base.Maybe LexerTypes.BSVType)]
    -> [LexerTypes.Expression]
    -> [(LexerTypes.Expression, LexerTypes.Expression)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
2070b6de8cde0aba6ba972e6f05f78a2
  applyNumbersToArgs ::
    GHC.Types.Int
    -> [(GHC.Base.String, [(GHC.Base.String, LexerTypes.PVSType)])]
    -> [(GHC.Base.String, [(GHC.Base.String, LexerTypes.PVSType)])]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U> -}
c82de72e656df5b0106784bbd9ad34b5
  applyNumbersToArgs' ::
    GHC.Types.Int
    -> (GHC.Base.String, LexerTypes.PVSType)
    -> (GHC.Base.String, LexerTypes.PVSType)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U(1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: (GHC.Base.String, LexerTypes.PVSType)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 (GHC.Base.++
                    @ GHC.Types.Char
                    ww1
                    (GHC.CString.unpackAppendCString#
                       BSV2PVS.applyNumbering2
                       (case w of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4
                               (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })),
                  ww2) }) -}
0e0f84df30cbdca5296a8870022c2041
  applyNumbersToArgsCD ::
    GHC.Types.Int
    -> [(GHC.Base.String, [(GHC.Base.String, LexerTypes.PVSType)])]
    -> [(GHC.Base.String, [(GHC.Base.String, LexerTypes.PVSType)])]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U> -}
b62253e5b34fec77316b9aa3153a13b2
  applyRepl ::
    LexerTypes.ActionPath
    -> [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
    -> [LexerTypes.ActionPath]
    -> [LexerTypes.ActionPath]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><S,1*U>,
     Unfolding: (\ (nom :: LexerTypes.ActionPath)
                   (repls :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                   (xs :: [LexerTypes.ActionPath]) ->
                 letrec {
                   go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                           -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                       (eta :: [LexerTypes.ActionPath]) ->
                     case ds of wild {
                       []
                       -> Data.OldList.nubBy
                            @ LexerTypes.ActionPath
                            LexerTypes.$fEqActionPath_$c==
                            eta
                       : y ys -> go16 ys (BSV2PVS.applyRepl' nom y eta) }
                 } in
                 go16 repls xs) -}
3535cbd80a9ed9fdc6c29e0c5b1881eb
  applyRepl' ::
    LexerTypes.ActionPath
    -> ([LexerTypes.ActionPath], LexerTypes.ActionPath)
    -> [LexerTypes.ActionPath]
    -> [LexerTypes.ActionPath]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U(U,U)><S,1*U> -}
2cf82c3139be5c17ff36661418907bb2
  applyRepl'' ::
    [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
    -> LexerTypes.RuleSchedule -> LexerTypes.RuleSchedule
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: (\ (reps :: [([LexerTypes.ActionPath],
                              LexerTypes.ActionPath)])
                   (r :: LexerTypes.RuleSchedule) ->
                 LexerTypes.RuleSchedule
                   (LexerTypes.rName r)
                   (LexerTypes.rGuard r)
                   (LexerTypes.rStatements r)
                   (LexerTypes.implicitConditions r)
                   (LexerTypes.writesTo r)
                   (LexerTypes.dWireWrites r)
                   (LexerTypes.dWireReads r)
                   (LexerTypes.fifoEnqs r)
                   (LexerTypes.fifoDeqs r)
                   (LexerTypes.fifoClears r)
                   (LexerTypes.fifoFirsts r)
                   (LexerTypes.actionMethodsCalled r)
                   (case r of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                              -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                        <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                      = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                          (eta :: [LexerTypes.ActionPath]) ->
                        case ds of wild1 {
                          []
                          -> Data.OldList.nubBy
                               @ LexerTypes.ActionPath
                               LexerTypes.$fEqActionPath_$c==
                               eta
                          : y ys -> go16 ys (BSV2PVS.applyRepl' ds1 y eta) }
                    } in
                    go16 reps ds13 })
                   (case r of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                              -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                        <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                      = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                          (eta :: [LexerTypes.ActionPath]) ->
                        case ds of wild1 {
                          []
                          -> Data.OldList.nubBy
                               @ LexerTypes.ActionPath
                               LexerTypes.$fEqActionPath_$c==
                               eta
                          : y ys -> go16 ys (BSV2PVS.applyRepl' ds1 y eta) }
                    } in
                    go16 reps ds14 })
                   (case r of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                              -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                        <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                      = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                          (eta :: [LexerTypes.ActionPath]) ->
                        case ds of wild1 {
                          []
                          -> Data.OldList.nubBy
                               @ LexerTypes.ActionPath
                               LexerTypes.$fEqActionPath_$c==
                               eta
                          : y ys -> go16 ys (BSV2PVS.applyRepl' ds1 y eta) }
                    } in
                    go16 reps ds15 })
                   (case r of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                              -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                        <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                      = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                          (eta :: [LexerTypes.ActionPath]) ->
                        case ds of wild1 {
                          []
                          -> Data.OldList.nubBy
                               @ LexerTypes.ActionPath
                               LexerTypes.$fEqActionPath_$c==
                               eta
                          : y ys -> go16 ys (BSV2PVS.applyRepl' ds1 y eta) }
                    } in
                    go16 reps ds16 })
                   (case r of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                              -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                        <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                      = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                          (eta :: [LexerTypes.ActionPath]) ->
                        case ds of wild1 {
                          []
                          -> Data.OldList.nubBy
                               @ LexerTypes.ActionPath
                               LexerTypes.$fEqActionPath_$c==
                               eta
                          : y ys -> go16 ys (BSV2PVS.applyRepl' ds1 y eta) }
                    } in
                    go16 reps ds17 })
                   (case r of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go16 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
                              -> [LexerTypes.ActionPath] -> [LexerTypes.ActionPath]
                        <join 2> {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                      = \ (ds :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)])
                          (eta :: [LexerTypes.ActionPath]) ->
                        case ds of wild1 {
                          []
                          -> Data.OldList.nubBy
                               @ LexerTypes.ActionPath
                               LexerTypes.$fEqActionPath_$c==
                               eta
                          : y ys -> go16 ys (BSV2PVS.applyRepl' ds1 y eta) }
                    } in
                    go16 reps ds18 })) -}
7bea09a1197798b511a17aa8c7cb3b19
  applyReplacement ::
    [LexerTypes.Replacement]
    -> LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (reps :: [LexerTypes.Replacement])
                   (rule :: LexerTypes.RuleDec) ->
                 letrec {
                   go16 :: [LexerTypes.Replacement]
                           -> LexerTypes.RuleDec -> LexerTypes.RuleDec
                     <join 2> {- Arity: 2 -}
                   = \ (ds :: [LexerTypes.Replacement]) (eta :: LexerTypes.RuleDec) ->
                     case ds of wild {
                       [] -> eta : y ys -> go16 ys (BSV2PVS.applyReplacement' y eta) }
                 } in
                 go16 reps rule) -}
eb8c4f3d737b26e2f154a1f4884a134a
  applyReplacement' ::
    LexerTypes.Replacement -> LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U(U,U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (rep :: LexerTypes.Replacement)
                   (ds :: (LexerTypes.RuleName, LexerTypes.Guard,
                           [LexerTypes.Statement], [LexerTypes.RuleAttribute])) ->
                 case ds of wild { (,,,) x y stmts z ->
                 (x, y,
                  GHC.Base.build
                    @ LexerTypes.Statement
                    (\ @ b1
                       (c :: LexerTypes.Statement -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ LexerTypes.Statement
                       @ b1
                       (GHC.Base.mapFB
                          @ LexerTypes.Statement
                          @ b1
                          @ LexerTypes.Statement
                          c
                          (BSV2PVS.applyReplacementStmt rep))
                       n3
                       stmts),
                  z) }) -}
cc7aeee3558cddf7d7a8eaa20370a446
  applyReplacementCase ::
    LexerTypes.Replacement -> LexerTypes.Case -> LexerTypes.Case
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (rep :: LexerTypes.Replacement)
                   (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) x stmt ->
                 (x, BSV2PVS.applyReplacementStmt rep stmt) }) -}
06f89af14be10de4d0fe5fb9de5cf550
  applyReplacementExp ::
    LexerTypes.Replacement
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.Replacement) (w1 :: LexerTypes.Expression) ->
                 case w of ww { (,) ww1 ww2 ->
                 BSV2PVS.$wapplyReplacementExp ww1 ww2 w1 }) -}
bde50a942f51150de34ce4a3e63e80b7
  applyReplacementStmt ::
    LexerTypes.Replacement
    -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U> -}
f763b0c4a8844365a786c3f3259ef5c3
  applyReplacementUStmt ::
    LexerTypes.Replacement
    -> LexerTypes.UStatement -> LexerTypes.UStatement
  {- Arity: 2, Strictness: <L,1*U(U,U)><S,1*U>,
     Unfolding: (\ (rep :: LexerTypes.Replacement)
                   (ds :: LexerTypes.UStatement) ->
                 case ds of wild {
                   LexerTypes.DeclAssign x y exp
                   -> LexerTypes.DeclAssign x y (BSV2PVS.applyReplacementExp rep exp)
                   LexerTypes.UAssign x exp
                   -> LexerTypes.UAssign x (BSV2PVS.applyReplacementExp rep exp) }) -}
a2a8104e6632fe41b1b09a9907f48c06
  applyReplacements ::
    [LexerTypes.Replacement]
    -> [LexerTypes.RuleDec] -> [LexerTypes.RuleDec]
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (reps :: [LexerTypes.Replacement])
                   (ruls :: [LexerTypes.RuleDec]) ->
                 GHC.Base.build
                   @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                      [LexerTypes.RuleAttribute])
                   (\ @ b1
                      (c :: (LexerTypes.RuleName, LexerTypes.Guard,
                             [LexerTypes.Statement], [LexerTypes.RuleAttribute])
                            -> b1 -> b1)[OneShot]
                      (n3 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                         [LexerTypes.RuleAttribute])
                      @ b1
                      (GHC.Base.mapFB
                         @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                            [LexerTypes.RuleAttribute])
                         @ b1
                         @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                            [LexerTypes.RuleAttribute])
                         c
                         (BSV2PVS.applyReplacement reps))
                      n3
                      ruls)) -}
012ccb3e91c470654b209bad81593588
  applyRootPrefix ::
    [LexerTypes.MethodArg]
    -> [GHC.Base.String]
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U> -}
ae82b15bbbba1dde3a4808d944a387a1
  applyRootPrefix' ::
    LexerTypes.ID_Path -> [GHC.Base.String] -> LexerTypes.ID_Path
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
59a66772d2253d2d83168a5faa63e525
  applyRootPrefixStmt ::
    [LexerTypes.MethodArg]
    -> [GHC.Base.String]
    -> LexerTypes.Statement
    -> LexerTypes.Statement
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U> -}
2886cf64657ca93eec5bf2678936eeac
  applyRootPrefixStmts ::
    [LexerTypes.MethodArg]
    -> [GHC.Base.String]
    -> [LexerTypes.Statement]
    -> [LexerTypes.Statement]
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (args :: [LexerTypes.MethodArg])
                   (prefix :: [GHC.Base.String])
                   (eta :: [LexerTypes.Statement]) ->
                 GHC.Base.build
                   @ LexerTypes.Statement
                   (\ @ b1
                      (c :: LexerTypes.Statement -> b1 -> b1)[OneShot]
                      (n3 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ LexerTypes.Statement
                      @ b1
                      (GHC.Base.mapFB
                         @ LexerTypes.Statement
                         @ b1
                         @ LexerTypes.Statement
                         c
                         (BSV2PVS.applyRootPrefixStmt args prefix))
                      n3
                      eta)) -}
c59d54de814aa1d27fc1319dbe94ab59
  arbitrateRuleSchemes ::
    [LexerTypes.RuleSchedule]
    -> [LexerTypes.RuleSchedule] -> LexerTypes.RuleSchedule
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: [LexerTypes.RuleSchedule])
                   (x :: [LexerTypes.RuleSchedule]) ->
                 case ds of wild {
                   [] -> BSV2PVS.arbitrateRuleSchemes3 x
                   : ipv ipv1
                   -> case x of wild1 {
                        [] -> BSV2PVS.arbitrateRuleSchemes2 wild
                        : ipv2 ipv3
                        -> let {
                             both :: [LexerTypes.RuleSchedule]
                             = Data.OldList.intersectBy
                                 @ LexerTypes.RuleSchedule
                                 LexerTypes.$fEqRuleSchedule_$c==
                                 wild
                                 wild1
                           } in
                           case GHC.List.$wlenAcc
                                  @ LexerTypes.RuleSchedule
                                  both
                                  0# of ww2 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww2 1#) of wild2 {
                             GHC.Types.False -> BSV2PVS.arbitrateRuleSchemes1 wild wild1
                             GHC.Types.True
                             -> GHC.List.head @ LexerTypes.RuleSchedule both } } } }) -}
9285d2d1a52ad366d1d0fe1d913caee4
  arbitrateRuleSchemes1 ::
    [LexerTypes.RuleSchedule]
    -> [LexerTypes.RuleSchedule] -> LexerTypes.RuleSchedule
  {- Arity: 2, Strictness: <B,1*U><B,1*U>x -}
40e04afb542861d5da32c06d44ef4f6a
  arbitrateRuleSchemes2 ::
    [LexerTypes.RuleSchedule] -> LexerTypes.RuleSchedule
  {- Arity: 1, Strictness: <B,1*U>x -}
a97cc4fd8559edc4747df4eedd902d98
  arbitrateRuleSchemes3 ::
    [LexerTypes.RuleSchedule] -> LexerTypes.RuleSchedule
  {- Arity: 1, Strictness: <B,1*U>x -}
fa0e53ff697cab6c7024dc5031ee986c
  b2pArgument :: LexerTypes.Argument -> LexerTypes.PVSArgument
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.Name, LexerTypes.BSVType,
                           [LexerTypes.ArgumentAttribute])) ->
                 case ds of wild { (,,) nom typ ds1 ->
                 (nom, BSV2PVS.b2pType typ) }) -}
57a2f9f0ac6ce32ece21e5308f761e62
  b2pConstDecl ::
    LexerTypes.BSVConstantDec -> LexerTypes.PVSConstantDec
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.Name, LexerTypes.BSVType,
                           LexerTypes.Literal)) ->
                 case ds of wild { (,,) nom typ lit ->
                 (nom, BSV2PVS.b2pType typ, lit) }) -}
cea3971bd28e8f978a6190fef0a06160
  b2pFuncs :: LexerTypes.BSVFunction -> LexerTypes.PVSFunction
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVFunction) ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1,
                  GHC.Base.map
                    @ (LexerTypes.Name, LexerTypes.BSVType,
                       [LexerTypes.ArgumentAttribute])
                    @ (GHC.Base.String, LexerTypes.PVSType)
                    BSV2PVS.b2pArgument
                    ww2,
                  BSV2PVS.b2pType ww3,
                  BSV2PVS.extractExpression
                    (GHC.Types.[] @ LexerTypes.MethodArg)
                    BSV2PVS.b2pFuncs1
                    (GHC.Types.[] @ GHC.Base.String)
                    (BSV2PVS.resolveMultipleStatements ww4)) }) -}
fd50ab8cbc22c12102bc133dfe883dce
  b2pFuncs1 :: LexerTypes.ID_Path
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (LexerTypes.ID (GHC.Types.[] @ GHC.Types.Char)) -}
a57b4006464d15cb8ff75eb3ec417163
  b2pInstDef ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVInstDef -> LexerTypes.PVSInstDef
  {- Arity: 2,
     Strictness: <L,U(A,A,A,A,A,U,A,A,A,A,A)><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (pkg :: LexerTypes.BSVPackage)
                   (ds :: (LexerTypes.Name,
                           [(LexerTypes.Name, LexerTypes.Literal)])) ->
                 case ds of wild { (,) x ys ->
                 (x,
                  GHC.Base.build
                    @ (LexerTypes.Name, LexerTypes.Expression)
                    (\ @ b1
                       (c :: (LexerTypes.Name, LexerTypes.Expression)
                             -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (LexerTypes.Name, LexerTypes.Expression)
                       @ b1
                       (GHC.Base.mapFB
                          @ (LexerTypes.Name, LexerTypes.Expression)
                          @ b1
                          @ (LexerTypes.Name, LexerTypes.Expression)
                          c
                          (BSV2PVS.b2pInstDef' pkg x))
                       n3
                       ys)) }) -}
08c826f4f303f503e344fdec491572d2
  b2pInstDef' ::
    LexerTypes.BSVPackage
    -> LexerTypes.Name
    -> (LexerTypes.Name, LexerTypes.Expression)
    -> (LexerTypes.Name, LexerTypes.Expression)
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,A,1*U,A,A,A,A,A)><L,U><S(LS),1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.Name)
                   (w2 :: (LexerTypes.Name, LexerTypes.Expression)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case ww2 of wild {
                   DEFAULT -> (ww1, wild)
                   LexerTypes.Identifier ds
                   -> case ds of wild1 {
                        DEFAULT -> (ww1, wild)
                        LexerTypes.ID ds1
                        -> case GHC.Base.eqString ds1 BSV2PVS.b2pInstDef'3 of wild2 {
                             GHC.Types.False -> (ww1, wild)
                             GHC.Types.True
                             -> (ww1,
                                 case w of wild3 { LexerTypes.BSVPackage ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ->
                                 case BSV2PVS.$wgetTypeDef ds7 w1 of ww3 { (#,#) ww4 ww5 ->
                                 case GHC.List.lookup
                                        @ LexerTypes.Name
                                        @ LexerTypes.BSVType
                                        GHC.Classes.$fEq[]_$s$fEq[]1
                                        ww1
                                        ww5 of wild4 {
                                   GHC.Base.Nothing
                                   -> case BSV2PVS.b2pInstDef'2 ret_ty LexerTypes.Expression of {}
                                   GHC.Base.Just x
                                   -> case x of wild5 {
                                        DEFAULT -> BSV2PVS.b2pInstDef'1
                                        LexerTypes.BSV_Custom x1
                                        -> LexerTypes.Identifier
                                             (LexerTypes.ID
                                                (GHC.CString.unpackAppendCString#
                                                   "mk"#
                                                   x1)) } } } }) } } } }) -}
00d3fbb4bf044de5bfd1219ff587d8d2
  b2pInstDef'1 :: LexerTypes.Expression
  {- Strictness: x -}
bc6a71d09c4d1431e25bc8c97a306864
  b2pInstDef'2 :: LexerTypes.BSVType
  {- Strictness: x -}
159380a5817f4055118c5ca094ae9f0c
  b2pInstDef'3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# BSV2PVS.b2pInstDef'4) -}
92a481c7e53bc6fc197eb373b88d5e98
  b2pInstDef'4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("defaultValue"#) -}
7e19df47547cfd05f15ca84e0caaa75e
  b2pState :: LexerTypes.BSVstateDec -> [LexerTypes.PVSstate]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVstateDec) ->
                 case w of wild {
                   LexerTypes.BSV_Reg ds ds1 i
                   -> case ds of wild1 {
                        DEFAULT
                        -> GHC.Types.:
                             @ LexerTypes.PVSstate
                             (LexerTypes.PVS_Reg wild1 (BSV2PVS.b2pType ds1) i)
                             (GHC.Types.[] @ LexerTypes.PVSstate)
                        LexerTypes.ID n3
                        -> case ds1 of wild2 {
                             DEFAULT
                             -> GHC.Types.:
                                  @ LexerTypes.PVSstate
                                  (LexerTypes.PVS_Reg wild1 (BSV2PVS.b2pType wild2) i)
                                  (GHC.Types.[] @ LexerTypes.PVSstate)
                             LexerTypes.BSV_Custom t
                             -> case LexerTypes.$fEqExpression_$c==
                                       i
                                       BSV2PVS.b2pState2 of wild3 {
                                  GHC.Types.False
                                  -> GHC.Types.:
                                       @ LexerTypes.PVSstate
                                       (LexerTypes.PVS_Reg
                                          (LexerTypes.ID n3)
                                          (BSV2PVS.b2pType (LexerTypes.BSV_Custom t))
                                          i)
                                       (GHC.Types.[] @ LexerTypes.PVSstate)
                                  GHC.Types.True
                                  -> GHC.Types.:
                                       @ LexerTypes.PVSstate
                                       (LexerTypes.PVS_SubModuleDec
                                          t
                                          (GHC.Types.[] @ GHC.Types.Char)
                                          n3)
                                       (GHC.Types.[] @ LexerTypes.PVSstate) } } }
                   LexerTypes.BSV_Fifo f n3 t
                   -> GHC.Types.:
                        @ LexerTypes.PVSstate
                        (LexerTypes.PVS_Fifo f n3 (BSV2PVS.b2pType t))
                        (GHC.Types.[] @ LexerTypes.PVSstate)
                   LexerTypes.BSV_Vector n3 t s i
                   -> GHC.Types.:
                        @ LexerTypes.PVSstate
                        (LexerTypes.PVS_Vector n3 (BSV2PVS.b2pType t) s i)
                        (GHC.Types.[] @ LexerTypes.PVSstate)
                   LexerTypes.BSV_RegFile ipv ipv1 ipv2 ipv3 -> BSV2PVS.b2pState1
                   LexerTypes.BSV_SubModuleDec i1 n3 i2
                   -> GHC.Types.:
                        @ LexerTypes.PVSstate
                        (LexerTypes.PVS_SubModuleDec i1 n3 i2)
                        (GHC.Types.[] @ LexerTypes.PVSstate)
                   LexerTypes.DWire n3 t i
                   -> GHC.Types.:
                        @ LexerTypes.PVSstate
                        (LexerTypes.PVS_DWire n3 (BSV2PVS.b2pType t) i)
                        (GHC.Types.[] @ LexerTypes.PVSstate) }) -}
e2ec286a5a84bd567ffff06abc74bbbb
  b2pState1 :: [LexerTypes.PVSstate]
  {- Strictness: x -}
9666884eff205f5f2eea231789174d97
  b2pState2 :: LexerTypes.Expression
  {- HasNoCafRefs, Strictness: m24,
     Unfolding: (LexerTypes.Literal LexerTypes.LitStructConstructor) -}
84584b9f540db168752a22b3004daabc
  b2pStateDecs :: LexerTypes.BSVPackage -> [LexerTypes.PVSstateDec]
  {- Arity: 1,
     Strictness: <S(LLLLLLLSLLL),1*U(A,A,A,A,A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (universe :: LexerTypes.BSVPackage) ->
                 case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                 GHC.Base.build
                   @ (GHC.Base.String, [LexerTypes.PVSstate])
                   (\ @ b1
                      (c :: (GHC.Base.String, [LexerTypes.PVSstate])
                            -> b1 -> b1)[OneShot]
                      (n3 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ LexerTypes.BSVModuleDec
                      @ b1
                      (GHC.Base.mapFB
                         @ (GHC.Base.String, [LexerTypes.PVSstate])
                         @ b1
                         @ LexerTypes.BSVModuleDec
                         c
                         BSV2PVS.b2pStateDecs1)
                      n3
                      ds8) }) -}
c6f30b14993bf42e5ea7c14cb683f5e6
  b2pStateDecs1 ::
    LexerTypes.BSVModuleDec -> (GHC.Base.String, [LexerTypes.PVSstate])
  {- Arity: 1, Strictness: <L,U(1*U,A,A,A,A,A,1*U,A,A,A)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 (LexerTypes.mName w,
                  case w of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                  BSV2PVS.b2pStateDecs_go ds7 })) -}
1acda3a2f9f4d32e3a33645c36e3ad34
  b2pStateDecs_go ::
    [LexerTypes.BSVstateDec] -> [LexerTypes.PVSstate]
  {- Arity: 1, Strictness: <S,1*U> -}
caee861dd3ab6de34f42926e8cf92d69
  b2pType :: LexerTypes.BSVType -> LexerTypes.PVSType
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d827b118812e64d9ce0be7bf80bc6c3d
  b2pTypeDef :: LexerTypes.BSVTypeDef -> LexerTypes.PVSTypeDef
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.BSVTypeDef) ->
                 case ds of wild {
                   LexerTypes.BSV_Synonym nom typ
                   -> LexerTypes.PVS_Synonym nom (BSV2PVS.b2pType typ)
                   LexerTypes.BSV_Enumeration nom enums
                   -> LexerTypes.PVS_Enumeration nom enums
                   LexerTypes.BSV_Struct nom fields
                   -> LexerTypes.PVS_Struct
                        nom
                        (GHC.Base.map
                           @ (LexerTypes.Name, LexerTypes.BSVType)
                           @ (LexerTypes.Name, LexerTypes.PVSType)
                           BSV2PVS.b2pTypeDef1
                           fields) }) -}
6b4134ca46bbd77fb03317ae4fae0048
  b2pTypeDef1 ::
    (LexerTypes.Name, LexerTypes.BSVType)
    -> (LexerTypes.Name, LexerTypes.PVSType)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.Name, LexerTypes.BSVType)) ->
                 case ds of wild { (,) x y -> (x, BSV2PVS.b2pType y) }) -}
0bd517946d8b462af0565efd7d1ac47a
  bsv2pvs ::
    LexerTypes.BSVPackage
    -> GHC.Base.Maybe GHC.Base.String
    -> [[LexerTypes.ID_Path]]
    -> LexerTypes.PVSPackage
  {- Arity: 3, Strictness: <L,U(U,A,A,U,U,U,U,U,U,A,A)><S,1*U><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: GHC.Base.Maybe GHC.Base.String)
                   (w2 :: [[LexerTypes.ID_Path]]) ->
                 case BSV2PVS.$wbsv2pvs
                        w
                        w1
                        w2 of ww { (#,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 LexerTypes.PVSPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 }) -}
37f8e86c23241b9943a52b5a36e21b2b
  bubbleUpLets ::
    [LexerTypes.Statement]
    -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
244d22966b4050725aac288a88c4b229
  check4imps :: [LexerTypes.RuleAttribute] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f1f55ab7690843cf69465f66a8900ac1
  cleanup ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.Statement -> GHC.Base.Maybe LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U> -}
330151cc9d1404dee5b46e311e4d105c
  collateMods ::
    [GHC.Base.Maybe LexerTypes.BSVModuleDec]
    -> [LexerTypes.BSVModuleDec]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f7a51f0dc0b158ba492bf9d9ff9f7f32
  combineLDecs ::
    LexerTypes.LocalVar
    -> [LexerTypes.Statement] -> LexerTypes.LocalVar
  {- Arity: 2, Strictness: <S,1*U(U,U,U)><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.LocalVar) (w1 :: [LexerTypes.Statement]) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case BSV2PVS.$wcombineLDecs
                        ww1
                        ww2
                        ww3
                        w1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 (ww5, ww6, ww7) } }) -}
eb7ca554388e4fb3e6df59bb18b9ebe8
  condenseLDecs ::
    LexerTypes.LocalVar
    -> [LexerTypes.Statement] -> LexerTypes.LocalVar
  {- Arity: 2, Strictness: <S,1*U(U,U,U)><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.LocalVar) (w1 :: [LexerTypes.Statement]) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case BSV2PVS.$wcondenseLDecs
                        ww1
                        ww2
                        ww3
                        w1 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 (ww5, ww6, ww7) } }) -}
310e9c7b75b1a0fbdf4d6b0f5041d346
  consolidateLDecs :: LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U> -}
1d2344a7ab616c5612a2c5b7c6aece4a
  constructDefaultValue ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.BSVType
    -> LexerTypes.Expression
  {- Arity: 3,
     Strictness: <S(LLLLLLSLLLL),1*U(A,A,A,A,A,A,1*U,A,A,A,A)><L,A><S,U>m38,
     Unfolding: InlineRule (3, True, False)
                (\ (uni :: LexerTypes.BSVPackage)
                   (mod :: LexerTypes.BSVModuleDec)
                   (t :: LexerTypes.BSVType) ->
                 case uni of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                 case BSV2PVS.lookupInst' ds7 t of wild1 { (,) n3 fs ->
                 LexerTypes.StructCluster
                   (Data.Either.Right
                      @ LexerTypes.BSVType
                      @ LexerTypes.PVSType
                      (BSV2PVS.b2pType t))
                   fs } }) -}
bdd1fab3f596599d9f12e2ed58c9c48b
  containsLVarDec :: LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
30bab428b259c4d04aea0700a8a9eda2
  convertMethodToRule ::
    LexerTypes.MethodBody -> GHC.Base.Maybe LexerTypes.RuleDec
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLL),1*U(U,1*U,A,U,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) x ds1 ds2 y z ds3 ->
                 case ds1 of wild1 {
                   DEFAULT
                   -> GHC.Base.Just
                        @ (LexerTypes.MethodName, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.RuleAttribute])
                        (x, y, z, GHC.Types.[] @ LexerTypes.RuleAttribute)
                   LexerTypes.Value ds4
                   -> GHC.Base.Nothing @ LexerTypes.RuleDec } }) -}
2b51e2d15314678d4b935203037441a5
  convertMethodToRule' :: LexerTypes.MethodBody -> LexerTypes.RuleDec
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A,A,U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) x ds1 ds2 y z ds3 ->
                 (x, y, z, GHC.Types.[] @ LexerTypes.RuleAttribute) }) -}
90345577d2e23c92c8b1e57aaacd206b
  convertModAttsR ::
    [LexerTypes.RuleAttribute] -> [LexerTypes.ModuleAttribute]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
86f5f218c8717b2f337f441bc7528400
  convertModAttsS ::
    [LexerTypes.StatementAttribute] -> [LexerTypes.RuleAttribute]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7a1c5bb4c628f4d826edd3f431cdb109
  convertToFunction ::
    LexerTypes.BSVPackage
    -> [LexerTypes.TransitionTable]
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> LexerTypes.MethodBody
    -> LexerTypes.ValueMethod
  {- Arity: 6,
     Strictness: <L,A><L,A><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><S(LSLLLL),1*U(U,1*U,A,1*U,1*U,A)>m,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: [LexerTypes.TransitionTable])
                   (w2 :: LexerTypes.BSVModuleDec)
                   (w3 :: GHC.Base.String)
                   (w4 :: [GHC.Base.String])
                   (w5 :: LexerTypes.MethodBody) ->
                 case w5 of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case BSV2PVS.$wconvertToFunction
                        w2
                        w3
                        w4
                        ww1
                        ww2
                        ww4
                        ww5 of ww7 { (#,,,,,,#) ww8 ww9 ww10 ww11 ww12 ww13 ww14 ->
                 (ww8, ww9, ww10, ww11, ww12, ww13, ww14) } }) -}
ae112511a5cace6cab5980e37f796f20
  convertToFunction1 :: LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: LexerTypes.ID_Path) -> GHC.Types.True) -}
df64de64bf5de6e85c0c75c61d237df2
  convertToFunction2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   BSV2PVS.convertToFunction3
                   (GHC.Types.[] @ GHC.Base.String)) -}
b955ec381c4959f4762e051956ac34f3
  convertToFunction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.convertToFunction4) -}
19f76eca4f5786e52c6495b9df100567
  convertToFunction4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("mod"#) -}
81e207f26974e2911c8bc1613f4ee96b
  convertToFunction5 :: LexerTypes.Expression
  {- Strictness: x -}
e35a7256488b0d757ab73c8e3475d000
  convertToFunction6 :: LexerTypes.ValueMethod
  {- Strictness: x -}
6ba481a7631ed846e7318f67e17f6a6e
  convertVectors ::
    LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 case BSV2PVS.$wconvertVectors
                        w of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 }) -}
afa7c3eba9d426ade47813e73a54d488
  crunchLDecs :: [LexerTypes.Statement] -> [LexerTypes.LocalVar]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
5e4b5076a45607dd4805b00845dd8f19
  crushModAttsCases :: LexerTypes.Case -> LexerTypes.Case
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) x y -> (x, BSV2PVS.crushModAttsS y) }) -}
78f9832156e5f698d39f1c62eb8fb6a7
  crushModAttsR :: LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.RuleName, LexerTypes.Guard,
                           [LexerTypes.Statement], [LexerTypes.RuleAttribute])) ->
                 case ds of wild { (,,,) x y z atts ->
                 (x, y, z, BSV2PVS.crushModAttsRA atts) }) -}
35bb8e7591fd79f63d151735a6a80035
  crushModAttsRA ::
    [LexerTypes.RuleAttribute] -> [LexerTypes.RuleAttribute]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
5b44866ed780df661402aafd925f8caa
  crushModAttsS :: LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U> -}
def5ddc9a718ba7b67bae1abca92f88c
  crushModAttsSA ::
    [LexerTypes.StatementAttribute] -> [LexerTypes.StatementAttribute]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8f6aa8e9966ca44c84115df9f5c34df8
  cvAct ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.ActionDec -> LexerTypes.ActionDec
  {- Arity: 2, Strictness: <L,U><S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (st :: [LexerTypes.BSVstateDec])
                   (ds :: (LexerTypes.ActionName, [LexerTypes.Statement],
                           [LexerTypes.ActionAttribute])) ->
                 case ds of wild { (,,) x y z ->
                 (x,
                  GHC.Base.build
                    @ LexerTypes.Statement
                    (\ @ b1
                       (c :: LexerTypes.Statement -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ LexerTypes.Statement
                       @ b1
                       (GHC.Base.mapFB
                          @ LexerTypes.Statement
                          @ b1
                          @ LexerTypes.Statement
                          c
                          (BSV2PVS.cvStmt st))
                       n3
                       y),
                  z) }) -}
89566704a26cca56894a51274f5bde12
  cvExp ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
64de28d975aa2843bb7f7c3dbf6941ee
  cvID ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.ID_Path
    -> [GHC.Base.String]
    -> Data.Either.Either LexerTypes.Expression LexerTypes.ID_Path
  {- Arity: 3, Strictness: <L,1*U><S,1*U><L,1*U> -}
ff83afb06e9933f9c53e8849ccf62c99
  cvInter ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.MidModInterfaceDec -> LexerTypes.MidModInterfaceDec
  {- Arity: 2, Strictness: <L,U><S,1*U(U,U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (st :: [LexerTypes.BSVstateDec])
                   (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y ms ->
                 (x, y,
                  GHC.Base.build
                    @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                       LexerTypes.Guard, [LexerTypes.Statement],
                       [LexerTypes.MethodBodyAttribute])
                    (\ @ b1
                       (c :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                              LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                              [LexerTypes.MethodBodyAttribute])
                             -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                          LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.MethodBodyAttribute])
                       @ b1
                       (GHC.Base.mapFB
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          @ b1
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          c
                          (BSV2PVS.cvMet st))
                       n3
                       ms)) }) -}
2cb2ff80a3dc4a7b3dd73652c26c080c
  cvMet ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.MethodBody -> LexerTypes.MethodBody
  {- Arity: 2, Strictness: <L,U><S,1*U(U,U,U,1*U,1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVstateDec]) (w1 :: LexerTypes.MethodBody) ->
                 case w1 of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 (ww1, ww2, ww3, BSV2PVS.cvExp w ww4,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    (BSV2PVS.cvStmt w)
                    ww5,
                  ww6) }) -}
20486f54aed6ed5a3e1e865deeb6def2
  cvRul ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 2, Strictness: <L,U><S,1*U(U,1*U,1*U,U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVstateDec]) (w1 :: LexerTypes.RuleDec) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1, BSV2PVS.cvExp w ww2,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    (BSV2PVS.cvStmt w)
                    ww3,
                  ww4) }) -}
00767d918ca2c439b23bcff9eccc1caa
  cvStmt ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
a3d862478de5474b3744bbd33bcfb282
  deReferenceStructure ::
    GHC.Base.String
    -> LexerTypes.TransitionTable -> LexerTypes.TransitionTable
  {- Arity: 2, Strictness: <S,U><S,U> -}
1d8b34d253a10d5584f96c87ff192e54
  deStruct :: [LexerTypes.RuleSchedule] -> [LexerTypes.RuleSchedule]
  {- Arity: 1, Strictness: <S,1*U> -}
d21e0abf77bef9eb6bf5e3da01e7c2cf
  def2exp ::
    LexerTypes.BSVInstDef
    -> LexerTypes.BSVType -> LexerTypes.Expression
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U)><L,1*U>m38,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (LexerTypes.Name,
                           [(LexerTypes.Name, LexerTypes.Literal)]))
                   (t :: LexerTypes.BSVType) ->
                 case ds of wild { (,) n3 fs ->
                 LexerTypes.StructCluster
                   (Data.Either.Right
                      @ LexerTypes.BSVType
                      @ LexerTypes.PVSType
                      (BSV2PVS.b2pType t))
                   fs }) -}
d018edc3642f5ae5c4365fec83a3b546
  dinvExp ::
    [LexerTypes.Argument]
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: [LexerTypes.Argument]) (w1 :: LexerTypes.Expression) ->
                 BSV2PVS.$wdinvExp w1) -}
9544cf017fba7d63863ed2821d9dbbc8
  dinvFunc :: LexerTypes.BSVFunction -> LexerTypes.BSVFunction
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Base.String, [LexerTypes.Argument],
                           LexerTypes.BSVType, [LexerTypes.Statement])) ->
                 case ds of wild { (,,,) n3 args typ stmts ->
                 (n3, args, typ,
                  GHC.Base.build
                    @ LexerTypes.Statement
                    (\ @ b1
                       (c :: LexerTypes.Statement -> b1 -> b1)[OneShot]
                       (n4 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ LexerTypes.Statement
                       @ b1
                       (GHC.Base.mapFB
                          @ LexerTypes.Statement
                          @ b1
                          @ LexerTypes.Statement
                          c
                          (BSV2PVS.dinvStmt args))
                       n4
                       stmts)) }) -}
c0c06e6946db406e659107c50507798d
  dinvStmt ::
    [LexerTypes.Argument]
    -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: [LexerTypes.Argument]) (w1 :: LexerTypes.Statement) ->
                 BSV2PVS.$wdinvStmt w1) -}
bdb824256cc4283043c842a8e8f805e6
  elemWith ::
    GHC.Classes.Eq a =>
    a -> [a] -> (a -> a -> GHC.Types.Bool) -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,A><L,U><S,1*U><L,C(C1(U))>, Inline: [0],
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: a)
                   (w2 :: [a])
                   (w3 :: a -> a -> GHC.Types.Bool) ->
                 BSV2PVS.$welemWith @ a w1 w2 w3) -}
1616b915c1a5d9e4d57254aadf42061c
  elemWith_$selemWith ::
    LexerTypes.ID_Path
    -> [LexerTypes.ID_Path]
    -> (LexerTypes.ID_Path -> LexerTypes.ID_Path -> GHC.Types.Bool)
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,C(C1(U))> -}
3a34186e7374048f0b96fa29678851ff
  elemWith_$selemWith1 ::
    GHC.Base.String
    -> [GHC.Base.String]
    -> (GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,C(C1(U))> -}
7f9eb0d6ad13d0b174b35ce4caa450db
  eliminateSingletonSBs ::
    LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U> -}
47db1b26c8dc64a4242f1d89fbb01c8d
  encapsulateUrgs ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [([GHC.Base.String], [GHC.Base.String])]
    -> ([LexerTypes.ActionPath], [LexerTypes.ActionPath])
  {- Arity: 4, Strictness: <L,A><L,A><L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [([GHC.Base.String], [GHC.Base.String])]) ->
                 case BSV2PVS.$wencapsulateUrgs w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
a8ad3f89aa2d58ecefe8213bdfb01dc8
  encapsulateUrgs' ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [([GHC.Base.String], [GHC.Base.String])]
    -> ([GHC.Base.String], [GHC.Base.String])
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [([GHC.Base.String], [GHC.Base.String])]) ->
                 (Data.OldList.nubBy
                    @ GHC.Base.String
                    GHC.Base.eqString
                    (BSV2PVS.encapsulateUrgs_go1 w2),
                  Data.OldList.nubBy
                    @ GHC.Base.String
                    GHC.Base.eqString
                    (BSV2PVS.encapsulateUrgs_go w2))) -}
f3b5e3e70af50116800d16d7c7e10e7b
  encapsulateUrgs_go ::
    [([GHC.Base.String], [GHC.Base.String])] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
baefbc668ad1b0f26cde2907ee10946a
  encapsulateUrgs_go1 ::
    [([GHC.Base.String], [GHC.Base.String])] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
225eb52c40209c4c07fd7e8fed947aaf
  expandSubInterfaces ::
    [LexerTypes.InterfaceDec]
    -> [LexerTypes.InterfaceDec] -> [LexerTypes.InterfaceDec]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
596b3a99bd756bbc040f3f98dce94b78
  expressionize ::
    LexerTypes.Expression
    -> LexerTypes.Statement -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
c919200ef25ebd72fd0521f8638c3cfb
  expressionizeSpecificTree ::
    LexerTypes.SpecificTree -> LexerTypes.Expression
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e45c65f956fb6f647991a4bdbc8af6e6
  extractConstructor :: LexerTypes.BSVType -> LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U>m25, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVType) ->
                 case w of wild {
                   DEFAULT -> BSV2PVS.b2pInstDef'1
                   LexerTypes.BSV_Custom x
                   -> LexerTypes.Identifier
                        (LexerTypes.ID (GHC.CString.unpackAppendCString# "mk"# x)) }) -}
04a90b7b96fb700c202a396918e28bcd
  extractExpression ::
    [LexerTypes.MethodArg]
    -> LexerTypes.ID_Path
    -> [GHC.Base.String]
    -> LexerTypes.Statement
    -> LexerTypes.Expression
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U> -}
c9a17d3f9f6477e6126be88940a5a57d
  extractGuardExpression ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.RuleSchedule
    -> LexerTypes.Expression
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,A,A,A,A,U,A,U,U)><S(LLLLLLLLLLLLLLLSLL),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,1*U,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: LexerTypes.RuleSchedule) ->
                 case w2 of ww { LexerTypes.RuleSchedule ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 BSV2PVS.$wextractGuardExpression w w1 ww2 ww16 }) -}
c132b6f476233171db36cd991902c105
  extractGuardExpression1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.extractGuardExpression2) -}
101fc4e9472486955c6c5e7279e6f017
  extractGuardExpression2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_var"#) -}
7ba43ec0ca832e32a55c70adc4a3389c
  extractSubmods :: [LexerTypes.BSVstateDec] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e7151ce2025d79eb9b4c0fa55330608e
  fetchGuardByRule ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.ActionPath
    -> LexerTypes.Expression
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,1*U(A,A,A,A,A,A,1*U,A,1*U,1*U)><S,1*U> -}
0bc1c7d75a2ca07393cc1baae6fed1d8
  filterActionMethodsByInstance ::
    GHC.Base.String -> [LexerTypes.Expression] -> [GHC.Base.String]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
2f35f316d5f2654a4dc9c6c0c7294291
  filterCases ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.Statement
    -> [LexerTypes.Case]
    -> ([LexerTypes.Case], [LexerTypes.Case])
  {- Arity: 3, Strictness: <L,A><L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: LexerTypes.Statement)
                   (w2 :: [LexerTypes.Case]) ->
                 case BSV2PVS.$wfilterCases w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
021ded4486b5e49cddb28146214e8c91
  filterDesUrgs ::
    [LexerTypes.ModuleAttribute] -> [LexerTypes.ModuleAttribute]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a34a96601a8ad653db221789882e1ba8
  filterDesUrgsForName ::
    [LexerTypes.ModuleAttribute]
    -> GHC.Base.String -> [[GHC.Base.String]]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
f7a2daf42e36918716b29a3083cb86a6
  filterForModule ::
    [LexerTypes.Expression]
    -> LexerTypes.BSVModuleDec -> [LexerTypes.Expression]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(A,U,A,A,A,A,A,A,A,A)> -}
fb276df0c8dab2937ed3f2c6b480d9df
  filterForWires ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.ID_Path] -> [LexerTypes.ID_Path]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)><S,1*U> -}
1203793ac935cf2cccab179558267bd2
  finalIDPathEqWithStrings ::
    GHC.Base.String -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
4b68dfe5a65388fac2f61a15928009e6
  findAction ::
    [LexerTypes.ActionDec] -> GHC.Base.String -> LexerTypes.ActionDec
  {- Arity: 2, Strictness: <S,1*U><S,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.ActionDec]) (w1 :: GHC.Base.String) ->
                 case BSV2PVS.$wfindAction w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 (ww1, ww2, ww3) }) -}
d7ab4230ec7ea24705ddcc0645fd5cba
  findCallStmt ::
    [LexerTypes.Statement]
    -> [LexerTypes.ActionDec]
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> GHC.Base.Maybe LexerTypes.Statement
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
c0d09a0dd08cbfe6ba6be90637dc7c27
  findDescendingUrgency ::
    [LexerTypes.ModuleAttribute]
    -> GHC.Base.String -> [LexerTypes.ModuleAttribute]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
d2b5ddd3d72a91bdd8dddded5543167f
  findInterface ::
    [LexerTypes.InterfaceDec]
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.InterfaceDec
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
9493b141988cf32e06af119de4df5843
  findLVarsWithName ::
    [LexerTypes.Statement]
    -> LexerTypes.ID_Path -> LexerTypes.Statement
  {- Arity: 2, Strictness: <S,1*U><S,U>m10, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.Statement]) (w1 :: LexerTypes.ID_Path) ->
                 case BSV2PVS.$wfindLVarsWithName w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 LexerTypes.LocalDec ww1 ww2 ww3 }) -}
ac262abc5ca591c1806aea54fed0704d
  findMatchingStatement ::
    LexerTypes.Statement
    -> [LexerTypes.Statement] -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
32eac5c849ca1b4b165f237db1cd18d7
  findMethod ::
    [LexerTypes.MethodBody]
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.MethodBody
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
778d3fa08016ecda66be79b2c0fc3842
  findMethod' ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.MethodBody]
    -> LexerTypes.ID_Path
    -> GHC.Base.Maybe LexerTypes.MethodBody
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,U,A,A,A,A,A)><S,1*U><L,1*U> -}
1dae238848b3e2ea4ed028f62b616a4a
  findMod ::
    LexerTypes.BSVPackage
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLLSLLL),1*U(A,A,A,A,A,A,A,1*U,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (omnibus :: LexerTypes.BSVPackage)
                   (modRef :: GHC.Base.String) ->
                 case omnibus of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                 BSV2PVS.getMod modRef ds8 }) -}
856b7676143f822372428ffd43e69590
  findModbyInst ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.ID_Path -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
bca4be8706302a2e312cc0351f5ed48e
  findPreemptedByList ::
    [LexerTypes.ModuleAttribute]
    -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
99d29bdd713a893eb6397a0c9824040d
  findPreemptingList ::
    [LexerTypes.ModuleAttribute]
    -> GHC.Base.String -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
c4f363dffeceb93e41dfaf5a865ca3e3
  findRule ::
    [LexerTypes.RuleDec] -> GHC.Base.String -> LexerTypes.RuleDec
  {- Arity: 2, Strictness: <S,1*U><S,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.RuleDec]) (w1 :: GHC.Base.String) ->
                 case BSV2PVS.$wfindRule w w1 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3, ww4) }) -}
0ba0833237a7173912c418981669e261
  findStmt ::
    [LexerTypes.Statement]
    -> [LexerTypes.ActionDec]
    -> LexerTypes.ID_Path
    -> GHC.Base.Maybe LexerTypes.Statement
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
57b9cb848042404917925e544e64fa76
  findSubModbyInst ::
    [LexerTypes.BSVModuleDec]
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
05d1bcb9f82a7536fa1e468ef8240046
  findSubModbyInst' ::
    [LexerTypes.BSVModuleDec]
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> GHC.Base.Maybe (LexerTypes.BSVModuleDec, LexerTypes.MethodBody)
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U> -}
ac8b3b030995b4d24bc3f7f9b8e18fdd
  findSupremum ::
    [LexerTypes.RuleSchedule]
    -> (LexerTypes.RuleSchedule, [LexerTypes.RuleSchedule],
        [LexerTypes.RuleSchedule])
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [LexerTypes.RuleSchedule]) ->
                 case BSV2PVS.$wfindSupremum w of ww { (#,,#) ww1 ww2 ww3 ->
                 (ww1, ww2, ww3) }) -}
f7c3ac399e3d47663e0029cdc020e3d9
  findSupremum1 :: LexerTypes.RuleSchedule -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLLLLLSL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LexerTypes.RuleSchedule) ->
                 case x of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                 case ds17 of wild1 {
                   [] -> GHC.Types.True : ds22 ds23 -> GHC.Types.False } }) -}
a93c8ef87a232dee99f7b9d16e43eb10
  findSupremum2 :: LexerTypes.RuleSchedule -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLLLLSLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LexerTypes.RuleSchedule) ->
                 case x of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                 case ds16 of wild1 {
                   [] -> GHC.Types.True : ds22 ds23 -> GHC.Types.False } }) -}
ff1d78dc6b1e4fb440ca3c2a761d7490
  findSupremum3 ::
    (LexerTypes.RuleSchedule, [LexerTypes.RuleSchedule],
     [LexerTypes.RuleSchedule])
  {- Strictness: x -}
eae492a878fc7544c9acf61bb774d654
  fixMaybeDefaults ::
    LexerTypes.BSVstateDec -> LexerTypes.BSVstateDec
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.BSVstateDec) ->
                 case ds of wild {
                   DEFAULT -> wild
                   LexerTypes.BSV_Reg i t init
                   -> LexerTypes.BSV_Reg i t (BSV2PVS.fixedInit t init)
                   LexerTypes.DWire i t init
                   -> LexerTypes.DWire i t (BSV2PVS.fixedInit t init) }) -}
5c69841c2b807e9cab0f8734dd0ab638
  fixedInit ::
    LexerTypes.BSVType
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: LexerTypes.BSVType) (ds1 :: LexerTypes.Expression) ->
                 case ds of wild {
                   DEFAULT -> ds1
                   LexerTypes.BSV_Maybe t
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> LexerTypes.Tagged
                             (GHC.Base.Nothing @ LexerTypes.PVSType)
                             (LexerTypes.Valid wild1)
                        LexerTypes.Tagged x exp -> LexerTypes.Tagged x exp } }) -}
be53b8de7a0b6e4b365a384f583bef7a
  gatherValueMethods ::
    [LexerTypes.MethodBody] -> [LexerTypes.MethodBody]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bafe84c294dbb2b06b4a528b28ab85cf
  genArgumentVars ::
    LexerTypes.UTArgs
    -> [LexerTypes.Argument] -> [(LexerTypes.PVSType, GHC.Base.String)]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
dae73184b74a2286ad52229df7984372
  genArgumentVars' ::
    GHC.Base.String
    -> LexerTypes.Argument -> (LexerTypes.PVSType, GHC.Base.String)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,1*U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.String)
                   (ds :: (LexerTypes.Name, LexerTypes.BSVType,
                           [LexerTypes.ArgumentAttribute])) ->
                 case ds of wild { (,,) nom btyp ds1 ->
                 (BSV2PVS.b2pType btyp, x) }) -}
c89d98503b99ffca7fa086ecdfaff5f8
  genFakeReg ::
    LexerTypes.ID_Path
    -> LexerTypes.BSVInstDef
    -> LexerTypes.BSV_Field
    -> LexerTypes.BSVstateDec
  {- Arity: 3, Strictness: <L,1*U><S,1*U(A,1*U)><S,1*U(U,U)>m1,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.ID_Path)
                   (w1 :: LexerTypes.BSVInstDef)
                   (w2 :: LexerTypes.BSV_Field) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case w2 of ww3 { (,) ww4 ww5 ->
                 LexerTypes.BSV_Reg
                   (BSV2PVS.applyIDPrefix w (LexerTypes.ID ww4))
                   ww5
                   (case GHC.List.lookup
                           @ LexerTypes.Name
                           @ LexerTypes.Literal
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           ww4
                           ww2 of wild {
                      GHC.Base.Nothing -> BSV2PVS.genFakeReg1 ww4
                      GHC.Base.Just x -> x }) } }) -}
af8195b494615e634e98bd9496a5199a
  genFakeReg1 :: LexerTypes.Name -> LexerTypes.Literal
  {- Arity: 1, Strictness: <B,1*U>x -}
cd46ceb7ae287906989153c973f5ed85
  genFakeRegs ::
    LexerTypes.ID_Path
    -> [LexerTypes.BSVTypeDef]
    -> [LexerTypes.BSVInstDef]
    -> GHC.Base.String
    -> GHC.Base.String
    -> [LexerTypes.BSVstateDec]
  {- Arity: 5, Strictness: <L,U><S,1*U><L,1*U><S,U><L,U> -}
32e92af8ecfed50a4bfed7393bce2c13
  genIfExp ::
    LexerTypes.Expression
    -> GHC.Base.Maybe LexerTypes.LocalVar
    -> GHC.Base.Maybe LexerTypes.LocalVar
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 4, Strictness: <L,U><S,1*U><S,1*U><L,U>m29, Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.Expression)
                   (w1 :: GHC.Base.Maybe LexerTypes.LocalVar)
                   (w2 :: GHC.Base.Maybe LexerTypes.LocalVar)
                   (w3 :: LexerTypes.Expression) ->
                 case w1 of wild {
                   GHC.Base.Nothing
                   -> case w2 of wild1 {
                        GHC.Base.Nothing
                        -> case BSV2PVS.genIfExp1 ret_ty LexerTypes.Expression of {}
                        GHC.Base.Just ds
                        -> case ds of wild2 { (,,) ds1 ds2 eExp ->
                           LexerTypes.Exp_If w w3 eExp } }
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,,) ds1 ds2 tExp ->
                      case w2 of wild2 {
                        GHC.Base.Nothing -> LexerTypes.Exp_If w tExp w3
                        GHC.Base.Just ds3
                        -> case ds3 of wild3 { (,,) ds4 ds5 eExp ->
                           LexerTypes.Exp_If w tExp eExp } } } }) -}
7196cccb5c6b0e6138caab81e26c3a6b
  genIfExp1 :: LexerTypes.Expression -> LexerTypes.Expression
  {- Strictness: x -}
1a488f2d98658a25b424860ec2d131f6
  genInterfaces ::
    LexerTypes.BSVModuleDec -> [LexerTypes.InterfaceDec]
  {- Arity: 1,
     Strictness: <S(LLLLSLLLLL),1*U(A,A,A,A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LexerTypes.BSVModuleDec) ->
                 case x of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 GHC.Base.build
                   @ (LexerTypes.Name, [LexerTypes.MethodDec],
                      [LexerTypes.InterfaceRef], [LexerTypes.InterfaceAttribute])
                   (\ @ b1
                      (c :: (LexerTypes.Name, [LexerTypes.MethodDec],
                             [LexerTypes.InterfaceRef], [LexerTypes.InterfaceAttribute])
                            -> b1 -> b1)[OneShot]
                      (n3 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (GHC.Base.String, GHC.Base.String, [LexerTypes.MethodBody])
                      @ b1
                      (GHC.Base.mapFB
                         @ (LexerTypes.Name, [LexerTypes.MethodDec],
                            [LexerTypes.InterfaceRef], [LexerTypes.InterfaceAttribute])
                         @ b1
                         @ (GHC.Base.String, GHC.Base.String, [LexerTypes.MethodBody])
                         c
                         BSV2PVS.genInterfaces')
                      n3
                      ds5) }) -}
bfdff0d1853b526516800e6ef68e2093
  genInterfaces' ::
    LexerTypes.MidModInterfaceDec -> LexerTypes.InterfaceDec
  {- Arity: 1, Strictness: <S,1*U(U,A,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y ms ->
                 (x,
                  GHC.Base.build
                    @ (LexerTypes.Name, LexerTypes.ReturnType, [LexerTypes.Argument],
                       [LexerTypes.MethodDecAttribute])
                    (\ @ b1
                       (c :: (LexerTypes.Name, LexerTypes.ReturnType,
                              [LexerTypes.Argument], [LexerTypes.MethodDecAttribute])
                             -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                          LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.MethodBodyAttribute])
                       @ b1
                       (GHC.Base.mapFB
                          @ (LexerTypes.Name, LexerTypes.ReturnType, [LexerTypes.Argument],
                             [LexerTypes.MethodDecAttribute])
                          @ b1
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          c
                          BSV2PVS.mBody2MDec)
                       n3
                       ms),
                  GHC.Types.[] @ LexerTypes.InterfaceRef,
                  GHC.Types.[] @ LexerTypes.InterfaceAttribute) }) -}
284da87b9b2ff5ef5f7aa4dfef1a33bb
  genMethVars ::
    [LexerTypes.MethodBody]
    -> [LexerTypes.MethodDec]
    -> [(LexerTypes.PVSType, GHC.Base.String)]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
ce590c220db3cdc0d527c445fe61dd65
  genMethVars' ::
    LexerTypes.MethodBody
    -> LexerTypes.MethodDec -> [(LexerTypes.PVSType, GHC.Base.String)]
  {- Arity: 2,
     Strictness: <S(LLSLLL),1*U(A,A,1*U,A,A,A)><S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute]))
                   (ds1 :: (LexerTypes.Name, LexerTypes.ReturnType,
                            [LexerTypes.Argument], [LexerTypes.MethodDecAttribute])) ->
                 case ds of wild { (,,,,,) nom1 ds2 args1 ds3 ds4 ds5 ->
                 case ds1 of wild1 { (,,,) nom2 typ args2 ds6 ->
                 BSV2PVS.genArgumentVars args1 args2 } }) -}
34f7628ee2a3abcc809f65c72ff5a04d
  genRuleHeap ::
    [LexerTypes.RuleSchedule]
    -> [GHC.Base.String] -> LexerTypes.RuleHeap
  {- Arity: 2, Strictness: <L,U><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.RuleSchedule]) (w1 :: [GHC.Base.String]) ->
                 case BSV2PVS.$wgenRuleHeap w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 LexerTypes.RHeap ww1 ww2 ww3 }) -}
7262b08e8d365b0335dbac84617f4b8e
  genRuleSchedule ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.RuleDec
    -> LexerTypes.RuleSchedule
  {- Arity: 5,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,U,U,U,U,U,U,U,U,U)><L,U><L,U><S,1*U(U,U,U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: LexerTypes.RuleDec) ->
                 case w4 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 BSV2PVS.$wgenRuleSchedule w w1 w2 w3 ww1 ww2 ww3 ww4 }) -}
7e8f6f71889c351f3ce4fd78e0b9e426
  genRuleSchedules ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.RuleSchedule]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S(LLLLLLLLSL),1*U(U,U,U,U,U,U,U,U,U,U)><L,U><L,U> -}
a5b6409183c6d36ee677819bcfcbc4c8
  genSubmodVars ::
    LexerTypes.BSVstateDec
    -> GHC.Base.Maybe (LexerTypes.PVSType, GHC.Base.String)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.BSVstateDec) ->
                 case ds of wild {
                   DEFAULT -> GHC.Base.Nothing @ (LexerTypes.PVSType, GHC.Base.String)
                   LexerTypes.BSV_SubModuleDec interface name inst
                   -> GHC.Base.Just
                        @ (LexerTypes.PVSType, [GHC.Types.Char])
                        (LexerTypes.PVS_Custom interface,
                         GHC.Base.++
                           @ GHC.Types.Char
                           interface
                           BSV2PVS.extractGuardExpression1) }) -}
e2c152706fe77e2875ab8b180c74514c
  genTotalTree ::
    [LexerTypes.RuleSchedule]
    -> GHC.Integer.Type.Integer -> LexerTypes.TotalTree
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: [LexerTypes.RuleSchedule])
                   (w1 :: GHC.Integer.Type.Integer) ->
                 BSV2PVS.$wgenTotalTree w) -}
9f9fdded9d6bf7d3b5ab6fe1f54cc033
  genTrans ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.TreeHeap
    -> LexerTypes.BSVstateDec
    -> LexerTypes.TransitionTable
  {- Arity: 7,
     Strictness: <L,U(A,A,A,A,A,U,U,A,A,A,A)><L,U(A,A,U,A,A,A,A,U,A,A)><L,U><L,U><L,U><S,1*U(A,U,U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: [GHC.Base.String])
                   (w5 :: LexerTypes.TreeHeap)
                   (w6 :: LexerTypes.BSVstateDec) ->
                 case w5 of ww { LexerTypes.THeap ww1 ww2 ww3 ->
                 BSV2PVS.$wgenTrans w w1 w2 w3 w4 ww2 ww3 w6 }) -}
51b4a4b3738b3facd1fe08a61a4c5ea2
  genTransTable ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.MethodArg]
    -> [GHC.Base.String]
    -> [LexerTypes.RuleSchedule]
    -> [LexerTypes.BSVstateDec]
    -> [LexerTypes.TransitionTable]
  {- Arity: 6,
     Strictness: <L,U(A,A,A,A,A,U,U,A,A,A,A)><L,U(A,A,U,A,A,A,1*U,U,A,A)><L,1*U><L,U><L,U><S,1*U>,
     Unfolding: (\ (universe :: LexerTypes.BSVPackage)
                   (mod :: LexerTypes.BSVModuleDec)
                   (mArgs :: [LexerTypes.MethodArg])
                   (prefixes :: [GHC.Base.String])
                   (sched :: [LexerTypes.RuleSchedule])
                   (states :: [LexerTypes.BSVstateDec]) ->
                 GHC.Base.map
                   @ LexerTypes.BSVstateDec
                   @ LexerTypes.TransitionTable
                   (let {
                      w :: LexerTypes.TreeHeap
                      = case BSV2PVS.$wgenRuleHeap
                               sched
                               (GHC.Types.[] @ GHC.Base.String) of ww { (#,,#) ww1 ww2 ww3 ->
                        case BSV2PVS.$wgenTreeHeap
                               ww1
                               ww2
                               ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                        LexerTypes.THeap ww5 ww6 ww7 } }
                    } in
                    let {
                      w1 :: [GHC.Base.String]
                      = GHC.Base.++
                          @ [GHC.Types.Char]
                          mArgs
                          (case mod of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                           BSV2PVS.getWireNames ds7 })
                    } in
                    \ (w2 :: LexerTypes.BSVstateDec) ->
                    case w of ww { LexerTypes.THeap ww1 ww2 ww3 ->
                    BSV2PVS.$wgenTrans
                      universe
                      mod
                      (GHC.Types.[] @ GHC.Base.String)
                      prefixes
                      w1
                      ww2
                      ww3
                      w2 })
                   states) -}
7bf3712dc804a0922c3cbaf3108e57a1
  genTransitionVars ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec -> [LexerTypes.TransitionVar]
  {- Arity: 2,
     Strictness: <L,1*U(A,A,A,1*U,A,A,A,A,A,A,A)><S(LLLLLLLLLS),1*U(A,A,A,U,A,A,1*U,A,A,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVPackage) (w1 :: LexerTypes.BSVModuleDec) ->
                 case w1 of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wgenTransitionVars w ww4 ww7 ww10 }) -}
227210db300518dd3ee5d005456bb307
  genTransitionVars1 ::
    (LexerTypes.PVSType, [GHC.Types.Char])
    -> (LexerTypes.PVSType, [GHC.Types.Char]) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (LexerTypes.PVSType, [GHC.Types.Char]))
                   (w1 :: (LexerTypes.PVSType, [GHC.Types.Char])) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 BSV2PVS.$wlvl ww1 ww2 ww4 ww5 } }) -}
2a1efca0da104e8de4daf2a465b72686
  genTransitionVars2 :: LexerTypes.InterfaceDec
  {- Strictness: x -}
e0f2baf268239926bb9e418e0868358a
  genTransitionVars3 ::
    (LexerTypes.PVSType, [GHC.Types.Char])
    -> (LexerTypes.PVSType, [GHC.Types.Char]) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (LexerTypes.PVSType, [GHC.Types.Char]))
                   (w1 :: (LexerTypes.PVSType, [GHC.Types.Char])) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 BSV2PVS.$wlvl1 ww1 ww2 ww4 ww5 } }) -}
d4662aef52513d190210320a64b8f3fc
  genTransitions ::
    LexerTypes.BSVPackage
    -> GHC.Base.String
    -> (GHC.Integer.Type.Integer, [LexerTypes.ID_Path])
    -> LexerTypes.PVStransition
  {- Arity: 3,
     Strictness: <L,U(A,A,A,U,A,U,U,U,A,A,A)><L,U><S,1*U(U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: GHC.Base.String)
                   (w2 :: (GHC.Integer.Type.Integer, [LexerTypes.ID_Path])) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case BSV2PVS.$wgenTransitions
                        w
                        w1
                        ww1
                        ww2 of ww3 { (#,,,#) ww4 ww5 ww6 ww7 ->
                 (ww4, ww5, ww6, ww7) } }) -}
8703ad5e943dd1d2b0cc627f432d1965
  genTreeHeap :: LexerTypes.RuleHeap -> LexerTypes.TreeHeap
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.RuleHeap) ->
                 case w of ww { LexerTypes.RHeap ww1 ww2 ww3 ->
                 case BSV2PVS.$wgenTreeHeap
                        ww1
                        ww2
                        ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 LexerTypes.THeap ww5 ww6 ww7 } }) -}
5803529f63c434f9d1cd0d9872996cfa
  genValueMethods ::
    LexerTypes.BSVPackage
    -> [LexerTypes.TransitionTable]
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [LexerTypes.ValueMethod]
  {- Arity: 5,
     Strictness: <L,A><L,A><S(LLSLLLLLLL),1*U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: [LexerTypes.TransitionTable])
                   (w2 :: LexerTypes.BSVModuleDec)
                   (w3 :: GHC.Base.String)
                   (w4 :: [GHC.Base.String]) ->
                 case w2 of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wgenValueMethods
                   ww1
                   ww2
                   ww3
                   ww4
                   ww7
                   ww8
                   ww9
                   ww10
                   w3
                   w4 }) -}
fae725519a729b4e98d2bc07af7d2ebd
  getAPPath :: LexerTypes.ActionPath -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
eca132e36a9a61f165a1d1a75bd77b87
  getAllInvokationsOf ::
    [LexerTypes.Expression] -> GHC.Base.String -> [LexerTypes.ID_Path]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
6ff85c0e61f9f044000162f5e9b5dec6
  getAnteriors ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [LexerTypes.ID_Path]
    -> ([LexerTypes.ID_Path], [LexerTypes.ID_Path],
        [LexerTypes.ID_Path], [LexerTypes.ID_Path])
    -> [LexerTypes.ActionPath]
  {- Arity: 5,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S(LLLLLLLLSL),1*U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><S,1*U(A,U,A,U)> -}
33ba25251116ffdb6b98bf3487236ec7
  getCaseMatches ::
    LexerTypes.BSVModuleDec -> [LexerTypes.Case] -> [[LexerTypes.Case]]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U>,
     Unfolding: (\ (m :: LexerTypes.BSVModuleDec)
                   (xs :: [LexerTypes.Case]) ->
                 letrec {
                   go16 :: [(LexerTypes.Literal, LexerTypes.Statement)]
                           -> [LexerTypes.Case]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(LexerTypes.Literal, LexerTypes.Statement)]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ LexerTypes.Case
                       : y ys
                       -> case y of ww { (,) ww1 ww2 ->
                          GHC.Base.++
                            @ (LexerTypes.Literal, LexerTypes.Statement)
                            (GHC.Base.map
                               @ LexerTypes.Statement
                               @ (LexerTypes.Literal, LexerTypes.Statement)
                               (\ (x :: LexerTypes.Statement) -> (ww1, x))
                               (BSV2PVS.removeVoids (BSV2PVS.splitStatementBlock m ww2)))
                            (go16 ys) } }
                 } in
                 BSV2PVS.$wgetCasesMatching (go16 xs)) -}
ad406e73271b1d27fc944844abaa03c8
  getCasesMatching ::
    LexerTypes.BSVModuleDec -> [LexerTypes.Case] -> [[LexerTypes.Case]]
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: [LexerTypes.Case]) ->
                 BSV2PVS.$wgetCasesMatching w1) -}
fd8f00f62617c8aa3b6e89c9e69baa55
  getConflicts ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.RuleDec]
    -> [LexerTypes.ID_Path]
    -> ([LexerTypes.ID_Path], [LexerTypes.ID_Path])
    -> [GHC.Base.String]
  {- Arity: 5,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(A,A,A,A,A,A,U,U,A,A)><S,1*U><L,U><L,1*U(U,U)> -}
c47ec6f32e020ec7d466f486ed655aa6
  getDeps ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.LocalVar]
    -> [LexerTypes.LocalVar]
    -> [LexerTypes.LocalVar]
  {- Arity: 3, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,U><S,1*U> -}
60e6d70a43def07914892b14f9756d33
  getHeap ::
    GHC.Base.String
    -> [LexerTypes.TreeHeap] -> GHC.Base.Maybe LexerTypes.TreeHeap
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
6e39d5d1636a38b94cfbded5adbb1bd0
  getHigherUrgencies ::
    GHC.Base.String -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.String) (ds1 :: [GHC.Base.String]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ipv ipv1
                   -> GHC.Base.build
                        @ [GHC.Types.Char]
                        (\ @ b
                           (c :: [GHC.Types.Char] -> b -> b)[OneShot]
                           (n3 :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ [GHC.Types.Char]
                           @ b
                           (GHC.List.takeWhileFB
                              @ [GHC.Types.Char]
                              @ b
                              (\ (q :: GHC.Base.String) -> GHC.Classes.$fEq[]_$s$c/=1 ds q)
                              c
                              n3)
                           n3
                           wild) }) -}
8a6724679265144968e73a017b662911
  getImplicitConditions ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.Statement]
    -> [LexerTypes.Expression]
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(A,A,A,A,A,A,U,A,A,A)><S,1*U> -}
1824ff64d734206a78b7899fed75902e
  getInstDef ::
    [LexerTypes.BSVInstDef]
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.BSVInstDef
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
747e330f33f36e917f9de4c50ec5ed01
  getLVarName ::
    GHC.Base.Maybe LexerTypes.LocalVar
    -> GHC.Base.Maybe LexerTypes.LocalVar -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe LexerTypes.LocalVar)
                   (ds1 :: GHC.Base.Maybe LexerTypes.LocalVar) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> BSV2PVS.getLVarName1
                        GHC.Base.Just ds2 -> case ds2 of wild2 { (,,) n3 ds3 ds4 -> n3 } }
                   GHC.Base.Just ds2
                   -> case ds2 of wild1 { (,,) n3 ds3 ds4 -> n3 } }) -}
9cbe5839feec0e5744709c611d008a9d
  getLVarName1 :: LexerTypes.ID_Path
  {- Strictness: x -}
3d5b1549e41b4e2d9260c587a7587a3c
  getLetVars ::
    LexerTypes.Statement -> GHC.Base.Maybe LexerTypes.LocalVar
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.Statement) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.getLetVars1
                   LexerTypes.Write ds1 ds2 ds3
                   -> GHC.Base.Nothing @ LexerTypes.LocalVar
                   LexerTypes.LocalDec ds1 ds2 ds3
                   -> case ds1 of wild1 {
                        [] -> BSV2PVS.getLetVars1
                        : x ds4
                        -> case ds4 of wild2 {
                             []
                             -> case ds2 of wild3 {
                                  DEFAULT -> BSV2PVS.getLetVars1
                                  LexerTypes.Void -> GHC.Base.Just @ LexerTypes.LocalVar x }
                             : ipv ipv1 -> BSV2PVS.getLetVars1 } }
                   LexerTypes.Void -> GHC.Base.Nothing @ LexerTypes.LocalVar }) -}
0a48b19bdb6d923be55b3743b79f3151
  getLetVars1 :: GHC.Base.Maybe LexerTypes.LocalVar
  {- Strictness: x -}
f3c0c5791991cedec92719cf4423d2ae
  getLets :: [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
3215cc1753f6957287af40ebcc1bd45a
  getLowerUrgencies ::
    GHC.Base.String -> [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
b339d62eb015bdda5f193deb2d82cc94
  getMCalls ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> LexerTypes.Statement
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(A,A,A,A,A,A,U,U,A,A)><L,U><S,1*U> -}
52793b5835a15dc015b8ef9fd0b2b70e
  getMCallsOverTree ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.SpecificTree
    -> [LexerTypes.Expression]
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,A,A,A)><S,1*U> -}
419d4ae0af0edeb6c23d3b0b5c3a9f25
  getMDecs ::
    [LexerTypes.InterfaceDec]
    -> [LexerTypes.InterfaceDec]
    -> GHC.Base.String
    -> [LexerTypes.MethodDec]
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U> -}
067d70d997eadae0c18e12b0c52e48de
  getMatchingCaseStatements ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.Case] -> LexerTypes.Statement -> [LexerTypes.Case]
  {- Arity: 3, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U><L,U> -}
9e3743e4c5eac12653001846fa1edc2d
  getMethCalls ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Types.Bool
    -> [LexerTypes.Statement]
    -> [LexerTypes.Expression]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,U,A,A)><L,U><S,1*U> -}
09c5802a3f0384cfd90bd15afea357e6
  getMethCallsCases ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Types.Bool
    -> LexerTypes.ExpCase
    -> [LexerTypes.Expression]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,A,A,A)><L,U><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (u :: LexerTypes.BSVPackage)
                   (m :: LexerTypes.BSVModuleDec)
                   (v :: GHC.Types.Bool)
                   (ds :: (LexerTypes.Literal, LexerTypes.Expression)) ->
                 case ds of wild { (,) l exp ->
                 BSV2PVS.getMethCallsExp u m v exp }) -}
e9b54feff426a79522077f0ea1d5ba14
  getMethCallsExp ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Types.Bool
    -> LexerTypes.Expression
    -> [LexerTypes.Expression]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,A,A,A)><L,U><S,1*U> -}
9a8103619650fc6f51335414a6d31adb
  getMethCallsLVar ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Types.Bool
    -> LexerTypes.LocalVar
    -> [LexerTypes.Expression]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,A,A,A)><L,U><S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (u :: LexerTypes.BSVPackage)
                   (m :: LexerTypes.BSVModuleDec)
                   (v :: GHC.Types.Bool)
                   (ds :: (LexerTypes.ID_Path,
                           Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType),
                           LexerTypes.Expression)) ->
                 case ds of wild { (,,) ds1 ds2 exp ->
                 BSV2PVS.getMethCallsExp u m v exp }) -}
a111e4fb609725c145958372f93c4b1e
  getMethNames :: LexerTypes.Expression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.Expression) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   LexerTypes.Exp_MethodCall mName ds1 ds2 ds3
                   -> BSV2PVS.showIDPath mName }) -}
d50780f5811d94e84e7b039064d10e43
  getMethNames' :: LexerTypes.BSVModuleDec -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLS),1*U(A,A,A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec) ->
                 case mod of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 GHC.Base.build
                   @ [GHC.Types.Char]
                   (\ @ b1
                      (c :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                      (n3 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                         LexerTypes.Guard, [LexerTypes.Statement],
                         [LexerTypes.MethodBodyAttribute])
                      @ b1
                      (GHC.Base.mapFB
                         @ [GHC.Types.Char]
                         @ b1
                         @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                            LexerTypes.Guard, [LexerTypes.Statement],
                            [LexerTypes.MethodBodyAttribute])
                         c
                         BSV2PVS.getMethNames'1)
                      n3
                      ds10) }) -}
40a5f38ce469985ab55f78f9b646e89d
  getMethNames'1 ::
    (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
     LexerTypes.Guard, [LexerTypes.Statement],
     [LexerTypes.MethodBodyAttribute])
    -> LexerTypes.MethodName
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLL),1*U(1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) x ds1 ds2 ds3 ds4 ds5 -> x }) -}
593d63f678dbc8d4317fbcfae892f5f1
  getMethodDependencies ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.TransitionTable]
    -> LexerTypes.ValueMethod
    -> ([GHC.Base.String], LexerTypes.ValueMethod)
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><S,1*U(U,U,U,U,U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [LexerTypes.TransitionTable])
                   (w3 :: LexerTypes.ValueMethod) ->
                 case w3 of ww { (,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case BSV2PVS.$wgetMethodDependencies
                        w
                        w1
                        w2
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7 of ww8 { (#,#) ww9 ww10 ->
                 (ww9, ww10) } }) -}
307c04982a6248c8ad3206a6c799f5f1
  getMethodDependencies1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("`"#) -}
b4b54a1ac1bbeb9f94bdff18fe8bb760
  getMethodDependencies2 :: [GHC.Types.Char]
  {- Strictness: x -}
a8ee2d07203f4071ff739f191c5371b4
  getMod ::
    GHC.Base.String
    -> [LexerTypes.BSVModuleDec]
    -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
4d03908f43723c6e9c0f9fde545aa7d8
  getModAttsRM ::
    [LexerTypes.RuleDec] -> [LexerTypes.ModuleAttribute]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f6d8acd0551687443fe78f3b4c805fb1
  getModAttsS ::
    LexerTypes.Statement -> [LexerTypes.StatementAttribute]
  {- Arity: 1, Strictness: <S,1*U> -}
58345abf13095a6d25f61745cb1d2d12
  getModAttsSR ::
    [LexerTypes.Statement] -> [LexerTypes.RuleAttribute]
  {- Arity: 1, Strictness: <S,1*U> -}
311883c21b7736107bee062363b5f6fc
  getModByInst ::
    [LexerTypes.BSVModuleDec]
    -> GHC.Base.String -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
950bb41d4ede1fae92ac1b266f468806
  getNonConflicts ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.RuleDec]
    -> [LexerTypes.ID_Path]
    -> ([LexerTypes.ID_Path], [LexerTypes.ID_Path])
    -> [GHC.Base.String]
  {- Arity: 5,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(A,A,A,A,A,A,U,U,A,A)><S,1*U><L,U><L,1*U(U,U)>,
     Unfolding: (\ (ds :: LexerTypes.BSVPackage)
                   (ds1 :: LexerTypes.BSVModuleDec)
                   (ds2 :: [LexerTypes.RuleDec])
                   (ds3 :: [LexerTypes.ID_Path])
                   (ds4 :: ([LexerTypes.ID_Path], [LexerTypes.ID_Path])) ->
                 case ds2 of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds5 xs
                   -> case ds5 of wild1 { (,,,) name ds6 stmts ds7 ->
                      case ds4 of wild2 { (,) fifoEnqs fifoDeqs ->
                      case Data.OldList.intersectBy
                             @ LexerTypes.ID_Path
                             LexerTypes.$fEqID_Path_$c==
                             ds3
                             (BSV2PVS.getWrites ds ds1 stmts) of wild3 {
                        []
                        -> GHC.Types.:
                             @ LexerTypes.RuleName
                             name
                             (BSV2PVS.getConflicts ds ds1 xs ds3 wild2)
                        : ds8 ds9 -> BSV2PVS.getConflicts ds ds1 xs ds3 wild2 } } } }) -}
a2b1846e1bfb2adb7df7fd5a9f39e73c
  getPreempts ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.ActionPath]
    -> ([LexerTypes.ActionPath], [LexerTypes.ActionPath])
  {- Arity: 7,
     Strictness: <L,A><L,1*U(A,A,A,A,A,1*U,A,A,A,A)><L,U><L,U><L,U><L,1*U><L,1*U>m,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: GHC.Base.String)
                   (w4 :: [GHC.Base.String])
                   (w5 :: [GHC.Base.String])
                   (w6 :: [LexerTypes.ActionPath]) ->
                 case BSV2PVS.$wgetPreempts
                        w1
                        w2
                        w3
                        w4
                        w5
                        w6 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
aef66181a9d020056159094b24206598
  getPreempts' ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.ActionPath]
  {- Arity: 5, Strictness: <L,A><L,A><L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (5, True, True)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: [GHC.Base.String]) ->
                 BSV2PVS.$wgetPreempts' w2 w3 w4) -}
e859a5db6e0fc8312fa7cbf5fba5e180
  getPriors ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [LexerTypes.RuleDec]
    -> [LexerTypes.ID_Path]
    -> ([LexerTypes.ID_Path], [LexerTypes.ID_Path],
        [LexerTypes.ID_Path], [LexerTypes.ID_Path])
    -> [LexerTypes.ActionPath]
  {- Arity: 6,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,U,A,A)><L,U><S,1*U><L,U><L,1*U(A,U,A,U)> -}
2115ac79884dfc3924a61a6f7abaa856
  getReadsBy ::
    LexerTypes.BSVModuleDec
    -> (LexerTypes.ID_Path -> GHC.Types.Bool)
    -> [GHC.Base.String]
    -> LexerTypes.Expression
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,C(U)><L,U><S,1*U> -}
45c4154b62838e025655c4a6a15907d5
  getReadsByCases ::
    LexerTypes.BSVModuleDec
    -> (LexerTypes.ID_Path -> GHC.Types.Bool)
    -> [GHC.Base.String]
    -> [LexerTypes.ExpCase]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,C(U)><L,U><S,1*U> -}
9dd62393a110dfdcaa2be92065772d6b
  getReadsByLVs ::
    LexerTypes.BSVModuleDec
    -> (LexerTypes.ID_Path -> GHC.Types.Bool)
    -> [GHC.Base.String]
    -> LexerTypes.LocalVar
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,C(U)><L,U><S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (m :: LexerTypes.BSVModuleDec)
                   (p :: LexerTypes.ID_Path -> GHC.Types.Bool)
                   (i :: [GHC.Base.String])
                   (ds :: (LexerTypes.ID_Path,
                           Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType),
                           LexerTypes.Expression)) ->
                 case ds of wild { (,,) ds1 ds2 x ->
                 BSV2PVS.getReadsBy m p i x }) -}
60e8d256ad0eb2d417d634f13a2a4a4b
  getReadsByOverStatements ::
    LexerTypes.BSVModuleDec
    -> (LexerTypes.ID_Path -> GHC.Types.Bool)
    -> [GHC.Base.String]
    -> [LexerTypes.Statement]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><L,C(U)><L,U><S,1*U> -}
5678644f16dc3a599db4b57a70fd31a0
  getRegFiles :: [LexerTypes.BSVstateDec] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
4dd60a4631d533dffe0b3ad0eb7c80c8
  getRelevantSchedules ::
    [LexerTypes.RuleSchedule]
    -> [GHC.Base.String] -> [LexerTypes.RuleSchedule]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (rs :: [LexerTypes.RuleSchedule])
                   (path :: [GHC.Base.String]) ->
                 GHC.List.filter
                   @ LexerTypes.RuleSchedule
                   (\ (q :: LexerTypes.RuleSchedule) ->
                    case q of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    BSV2PVS.isAboveOrAt path (BSV2PVS.getAPPath ds1) })
                   rs) -}
3b07c89baf62723d3608045cd75415d6
  getReplacements ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.Expression]
    -> [LexerTypes.Replacement]
  {- Arity: 3, Strictness: <L,A><L,1*U(A,A,A,A,A,A,A,A,A,U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [LexerTypes.Expression]) ->
                 BSV2PVS.$wgetReplacements w1 w2) -}
1392ff3196b50b0e0b043dde4b33ca34
  getReturnExp ::
    [LexerTypes.Statement] -> GHC.Base.Maybe LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U> -}
e7f217c5c786daec88b7f7069e82395c
  getStateType ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.BSVstateDec]
    -> LexerTypes.ID_Path
    -> LexerTypes.BSVType
  {- Arity: 3,
     Strictness: <L,1*U(A,A,1*U,A,A,A,A,A,A,A)><S,1*U><S,U> -}
be3448184f9c0d7b1f077ba983e09c64
  getStatement ::
    LexerTypes.ID_Path
    -> [LexerTypes.Statement] -> GHC.Base.Maybe LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
65e59eb2597bc46b93ebade9c8d27ffa
  getStatementPairs ::
    [LexerTypes.Statement]
    -> [LexerTypes.Statement]
    -> [(LexerTypes.Statement, LexerTypes.Statement)]
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (xs :: [LexerTypes.Statement])
                   (ys :: [LexerTypes.Statement]) ->
                 let {
                   z :: [(LexerTypes.Statement, LexerTypes.Statement)]
                   = letrec {
                       go16 :: [LexerTypes.Statement]
                               -> [LexerTypes.Statement]
                               -> [(LexerTypes.Statement, LexerTypes.Statement)]
                         {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                       = \ (ds :: [LexerTypes.Statement])
                           (eta :: [LexerTypes.Statement]) ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ (LexerTypes.Statement, LexerTypes.Statement)
                           : y ys1
                           -> case eta of wild1 {
                                [] -> GHC.Types.[] @ (LexerTypes.Statement, LexerTypes.Statement)
                                : y1 ys2
                                -> GHC.Types.:
                                     @ (LexerTypes.Statement, LexerTypes.Statement)
                                     (BSV2PVS.findMatchingStatement y xs, y1)
                                     (go16 ys1 ys2) } }
                     } in
                     go16 ys ys
                 } in
                 letrec {
                   go16 :: [LexerTypes.Statement]
                           -> [LexerTypes.Statement]
                           -> [(LexerTypes.Statement, LexerTypes.Statement)]
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ (ds :: [LexerTypes.Statement])
                       (_ys :: [LexerTypes.Statement]) ->
                     case ds of wild {
                       [] -> z
                       : ipv ipv1
                       -> case _ys of wild1 {
                            [] -> z
                            : ipv2 ipv3
                            -> GHC.Types.:
                                 @ (LexerTypes.Statement, LexerTypes.Statement)
                                 (ipv, ipv2)
                                 (go16 ipv1 ipv3) } }
                 } in
                 Data.OldList.nubBy
                   @ (LexerTypes.Statement, LexerTypes.Statement)
                   BSV2PVS.getStatementPairs1
                   (go16
                      xs
                      (GHC.Base.map
                         @ LexerTypes.Statement
                         @ LexerTypes.Statement
                         (\ (x :: LexerTypes.Statement) ->
                          BSV2PVS.findMatchingStatement x ys)
                         xs))) -}
ae56678b8820fae9a0a86a6810d7ce89
  getStatementPairs1 ::
    (LexerTypes.Statement, LexerTypes.Statement)
    -> (LexerTypes.Statement, LexerTypes.Statement) -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (LexerTypes.Statement, LexerTypes.Statement))
                   (w1 :: (LexerTypes.Statement, LexerTypes.Statement)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 BSV2PVS.$wlvl2 ww1 ww2 ww4 ww5 } }) -}
26773446c36d31961acdce66b4c7b96d
  getStruct ::
    LexerTypes.BSVType
    -> [LexerTypes.BSVInstDef] -> GHC.Base.Maybe LexerTypes.BSVInstDef
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
8e593028848aa8cace6aa95faf446231
  getStructType ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVType -> LexerTypes.BSVTypeDef
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m3, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVTypeDef]) (w1 :: LexerTypes.BSVType) ->
                 case BSV2PVS.$wgetStructType w w1 of ww { (#,#) ww1 ww2 ->
                 LexerTypes.BSV_Struct ww1 ww2 }) -}
7ae42893cf1655615e576f9ce4627bc7
  getSubinterfaceNames ::
    LexerTypes.BSVPackage -> [LexerTypes.InterfaceRef]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLLLLL),1*U(A,A,A,1*U,A,A,A,A,A,A,A)>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVPackage) ->
                 case w of ww { LexerTypes.BSVPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ->
                 BSV2PVS.getSubinterfaceNames_go ww4 }) -}
b031b994cabc0e788eded260c6115c4f
  getSubinterfaceNames_go ::
    [(LexerTypes.Name, [LexerTypes.MethodDec],
      [LexerTypes.InterfaceRef], [LexerTypes.InterfaceAttribute])]
    -> [LexerTypes.InterfaceRef]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c395128b5cc4a227efeae2b551404844
  getTheTopMod :: LexerTypes.BSVPackage -> LexerTypes.BSVModuleDec
  {- Arity: 1,
     Strictness: <S(LLLLLLLSLLL),1*U(A,A,A,A,A,A,A,1*U,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (u :: LexerTypes.BSVPackage) ->
                 case u of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                 BSV2PVS.getTheTopMod_topMod' ds8 }) -}
331ce09154d8506a0767a865710aa75f
  getTheTopMod_topMod' ::
    [LexerTypes.BSVModuleDec] -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [LexerTypes.BSVModuleDec]) ->
                 case BSV2PVS.$wtopMod'
                        w of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 }) -}
4a5978a2dbcf9972aa0d53d112e85707
  getTopPackageName' ::
    GHC.Base.String -> [LexerTypes.BSVPackage] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
c2bc8c2660a347d6376cb93674a969f0
  getTotalReturnExp ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,A,A,A)><S,U> -}
75dc6883eed45393988fb51ef98fadd1
  getTransitionName ::
    LexerTypes.TransitionTable -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.TransitionTable) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.getTransitionName1
                   LexerTypes.TransReg x ds1 -> x
                   LexerTypes.TransVect x ds1 ds2 -> x
                   LexerTypes.TransStruct x ds1 -> LexerTypes.ID x
                   LexerTypes.TransDWire x ds1 ds2 -> x }) -}
8725830b02fd3e4c25a4ebf124f45401
  getTransitionName1 :: LexerTypes.ID_Path
  {- Strictness: x -}
f75265bca347aacb30a3d4a059e6b377
  getTypeBitSize :: LexerTypes.BSVType -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.BSVType) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.getTypeBitSize2
                   LexerTypes.BSV_Bool -> BSV2PVS.getTypeBitSize1
                   LexerTypes.BSV_Bit n3 -> n3
                   LexerTypes.BSV_Int n3 -> n3
                   LexerTypes.BSV_UInt n3 -> n3 }) -}
616d867e36d60a13ede20135ca52f68e
  getTypeBitSize1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
c15658675824c7840e910aee2f48ff0a
  getTypeBitSize2 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
c9cb62b4e65a16bd9a978178152feee5
  getTypeDef ::
    [LexerTypes.BSVTypeDef] -> LexerTypes.Name -> LexerTypes.BSVTypeDef
  {- Arity: 2, Strictness: <S,1*U><S,U>m3, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVTypeDef]) (w1 :: LexerTypes.Name) ->
                 case BSV2PVS.$wgetTypeDef w w1 of ww { (#,#) ww1 ww2 ->
                 LexerTypes.BSV_Struct ww1 ww2 }) -}
cb42fa7fdafff3b40f5a81789a9f9e4a
  getVectIndex ::
    GHC.Base.String -> LexerTypes.Statement -> [LexerTypes.Expression]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
9adbc320b679ec9a50235c8e6d3bc46e
  getVectSize ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.ID_Path -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
a8fdcf43607912e01f174d84c7939e2c
  getVectorWrites ::
    GHC.Base.String -> LexerTypes.TotalTree -> [LexerTypes.Expression]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
49e580084921611b85923a8998615726
  getWireMCalls ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.TransitionTable]
    -> [GHC.Base.String]
    -> LexerTypes.Expression
    -> [LexerTypes.Expression]
  {- Arity: 5,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><S,1*U>,
     Unfolding: (\ (uni :: LexerTypes.BSVPackage)
                   (mod :: LexerTypes.BSVModuleDec)
                   (tables :: [LexerTypes.TransitionTable])
                   (path :: [GHC.Base.String])
                   (exp :: LexerTypes.Expression) ->
                 letrec {
                   go16 :: [LexerTypes.TransitionTable] -> [LexerTypes.Expression]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [LexerTypes.TransitionTable]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ LexerTypes.Expression
                       : y ys
                       -> case y of wild1 {
                            DEFAULT
                            -> case BSV2PVS.getWireMCalls1 ret_ty [LexerTypes.Expression] of {}
                            LexerTypes.TransDWire ds1 t ds2
                            -> GHC.Base.++
                                 @ LexerTypes.Expression
                                 (BSV2PVS.getMCallsOverTree uni mod t)
                                 (go16 ys) } }
                 } in
                 go16
                   (Data.Maybe.catMaybes1
                      @ LexerTypes.TransitionTable
                      (GHC.Base.map
                         @ LexerTypes.ID_Path
                         @ (GHC.Base.Maybe LexerTypes.TransitionTable)
                         (\ (x :: LexerTypes.ID_Path) ->
                          BSV2PVS.lookupWireTable
                            tables
                            (BSV2PVS.strings2idpath
                               (GHC.Base.++
                                  @ [GHC.Types.Char]
                                  path
                                  (case BSV2PVS.$widpath2strings x of ww { (#,#) ww1 ww2 ->
                                   GHC.Types.: @ GHC.Base.String ww1 ww2 }))))
                         (BSV2PVS.getReadsBy
                            mod
                            BSV2PVS.convertToFunction1
                            (GHC.Types.[] @ GHC.Base.String)
                            exp)))) -}
be8b8b753ac75a76670ddf3db2a44950
  getWireMCalls1 :: LexerTypes.SpecificTree
  {- Strictness: x -}
0d0cccdcad3087a0f42110238102823e
  getWireNames :: [LexerTypes.BSVstateDec] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
e14ee79668d423d2188d031c03cc2043
  getWrites ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.Statement]
    -> [LexerTypes.ID_Path]
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(A,A,A,A,A,A,U,U,A,A)><S,1*U> -}
0a7944ee9787aa30107c7f85963ead18
  groupByType ::
    [(LexerTypes.PVSType, GHC.Base.String)]
    -> [(LexerTypes.PVSType, [GHC.Base.String])]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4c556261d5620242938d2327afe0d413
  idInit :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   DEFAULT
                   -> case BSV2PVS.$widpath2strings wild of ww { (#,#) ww1 ww2 ->
                      BSV2PVS.strings2idpath (GHC.List.init1 @ GHC.Base.String ww1 ww2) }
                   LexerTypes.ID x -> wild }) -}
d9d26a14a119c0ae949c397631d41cd8
  idTopLevel :: LexerTypes.ID_Path -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct x y -> x
                   LexerTypes.ID x -> x
                   LexerTypes.ID_Vect x n3 -> x }) -}
8a117f4e4b7c21db8f4e025c57a6000c
  idpath2string :: LexerTypes.ID_Path -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
f8cd6fe226dc17ed3a95305ff93e6792
  idpath2strings :: LexerTypes.ID_Path -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.ID_Path) ->
                 case BSV2PVS.$widpath2strings w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Base.String ww1 ww2 }) -}
723c5cdee1ce913042622f89a6837bdc
  instantiateSubmod ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.BSVstateDec
    -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,A,A,A,1*U,A,A,A)><L,A><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: LexerTypes.BSVstateDec) ->
                 BSV2PVS.$winstantiateSubmod w w2) -}
cfbc881edc8976dfc42704cea836c64e
  instantiateSubmod1 :: LexerTypes.BSVModuleDec
  {- Strictness: x -}
434034b2549f4da2c7542196c43543d0
  instantiateSubmods ::
    GHC.Base.String -> LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 2, Strictness: <L,U><S,1*U(U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ (topMod :: GHC.Base.String)
                   (universe :: LexerTypes.BSVPackage) ->
                 case universe of wild { LexerTypes.BSVPackage ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 LexerTypes.BSVPackage
                   ds
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   (GHC.Types.:
                      @ LexerTypes.BSVModuleDec
                      (case BSV2PVS.getMod topMod ds7 of wild1 {
                         GHC.Base.Nothing -> BSV2PVS.instantiateSubmods3
                         GHC.Base.Just x
                         -> case x of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                            case BSV2PVS.$winstantiateSubmods'
                                   wild
                                   ww1
                                   ww2
                                   ww4
                                   ww5
                                   ww6
                                   ww7
                                   ww8
                                   ww9
                                   ww10 of ww11 { (#,,,,,,,,,#) ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                            LexerTypes.BSVModuleDec
                              ww12
                              BSV2PVS.instantiateSubmods1
                              ww14
                              ww15
                              ww16
                              ww17
                              ww18
                              ww19
                              ww20
                              ww21 } } })
                      (GHC.List.filter
                         @ LexerTypes.BSVModuleDec
                         (\ (x :: LexerTypes.BSVModuleDec) ->
                          case x of wild1 { LexerTypes.BSVModuleDec ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ->
                          case GHC.Base.eqString ds11 topMod of wild2 {
                            GHC.Types.False -> GHC.Types.True
                            GHC.Types.True -> GHC.Types.False } })
                         ds7))
                   ds8
                   ds9
                   ds10 }) -}
bd4cb4ef3a792abef27e42ac7d56e6ba
  instantiateSubmods' ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 2,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S,1*U(U,U,A,U,U,U,U,U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVPackage) (w1 :: LexerTypes.BSVModuleDec) ->
                 case w1 of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 case BSV2PVS.$winstantiateSubmods'
                        w
                        ww1
                        ww2
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10 of ww11 { (#,,,,,,,,,#) ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                 LexerTypes.BSVModuleDec
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17
                   ww18
                   ww19
                   ww20
                   ww21 } }) -}
ea1a9adecbdca9d043d0b1c13f9f63b3
  instantiateSubmods1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.instantiateSubmods2) -}
2f720cbfe2ac2776887a6f4d1b86abd9
  instantiateSubmods2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("root"#) -}
15d3dcea529ea35c3b4bfd5dbf2a55fd
  instantiateSubmods3 :: LexerTypes.BSVModuleDec
  {- Strictness: x -}
c2c714efc3cc4ad2565347fdcf132f85
  interfaceLookup ::
    GHC.Types.Int
    -> GHC.Base.String
    -> [LexerTypes.MidModInterfaceDec]
    -> GHC.Base.Maybe [LexerTypes.MethodBody]
  {- Arity: 3, Strictness: <S(S),1*U(1*U)><L,U><S,1*U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Base.String)
                   (w2 :: [LexerTypes.MidModInterfaceDec]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BSV2PVS.$winterfaceLookup ww1 w1 w2 }) -}
c0e7ea58ca971cd553805222ce3590ca
  interfaceLookup1 ::
    (GHC.Base.String, GHC.Base.String, [LexerTypes.MethodBody])
    -> (GHC.Base.String, [LexerTypes.MethodBody])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y z -> (y, z) }) -}
12e98b589cb35f1983dd0288d628178a
  interfaceLookup2 ::
    (GHC.Base.String, GHC.Base.String, [LexerTypes.MethodBody])
    -> (GHC.Base.String, [LexerTypes.MethodBody])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y z -> (x, z) }) -}
57dfc5ddc72fa67fc62187ffe40f8079
  interfaceLookup3 :: GHC.Base.Maybe [LexerTypes.MethodBody]
  {- Strictness: x -}
c1d39035febd90a4f2a6a91bffb892f4
  isAboveOrAt ::
    [GHC.Base.String] -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
06617efaad29b40c21364e329ddeec85
  isAction ::
    LexerTypes.BSVModuleDec -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLLSLL),1*U(A,A,A,A,A,A,A,1*U,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec) (x :: GHC.Base.String) ->
                 case mod of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   x
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n3 :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (LexerTypes.ActionName, [LexerTypes.Statement],
                            [LexerTypes.ActionAttribute])
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ (LexerTypes.ActionName, [LexerTypes.Statement],
                               [LexerTypes.ActionAttribute])
                            c
                            BSV2PVS.isAction1)
                         n3
                         ds8)) }) -}
31f22b9ad02f4196bec73cb66021b22d
  isAction1 ::
    (LexerTypes.ActionName, [LexerTypes.Statement],
     [LexerTypes.ActionAttribute])
    -> LexerTypes.ActionName
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.ActionName, [LexerTypes.Statement],
                           [LexerTypes.ActionAttribute])) ->
                 case ds of wild { (,,) x ds1 ds2 -> x }) -}
9a65366407f4efbfd223c7f125c3a6e2
  isClearAnterior ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.RuleDec
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,U,A,A)><S,1*U(A,A,U,A)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: LexerTypes.RuleDec)
                   (w3 :: [LexerTypes.ID_Path]) ->
                 case w2 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 BSV2PVS.$wisClearAnterior w w1 ww3 w3 }) -}
07461f41296f177ece963e483d735d26
  isClearAnterior1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.isClearAnterior2) -}
eaa4c39c24d3136a44518178fa2cf36e
  isClearAnterior2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("enq"#) -}
a23d033e258f81a5f5e0ccc1711c3726
  isClearAnterior3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.isClearAnterior4) -}
cf0847e965c6816c17aafee16fb749b0
  isClearAnterior4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("deq"#) -}
68279ac2d27f705b6ae5d0108ec585f0
  isClearAnterior5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.isClearAnterior6) -}
9b6f6b3969fa9f2a937da60ee236ac86
  isClearAnterior6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("first"#) -}
6730123eb679d91c012ddb9ddd71869d
  isDWire ::
    LexerTypes.BSVModuleDec -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)><S,1*U> -}
5231a352e5f98964bf51a78011038513
  isDWire' ::
    [LexerTypes.BSVstateDec] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
72167acf763d0002287b7471291410a2
  isDeqAnterior ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.RuleDec
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.ID_Path]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,A,U,A,A,A,U,U,A,A)><S,1*U(A,A,1*U,A)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: LexerTypes.RuleDec)
                   (w3 :: [LexerTypes.ID_Path]) ->
                 case w2 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 BSV2PVS.$wisDeqAnterior w w1 ww3 w3 }) -}
1722084240ded9c8c85546ee2ddaa6a6
  isFullySplit :: LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
e69736a25839937709c7b2fa2f66ebde
  isFullySplitCase :: LexerTypes.Case -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) ds1 stmt -> BSV2PVS.isFullySplit stmt }) -}
efdba0e33bf8b5a02b352797f13d4756
  isIDPrefix ::
    GHC.Base.String -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.String) (ds1 :: LexerTypes.ID_Path) ->
                 case ds1 of wild {
                   LexerTypes.ID_Submod_Struct x' y -> GHC.Base.eqString ds x'
                   LexerTypes.ID ds2 -> GHC.Types.False
                   LexerTypes.ID_Vect ipv ipv1 -> BSV2PVS.isIDPrefix1 }) -}
6f6a4dd57889a193ce144fb74b9ea944
  isIDPrefix1 :: GHC.Types.Bool
  {- Strictness: x -}
eb63f3d6a3d577b8ca2df2441897bc27
  isInSubmod ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S(LLLLLLSLLL),1*U(A,A,A,A,A,A,1*U,A,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wisInSubmod w ww7 w2 }) -}
35c38db22a4b5f83d00cacf73bf57f84
  isInWhichSubmod ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> LexerTypes.BSVModuleDec
  {- Arity: 3,
     Strictness: <S(LLLLLLLSLLL),1*U(A,A,A,A,A,A,A,U,A,A,A)><L,1*U(A,A,A,A,A,A,U,A,A,A)><L,A>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { LexerTypes.BSVPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ->
                 BSV2PVS.$wisInWhichSubmod ww8 w1 }) -}
16ebbb90140bb597e9ba86c327a158b7
  isInWhichSubmod1 :: LexerTypes.BSVModuleDec
  {- Strictness: x -}
34a68ec02b688faaf2d382c5ac2a14db
  isInWhichSubmod10 :: [LexerTypes.BSVTypeDef]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.BSVTypeDef]
                   BSV2PVS.isInWhichSubmod11) -}
4763d0c9504bfef0b2eeffd2296454d2
  isInWhichSubmod11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [BSVTypeDef]"#) -}
4d495aaf0de1b418d521b966e82eabcd
  isInWhichSubmod12 :: [LexerTypes.BSVConstantDec]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.BSVConstantDec]
                   BSV2PVS.isInWhichSubmod13) -}
20d642d22b840e0a83649bab2d8eb551
  isInWhichSubmod13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [BSVConstantDec]"#) -}
4e0eeded69f0ef26cb7cd93e43c6bbad
  isInWhichSubmod14 :: [LexerTypes.InterfaceDec]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.InterfaceDec]
                   BSV2PVS.isInWhichSubmod15) -}
677f949fa1dea9e3bd8889a44fe4e7de
  isInWhichSubmod15 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [InterfaceDec]"#) -}
c9d738abf63afba04af53dc07214bcaf
  isInWhichSubmod16 :: [GHC.Base.String]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [GHC.Base.String]
                   BSV2PVS.isInWhichSubmod17) -}
2edb5adb346da40b4abc9ff38828f0f5
  isInWhichSubmod17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [String]"#) -}
f2619d1d6c5acec34c0806f45dbde213
  isInWhichSubmod18 :: [LexerTypes.PackageName]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.PackageName]
                   BSV2PVS.isInWhichSubmod19) -}
bf8761d0bd27fb0e1f02ff128adefcf2
  isInWhichSubmod19 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [PackageName]"#) -}
b45e3db3856e2904245bf6161750e058
  isInWhichSubmod2 :: [LexerTypes.HexFile]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.HexFile]
                   BSV2PVS.isInWhichSubmod3) -}
02bae15ca6be1ad092fa7714ac9ee8e3
  isInWhichSubmod20 :: LexerTypes.PackageName
  {- Unfolding: (Control.Exception.Base.absentError
                   @ LexerTypes.PackageName
                   BSV2PVS.isInWhichSubmod21) -}
94341693073d76fae06dc8ea9f49ba97
  isInWhichSubmod21 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww PackageName"#) -}
38a6d546e3eecab08f738bb7248623ef
  isInWhichSubmod3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [HexFile]"#) -}
7a0043d66be8a0d3a57995f7f24f4a43
  isInWhichSubmod4 :: [LexerTypes.BSVMacro]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.BSVMacro]
                   BSV2PVS.isInWhichSubmod5) -}
c8fe50a76cd50a195a48a8a044f79519
  isInWhichSubmod5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [BSVMacro]"#) -}
aaea2a98359de36a0573bb7ff79dcf83
  isInWhichSubmod6 :: [LexerTypes.BSVFunction]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.BSVFunction]
                   BSV2PVS.isInWhichSubmod7) -}
88f12ff75ed70f05a9c149d0650a204c
  isInWhichSubmod7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [BSVFunction]"#) -}
7437a30e70d36fd15644407e60c7b48a
  isInWhichSubmod8 :: [LexerTypes.BSVInstDef]
  {- Unfolding: (Control.Exception.Base.absentError
                   @ [LexerTypes.BSVInstDef]
                   BSV2PVS.isInWhichSubmod9) -}
0857dd136bc8a3602a46affc0b88cd96
  isInWhichSubmod9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ww [BSVInstDef]"#) -}
a38731584463b8a9f00d46a482ea2f59
  isInWhichSubmod_go2 ::
    [[GHC.Types.Char]] -> [GHC.Types.Bool] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
55d121049ca84ebecac0cb2893030292
  isLocalDec :: LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
0a18e6662d834c2fc70b15b0333dd5e2
  isMethod ::
    LexerTypes.BSVModuleDec -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLS),1*U(A,A,A,A,A,A,A,A,A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec) (x :: GHC.Base.String) ->
                 case mod of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   x
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n3 :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                            LexerTypes.Guard, [LexerTypes.Statement],
                            [LexerTypes.MethodBodyAttribute])
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                               LexerTypes.Guard, [LexerTypes.Statement],
                               [LexerTypes.MethodBodyAttribute])
                            c
                            BSV2PVS.getMethNames'1)
                         n3
                         ds10)) }) -}
4aa799d729e80c61c3c04092a4ec34b9
  isNext :: [GHC.Base.String] -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
68b6dff166651f05c8eef4085940ed55
  isReferencedAnywhere ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.LocalVar
    -> [LexerTypes.LocalVar]
    -> LexerTypes.Statement
    -> GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,A,A)><S,1*U><L,U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: LexerTypes.LocalVar)
                   (w2 :: [LexerTypes.LocalVar])
                   (w3 :: LexerTypes.Statement) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 BSV2PVS.$wisReferencedAnywhere w ww1 w2 w3 }) -}
fdd4abfd810ddeac2b9421c34c77f933
  isReferencedin ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.LocalVar -> LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: LexerTypes.LocalVar)
                   (w2 :: LexerTypes.Statement) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 BSV2PVS.$wisReferencedin w ww1 w2 }) -}
2d1ae543682990b6269c9364ae1718ae
  isReferencedinExp ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.LocalVar -> LexerTypes.Expression -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (m :: LexerTypes.BSVModuleDec)
                   (ds :: (LexerTypes.ID_Path,
                           Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType),
                           LexerTypes.Expression))
                   (exp :: LexerTypes.Expression) ->
                 case ds of wild { (,,) n3 ds1 ds2 ->
                 GHC.List.elem
                   @ LexerTypes.ID_Path
                   LexerTypes.$fEqID_Path
                   n3
                   (BSV2PVS.getReadsBy
                      m
                      BSV2PVS.convertToFunction1
                      (GHC.Types.[] @ GHC.Base.String)
                      exp) }) -}
e03f1051a3c9d2d7f758ebf2e7c11f63
  isRule ::
    LexerTypes.BSVModuleDec -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLLLSL),1*U(A,A,A,A,A,A,A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec) (x :: GHC.Base.String) ->
                 case mod of wild { LexerTypes.BSVModuleDec ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   x
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n3 :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                            [LexerTypes.RuleAttribute])
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                               [LexerTypes.RuleAttribute])
                            c
                            BSV2PVS.isRule1)
                         n3
                         ds9)) }) -}
5f8686865050abfc88e187b452ed94af
  isRule1 ::
    (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
     [LexerTypes.RuleAttribute])
    -> LexerTypes.RuleName
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.RuleName, LexerTypes.Guard,
                           [LexerTypes.Statement], [LexerTypes.RuleAttribute])) ->
                 case ds of wild { (,,,) x ds1 ds2 ds3 -> x }) -}
c40b70d5d9bbd2218f58bca1ed45ace3
  isStatementMatch ::
    LexerTypes.Statement -> LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
78c3198bf663b21db94b0327e64c02d6
  isSubMethod ::
    LexerTypes.BSVModuleDec -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(LLLLLLLLLS),1*U(A,A,A,A,A,A,A,A,A,1*U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: LexerTypes.ID_Path) ->
                 case w of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wisSubMethod ww10 w1 }) -}
31cc49141577a8f6a8dc441b432c394a
  isThisLDec ::
    LexerTypes.ID_Path -> LexerTypes.Statement -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
22d1708fcacc9ad6ecb1a41c4bde2152
  isWire ::
    [LexerTypes.BSVstateDec] -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (st :: [LexerTypes.BSVstateDec]) (i :: LexerTypes.ID_Path) ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   (BSV2PVS.showIDPath i)
                   (BSV2PVS.getWireNames st)) -}
fe6beb2b4dbb1013c0cab6fd384250bd
  isWireAnterior ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.RuleDec
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.ID_Path]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S(LSLL),1*U(A,1*U,1*U,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: LexerTypes.RuleDec)
                   (w2 :: [LexerTypes.ID_Path]) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 BSV2PVS.$wisWireAnterior w ww2 ww3 w2 }) -}
0a343ea4475f25ddda14d2ae54400a28
  keepLDec ::
    LexerTypes.ID_Path -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
4fb23aad7ed75ae45d35d543580212cf
  killDeadRefs ::
    [LexerTypes.RuleNode]
    -> [LexerTypes.RuleNode] -> [LexerTypes.RuleNode]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
d2074c4447439dbf072d0a1c20ba4699
  killNonreferencedMethods ::
    [GHC.Base.String]
    -> ([GHC.Base.String], LexerTypes.ValueMethod)
    -> ([GHC.Base.String], LexerTypes.ValueMethod)
  {- Arity: 2, Strictness: <L,1*U><S,1*U(1*U,U(U,U,U,U,U,U,U))>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Base.String])
                   (w1 :: ([GHC.Base.String], LexerTypes.ValueMethod)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case BSV2PVS.$wkillNonreferencedMethods
                        w
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
3b5f535dc5e7057a790227cc2e8a75e4
  killNonreferencedMethods1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.getMethodDependencies1) -}
0dccd7e9f4be70c42f70e3234e19dbbf
  killSidewaysReferences ::
    LexerTypes.BSVPackage
    -> ([GHC.Base.String], LexerTypes.ValueMethod)
    -> ([GHC.Base.String], LexerTypes.ValueMethod)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (uni :: LexerTypes.BSVPackage)
                   (ds :: ([GHC.Base.String], LexerTypes.ValueMethod)) ->
                 case ds of wild { (,) mCalls meth ->
                 (GHC.Base.build
                    @ [GHC.Types.Char]
                    (\ @ b
                       (c :: [GHC.Types.Char] -> b -> b)[OneShot]
                       (n3 :: b)[OneShot] ->
                     GHC.Base.foldr
                       @ [GHC.Types.Char]
                       @ b
                       (GHC.List.filterFB
                          @ [GHC.Types.Char]
                          @ b
                          c
                          BSV2PVS.killSidewaysReferences1)
                       n3
                       mCalls),
                  meth) }) -}
047795bb25502940069b272780f2abdb
  killSidewaysReferences1 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: GHC.Base.String) -> GHC.Types.True) -}
156406b3c434c8d8335b5fb688d8bb45
  killSupremumReference ::
    LexerTypes.ActionPath
    -> LexerTypes.RuleSchedule -> LexerTypes.RuleSchedule
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,1*U,1*U,1*U,1*U)>,
     Unfolding: (\ (x :: LexerTypes.ActionPath)
                   (r :: LexerTypes.RuleSchedule) ->
                 case r of wild { LexerTypes.RuleSchedule ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 LexerTypes.RuleSchedule
                   ds
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   ds7
                   ds8
                   ds9
                   ds10
                   ds11
                   ds12
                   ds13
                   (GHC.List.filter
                      @ LexerTypes.ActionPath
                      (LexerTypes.$fEqActionPath_$c/= x)
                      ds14)
                   (GHC.List.filter
                      @ LexerTypes.ActionPath
                      (LexerTypes.$fEqActionPath_$c/= x)
                      ds15)
                   (GHC.List.filter
                      @ LexerTypes.ActionPath
                      (LexerTypes.$fEqActionPath_$c/= x)
                      ds16)
                   (GHC.List.filter
                      @ LexerTypes.ActionPath
                      (LexerTypes.$fEqActionPath_$c/= x)
                      ds17) }) -}
17cd0257febdb13417cc041f29275f3e
  killSupremumReferences ::
    LexerTypes.ActionPath
    -> [LexerTypes.RuleSchedule] -> [LexerTypes.RuleSchedule]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: LexerTypes.ActionPath)
                   (ds1 :: [LexerTypes.RuleSchedule]) ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ LexerTypes.RuleSchedule
                   : ipv ipv1
                   -> GHC.Base.build
                        @ LexerTypes.RuleSchedule
                        (\ @ b1
                           (c :: LexerTypes.RuleSchedule -> b1 -> b1)[OneShot]
                           (n3 :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ LexerTypes.RuleSchedule
                           @ b1
                           (GHC.Base.mapFB
                              @ LexerTypes.RuleSchedule
                              @ b1
                              @ LexerTypes.RuleSchedule
                              c
                              (BSV2PVS.killSupremumReference ds))
                           n3
                           wild) }) -}
ed641e41ebd534b5a60bba6038984b22
  killVoids :: [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a158c4fed81498ae8dd9d7ffe1bb46f3
  lDecExpressionize ::
    [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, Strictness: <S,1*U> -}
a9db344246178ac214e75fbfd457a09f
  lDecExpressionize' ::
    [LexerTypes.Statement]
    -> LexerTypes.LocalVar
    -> (LexerTypes.LocalVar, [LexerTypes.Statement])
  {- Arity: 2, Strictness: <L,U><S,1*U(U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.Statement]) (w1 :: LexerTypes.LocalVar) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case BSV2PVS.$wlDecExpressionize'
                        w
                        ww1
                        ww2
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6) } }) -}
aefac010b437b200fab75f1a98e1fd71
  lastAP :: LexerTypes.ActionPath -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
eef7a3daf78b2fcf8be4da5f80746c74
  lastID :: LexerTypes.ID_Path -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
e8617a36a9fd74128208c6d09afece80
  letPreproc :: LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,A,1*U)>,
     Unfolding: (\ (universe :: LexerTypes.BSVPackage) ->
                 LexerTypes.BSVPackage
                   (LexerTypes.bsv_packageName universe)
                   (LexerTypes.imports universe)
                   (LexerTypes.including universe)
                   (LexerTypes.interfaces universe)
                   (LexerTypes.bsv_constants universe)
                   (LexerTypes.bsv_typedefs universe)
                   (LexerTypes.bsv_instDefs universe)
                   (case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                    GHC.Base.map
                      @ LexerTypes.BSVModuleDec
                      @ LexerTypes.BSVModuleDec
                      BSV2PVS.letPreproc2
                      ds8 })
                   (case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                    GHC.Base.map
                      @ (GHC.Base.String, [LexerTypes.Argument], LexerTypes.BSVType,
                         [LexerTypes.Statement])
                      @ (GHC.Base.String, [LexerTypes.Argument], LexerTypes.BSVType,
                         [LexerTypes.Statement])
                      BSV2PVS.letPreproc1
                      ds9 })
                   (GHC.Types.[] @ LexerTypes.BSVMacro)
                   (LexerTypes.hexFiles universe)) -}
1fbbba359e51b148d856bcfb6aef4b43
  letPreproc1 ::
    (GHC.Base.String, [LexerTypes.Argument], LexerTypes.BSVType,
     [LexerTypes.Statement])
    -> LexerTypes.BSVFunction
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Base.String, [LexerTypes.Argument],
                          LexerTypes.BSVType, [LexerTypes.Statement])) ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    (\ (w1 :: LexerTypes.Statement) -> BSV2PVS.$wdinvStmt w1)
                    (BSV2PVS.lpStmts ww4)) }) -}
41f3b1b477a71233fcf826e63164d759
  letPreproc2 :: LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LexerTypes.BSVModuleDec) ->
                 BSV2PVS.convertVectors (BSV2PVS.lpMod x)) -}
aaa9ab6f009acc74b4516dd46dee25a8
  lookupBy ::
    (a -> b -> GHC.Types.Bool) -> a -> [(b, c)] -> GHC.Base.Maybe c
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U> -}
e1bb0771622074ebcfeeb5492b5cfb05
  lookupInst ::
    [LexerTypes.BSVInstDef] -> GHC.Base.String -> LexerTypes.BSVInstDef
  {- Arity: 2, Strictness: <S,1*U><S,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVInstDef]) (w1 :: GHC.Base.String) ->
                 case BSV2PVS.$wlookupInst w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
56102467fb48b298801897ebc694d4b6
  lookupInst' ::
    [LexerTypes.BSVInstDef]
    -> LexerTypes.BSVType -> LexerTypes.BSVInstDef
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVInstDef]) (w1 :: LexerTypes.BSVType) ->
                 case BSV2PVS.$wlookupInst' w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
b966c56f91ae3adc419a2eaf43797a31
  lookupWireTable ::
    [LexerTypes.TransitionTable]
    -> LexerTypes.ID_Path -> GHC.Base.Maybe LexerTypes.TransitionTable
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
7943dd36f8bc5898e2a510d4cef5117b
  lpAct :: LexerTypes.ActionDec -> LexerTypes.ActionDec
  {- Arity: 1, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.ActionName, [LexerTypes.Statement],
                           [LexerTypes.ActionAttribute])) ->
                 case ds of wild { (,,) x y z -> (x, BSV2PVS.lpStmts y, z) }) -}
ffdc20a85baf56ab9efb05f617125b3d
  lpFun :: LexerTypes.BSVFunction -> LexerTypes.BSVFunction
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Base.String, [LexerTypes.Argument],
                           LexerTypes.BSVType, [LexerTypes.Statement])) ->
                 case ds of wild { (,,,) n3 a t stmts ->
                 (n3, a, t, BSV2PVS.lpStmts stmts) }) -}
040bfe492045b6678cb83155b239ff29
  lpInter ::
    LexerTypes.MidModInterfaceDec -> LexerTypes.MidModInterfaceDec
  {- Arity: 1, Strictness: <S,1*U(U,U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y ms ->
                 (x, y,
                  GHC.Base.build
                    @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                       LexerTypes.Guard, [LexerTypes.Statement],
                       [LexerTypes.MethodBodyAttribute])
                    (\ @ b1
                       (c :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                              LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                              [LexerTypes.MethodBodyAttribute])
                             -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                          LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.MethodBodyAttribute])
                       @ b1
                       (GHC.Base.mapFB
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          @ b1
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          c
                          BSV2PVS.lpMet)
                       n3
                       ms)) }) -}
379b72486725b7fc015068cef78c23a9
  lpMet :: LexerTypes.MethodBody -> LexerTypes.MethodBody
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) u v w x y z ->
                 (u, v, w, x, BSV2PVS.lpStmts y, z) }) -}
90a9d4e14a86ca00ecdd13aab4c733cf
  lpMod :: LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 case BSV2PVS.$wlpMod
                        w of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 }) -}
ad337cbaef1f123750daf9a417ea17d2
  lpRul :: LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.RuleName, LexerTypes.Guard,
                           [LexerTypes.Statement], [LexerTypes.RuleAttribute])) ->
                 case ds of wild { (,,,) w x y z ->
                 (w, x, BSV2PVS.lpStmts y, z) }) -}
b070b05372a094da0f56c8c6f2eaa5d5
  lpStmt :: LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U> -}
0039c004a5f637eb4a21a18c3d59f071
  lpStmts :: [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (stmts :: [LexerTypes.Statement]) ->
                 case BSV2PVS.getLets stmts of wild {
                   []
                   -> GHC.Base.map
                        @ LexerTypes.Statement
                        @ LexerTypes.Statement
                        BSV2PVS.lpStmt
                        stmts
                   : ds1 ds2
                   -> GHC.Types.:
                        @ LexerTypes.Statement
                        (case BSV2PVS.$wamalgamateLets
                                wild
                                (letrec {
                                   go16 :: [LexerTypes.Statement] -> [LexerTypes.Statement]
                                     {- Arity: 1, Strictness: <S,1*U> -}
                                   = \ (ds :: [LexerTypes.Statement]) ->
                                     case ds of wild1 {
                                       [] -> GHC.Types.[] @ LexerTypes.Statement
                                       : y ys
                                       -> case GHC.List.elem
                                                 @ LexerTypes.Statement
                                                 LexerTypes.$fEqStatement
                                                 y
                                                 wild of wild2 {
                                            GHC.Types.False
                                            -> GHC.Types.:
                                                 @ LexerTypes.Statement
                                                 (BSV2PVS.lpStmt y)
                                                 (go16 ys)
                                            GHC.Types.True -> go16 ys } }
                                 } in
                                 go16 stmts) of ww { (#,,#) ww1 ww2 ww3 ->
                         LexerTypes.LocalDec ww1 ww2 ww3 })
                        (GHC.Types.[] @ LexerTypes.Statement) }) -}
375a2eaa7a7a7e0dc6e3d82cfdf9b050
  mBody2MDec :: LexerTypes.MethodBody -> LexerTypes.MethodDec
  {- Arity: 1, Strictness: <S,1*U(U,U,1*U,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) nom typ args ds1 ds2 ds3 ->
                 (nom, typ, BSV2PVS.utArg2Arg args,
                  GHC.Types.[] @ LexerTypes.MethodDecAttribute) }) -}
07ca8c77d82e7247fe5c4222b29a9bb7
  makeActionPath :: [GHC.Base.String] -> LexerTypes.ActionPath
  {- Arity: 1, Strictness: <S,1*U> -}
848a1e38b1430871b626440b09f5bb63
  makeActionPath' ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> LexerTypes.ActionPath
  {- Arity: 3,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S(LLLLLLLSLL),1*U(1*U,1*U,1*U,1*U,A,A,U,U,U,U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wmakeActionPath'
                   w
                   ww1
                   ww2
                   ww3
                   ww4
                   ww7
                   ww8
                   ww9
                   ww10
                   w2 }) -}
a2ff72ff690aa09e2f64bd3c7902486b
  makeCallSpecificTree ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.TotalTree
    -> LexerTypes.SpecificTree
  {- Arity: 6,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A)><L,U><L,U><L,U><L,U><S,1*U> -}
4a39cba491b558fda31c258bade70ec3
  makeCallTreesSpecific ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> GHC.Base.String
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.TotalTree
    -> LexerTypes.SpecificTree
  {- Arity: 6,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A)><L,U><L,U><L,U><L,U><S,1*U>,
     Unfolding: (\ (mod :: LexerTypes.BSVModuleDec)
                   (fifoName :: LexerTypes.ID_Path)
                   (methName :: GHC.Base.String)
                   (prefixes :: [GHC.Base.String])
                   (ex :: [GHC.Base.String])
                   (tree :: LexerTypes.TotalTree) ->
                 BSV2PVS.simplifySpecificTree2
                   (BSV2PVS.simplifySpecificTree
                      (BSV2PVS.replaceSkips
                         BSV2PVS.makeCallTreesSpecific1
                         (BSV2PVS.simplifySpecificTree4
                            (BSV2PVS.makeCallSpecificTree
                               mod
                               fifoName
                               methName
                               prefixes
                               ex
                               tree))))) -}
60ed2127aa19da7b1a959f5abbf32574
  makeCallTreesSpecific1 :: LexerTypes.ID_Path
  {- Strictness: m2,
     Unfolding: (LexerTypes.ID BSV2PVS.makeCallTreesSpecific2) -}
1780572bd8fe71056f0443ae89419e2d
  makeCallTreesSpecific2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.makeCallTreesSpecific3) -}
727a482f2a9a26164e110969bb0fd24c
  makeCallTreesSpecific3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Nothing"#) -}
e49a9396e0ec62c91441346f100f8950
  makeSpecificTree ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.TotalTree
    -> LexerTypes.SpecificTree
  {- Arity: 5,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A)><L,U><L,U><L,U><S,1*U> -}
b084e3e9e3792b88290a79e2b32cb24b
  makeStateFromStruct ::
    LexerTypes.BSVInstDef
    -> LexerTypes.BSVTypeDef
    -> LexerTypes.ID_Path
    -> [LexerTypes.BSVstateDec]
  {- Arity: 3, Strictness: <L,1*U(A,U)><S,U><L,U> -}
6719da9b2788be24d504d9c4d490710b
  makeStatesFromStruct ::
    [LexerTypes.BSVInstDef]
    -> LexerTypes.BSVTypeDef
    -> LexerTypes.ID_Path
    -> [LexerTypes.BSVstateDec]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ (insts :: [LexerTypes.BSVInstDef])
                   (ds :: LexerTypes.BSVTypeDef)
                   (localPath :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.makeStatesFromStruct2
                   LexerTypes.BSV_Struct n3 fs
                   -> BSV2PVS.makeStateFromStruct
                        (case BSV2PVS.getInstDef insts n3 of wild1 {
                           GHC.Base.Nothing -> BSV2PVS.makeStatesFromStruct1 insts n3
                           GHC.Base.Just x -> x })
                        wild
                        localPath }) -}
4a4a36b3382d377452f59b5fc33c8ef4
  makeStatesFromStruct1 ::
    [LexerTypes.BSVInstDef] -> LexerTypes.Name -> LexerTypes.BSVInstDef
  {- Arity: 2, Strictness: <B,1*U><B,1*U>x -}
30bb873f6fd46b07eb315510fb15079f
  makeStatesFromStruct2 :: [LexerTypes.BSVstateDec]
  {- Strictness: x -}
5e890a82e06037b63a0537688617411b
  makeTreesSpecific ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.BSVstateDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.TotalTree
    -> GHC.Base.Maybe LexerTypes.Expression
    -> LexerTypes.SpecificTree
  {- Arity: 6,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A)><S,1*U><L,U><L,U><S,1*U><L,1*U>,
     Unfolding: (\ (mod :: LexerTypes.BSVModuleDec)
                   (ds :: LexerTypes.BSVstateDec)
                   (prefixes :: [GHC.Base.String])
                   (ex :: [GHC.Base.String])
                   (tree :: LexerTypes.TotalTree)
                   (ds1 :: GHC.Base.Maybe LexerTypes.Expression) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.makeTreesSpecific2
                   LexerTypes.BSV_Reg n3 t ini
                   -> BSV2PVS.simplifySpecificTree2
                        (BSV2PVS.simplifySpecificTree
                           (BSV2PVS.replaceSkips
                              n3
                              (BSV2PVS.simplifySpecificTree4
                                 (BSV2PVS.makeSpecificTree mod n3 prefixes ex tree))))
                   LexerTypes.BSV_Fifo f n3 t
                   -> BSV2PVS.simplifySpecificTree2
                        (BSV2PVS.simplifySpecificTree
                           (BSV2PVS.replaceSkips
                              n3
                              (BSV2PVS.simplifySpecificTree4
                                 (BSV2PVS.makeSpecificTree mod n3 prefixes ex tree))))
                   LexerTypes.BSV_Vector ds2 t num ini
                   -> case ds2 of wild1 {
                        DEFAULT
                        -> case ds1 of wild2 {
                             GHC.Base.Nothing -> BSV2PVS.makeTreesSpecific1
                             GHC.Base.Just ipv -> BSV2PVS.makeTreesSpecific2 }
                        LexerTypes.ID n3
                        -> case ds1 of wild2 {
                             GHC.Base.Nothing -> BSV2PVS.makeTreesSpecific1
                             GHC.Base.Just exp
                             -> BSV2PVS.simplifySpecificTree2
                                  (BSV2PVS.simplifySpecificTree
                                     (BSV2PVS.replaceSkips
                                        BSV2PVS.makeCallTreesSpecific1
                                        (BSV2PVS.simplifySpecificTree4
                                           (BSV2PVS.makeSpecificTree
                                              mod
                                              (LexerTypes.ID_Vect n3 exp)
                                              prefixes
                                              ex
                                              tree)))) } }
                   LexerTypes.DWire n3 t ini
                   -> BSV2PVS.simplifySpecificTree2
                        (BSV2PVS.simplifySpecificTree
                           (BSV2PVS.replaceSkips
                              n3
                              (BSV2PVS.simplifySpecificTree4
                                 (BSV2PVS.makeSpecificTree mod n3 prefixes ex tree)))) }) -}
3dc33df83eac2b7176653853c474e7f7
  makeTreesSpecific1 :: LexerTypes.SpecificTree
  {- Strictness: x -}
52e3acae5f372fb0c1a510edef99ae1c
  makeTreesSpecific2 :: LexerTypes.SpecificTree
  {- Strictness: x -}
45779d49ed087d0d78128fc81069dc78
  matchLVs ::
    [LexerTypes.LocalVar]
    -> [LexerTypes.LocalVar]
    -> LexerTypes.Expression
    -> [LexerTypes.LocalVar]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
41c49e25c0c8fb20eb41d4093dd96c74
  matchingExp ::
    LexerTypes.ID_Path
    -> [LexerTypes.LocalVar] -> LexerTypes.Expression
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
0f35f5deff6b8b6aadf2ef1fecf2c14f
  maybeToEmpty :: [GHC.Base.Maybe a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6874459be5da447266d4a9738f528233
  mergeAP ::
    [GHC.Base.String] -> GHC.Base.String -> LexerTypes.ActionPath
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
eaf653146b422a1702908a324b8607eb
  mergeActionPaths ::
    [LexerTypes.ActionPath] -> LexerTypes.ActionPath
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ap :: [LexerTypes.ActionPath]) ->
                 case ap of wild {
                   [] -> case GHC.List.badHead ret_ty LexerTypes.ActionPath of {}
                   : x ds1
                   -> BSV2PVS.mergeAP
                        (BSV2PVS.getAPPath x)
                        (case GHC.Base.map
                                @ LexerTypes.ActionPath
                                @ [GHC.Types.Char]
                                BSV2PVS.lastAP
                                wild of wild1 {
                           [] -> GHC.Types.[] @ GHC.Types.Char
                           : x1 xs1
                           -> Data.OldList.intercalate_$spoly_go
                                @ GHC.Types.Char
                                x1
                                (Data.OldList.prependToAll
                                   @ [GHC.Types.Char]
                                   BSV2PVS.mergeActionPaths1
                                   xs1) }) }) -}
8f208d0d6d50de2910fb4c25505d50ce
  mergeActionPaths1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.applyNumbering2) -}
392db0d6a36a0d4b230a38a8b48380c3
  mergeDeeperLets ::
    ([LexerTypes.Statement], [LexerTypes.Statement])
    -> [LexerTypes.Statement]
    -> ([LexerTypes.Statement], [LexerTypes.Statement])
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: ([LexerTypes.Statement], [LexerTypes.Statement]))
                   (w1 :: [LexerTypes.Statement]) ->
                 case w of ww { (,) ww1 ww2 ->
                 case BSV2PVS.$wmergeDeeperLets ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
25b182ff97517c14b563194e4204873e
  mergeIDPaths ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><L,U>m1, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.ID_Path) (w1 :: LexerTypes.ID_Path) ->
                 case BSV2PVS.$wmergeIDPaths w w1 of ww { (#,#) ww1 ww2 ->
                 LexerTypes.ID_Submod_Struct ww1 ww2 }) -}
e91038aec7f07f4d862770b0f9e85083
  mergeLocalVars ::
    LexerTypes.LocalVar
    -> (LexerTypes.Expression -> LexerTypes.Expression)
    -> LexerTypes.LocalVar
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U,U)><L,1*C1(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (LexerTypes.ID_Path,
                           Data.Either.Either
                             (GHC.Base.Maybe LexerTypes.BSVType)
                             (GHC.Base.Maybe LexerTypes.PVSType),
                           LexerTypes.Expression))
                   (fExp :: LexerTypes.Expression -> LexerTypes.Expression) ->
                 case ds of wild { (,,) nom typ exp -> (nom, typ, fExp exp) }) -}
99be63883da16b89cc10a7a0555a4239
  methDescUrgPragma ::
    LexerTypes.BSVModuleDec
    -> GHC.Base.String -> [GHC.Base.String] -> [LexerTypes.ActionPath]
  {- Arity: 3,
     Strictness: <S(LLLLLSLLLL),1*U(A,A,A,A,A,1*U,A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: GHC.Base.String)
                   (w2 :: [GHC.Base.String]) ->
                 case w of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wmethDescUrgPragma ww6 w1 w2 }) -}
d053d45fcd3db26eae6eebf2cf9b71bf
  methDescUrgPragmaInverse ::
    LexerTypes.BSVModuleDec
    -> GHC.Base.String -> [GHC.Base.String] -> [LexerTypes.ActionPath]
  {- Arity: 3,
     Strictness: <S(LLLLLSLLLL),1*U(A,A,A,A,A,1*U,A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVModuleDec)
                   (w1 :: GHC.Base.String)
                   (w2 :: [GHC.Base.String]) ->
                 case w of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 BSV2PVS.$wmethDescUrgPragmaInverse ww6 w1 w2 }) -}
ccbc55a04ef840fd7ae746dd854ac143
  migrateAttributes :: LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,U,1*U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (universe :: LexerTypes.BSVPackage) ->
                 case universe of wild { LexerTypes.BSVPackage ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 LexerTypes.BSVPackage
                   ds
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   (GHC.Base.build
                      @ LexerTypes.BSVModuleDec
                      (\ @ b1
                         (c :: LexerTypes.BSVModuleDec -> b1 -> b1)[OneShot]
                         (n3 :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ LexerTypes.BSVModuleDec
                         @ b1
                         (GHC.Base.mapFB
                            @ LexerTypes.BSVModuleDec
                            @ b1
                            @ LexerTypes.BSVModuleDec
                            c
                            BSV2PVS.migrateModAttributes)
                         n3
                         ds7))
                   ds8
                   ds9
                   ds10 }) -}
fe34314d7743185952eaba4dca831156
  migrateModAttributes ::
    LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,1*U,U,U,1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 case w of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 let {
                   newRules :: [LexerTypes.RuleDec]
                   = GHC.Base.map
                       @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.RuleAttribute])
                       @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.RuleAttribute])
                       BSV2PVS.migrateRuleAttributes
                       ww9
                 } in
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   (GHC.Base.++
                      @ LexerTypes.ModuleAttribute
                      ww6
                      (BSV2PVS.getModAttsRM newRules))
                   ww7
                   ww8
                   (GHC.Base.map
                      @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                         [LexerTypes.RuleAttribute])
                      @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                         [LexerTypes.RuleAttribute])
                      BSV2PVS.crushModAttsR
                      newRules)
                   ww10 }) -}
4da25020cf2b303893ed5af12617ff91
  migrateRuleAttributes :: LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.RuleDec) ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    BSV2PVS.crushModAttsS
                    ww3,
                  GHC.Base.++
                    @ LexerTypes.RuleAttribute
                    ww4
                    (BSV2PVS.getModAttsSR ww3)) }) -}
a7365845b632b17b20544c15b7aa3d6c
  notNothing :: GHC.Base.Maybe a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: GHC.Base.Maybe a) ->
                 case ds of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just x -> GHC.Types.True }) -}
c4b4e3631cfde9e814b39e3b78580246
  nubPath :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
0c95bfb73a55eedad1c92edb4644e2ad
  omniFlatten ::
    GHC.Base.Maybe GHC.Base.String
    -> [LexerTypes.BSVPackage] -> LexerTypes.BSVPackage
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Base.Maybe GHC.Base.String)
                   (omnibuss :: [LexerTypes.BSVPackage]) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> LexerTypes.BSVPackage
                        (case GHC.List.reverse1
                                @ LexerTypes.BSVPackage
                                omnibuss
                                (GHC.Types.[] @ LexerTypes.BSVPackage) of wild1 {
                           [] -> case GHC.List.badHead ret_ty LexerTypes.PackageName of {}
                           : x ds1
                           -> case x of wild2 { LexerTypes.BSVPackage ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ->
                              ds2 } })
                        (BSV2PVS.omniFlatten_go9 omnibuss)
                        (BSV2PVS.omniFlatten_go8 omnibuss)
                        (let {
                           ints :: [LexerTypes.InterfaceDec]
                           = BSV2PVS.omniFlatten_go7 omnibuss
                         } in
                         BSV2PVS.expandSubInterfaces ints ints)
                        (BSV2PVS.omniFlatten_go6 omnibuss)
                        (BSV2PVS.omniFlatten_go5 omnibuss)
                        (BSV2PVS.omniFlatten_go4 omnibuss)
                        (Data.OldList.nubBy
                           @ LexerTypes.BSVModuleDec
                           LexerTypes.$fEqBSVModuleDec_$c==
                           (BSV2PVS.omniFlatten_go3 omnibuss))
                        (BSV2PVS.omniFlatten_go2 omnibuss)
                        (BSV2PVS.omniFlatten_go1 omnibuss)
                        (BSV2PVS.omniFlatten_go omnibuss)
                   GHC.Base.Just topMod
                   -> let {
                        omnibuses :: [LexerTypes.BSVPackage]
                        = GHC.Base.map
                            @ LexerTypes.BSVPackage
                            @ LexerTypes.BSVPackage
                            BSV2PVS.preprocMidModInts
                            omnibuss
                      } in
                      LexerTypes.BSVPackage
                        (BSV2PVS.getTopPackageName' topMod omnibuses)
                        (BSV2PVS.omniFlatten_go9 omnibuses)
                        (BSV2PVS.omniFlatten_go8 omnibuses)
                        (let {
                           ints :: [LexerTypes.InterfaceDec]
                           = BSV2PVS.omniFlatten_go7 omnibuses
                         } in
                         BSV2PVS.expandSubInterfaces ints ints)
                        (BSV2PVS.omniFlatten_go6 omnibuses)
                        (BSV2PVS.omniFlatten_go5 omnibuses)
                        (BSV2PVS.omniFlatten_go4 omnibuses)
                        (Data.OldList.nubBy
                           @ LexerTypes.BSVModuleDec
                           LexerTypes.$fEqBSVModuleDec_$c==
                           (BSV2PVS.omniFlatten_go3 omnibuses))
                        (BSV2PVS.omniFlatten_go2 omnibuses)
                        (BSV2PVS.omniFlatten_go1 omnibuses)
                        (BSV2PVS.omniFlatten_go omnibuses) }) -}
951166409b3a65a247707832f0daf378
  omniFlatten_go :: [LexerTypes.BSVPackage] -> [LexerTypes.HexFile]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
eebdaa8e6659645b7fe81e5f9bb17ca8
  omniFlatten_go1 :: [LexerTypes.BSVPackage] -> [LexerTypes.BSVMacro]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
56c71235d057275d7acd83486fe83d96
  omniFlatten_go2 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.BSVFunction]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
795898ebad848a5ef4f0f9ea92c9a931
  omniFlatten_go3 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.BSVModuleDec]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
023f547817054dfd33376602b9d5c21b
  omniFlatten_go4 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.BSVInstDef]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
389e2884e28602de97f728a787440a14
  omniFlatten_go5 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.BSVTypeDef]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d01267ec933a4ab5b2312685f07e9d8f
  omniFlatten_go6 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.BSVConstantDec]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4d4f6254995ed72a6bd669a6473fb138
  omniFlatten_go7 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.InterfaceDec]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
78cbb04883a938c292c8c4d6684bc916
  omniFlatten_go8 :: [LexerTypes.BSVPackage] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
49a69f5e15eb55ac2f67f585192344ca
  omniFlatten_go9 ::
    [LexerTypes.BSVPackage] -> [LexerTypes.PackageName]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
906d775db0179fe49560067772fa0c47
  onlyInputMethods ::
    [LexerTypes.MethodBody] -> [LexerTypes.MethodBody]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
52fb637816c7a7dffc5846965a5321ec
  orderLDecs ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.LocalVar] -> [LexerTypes.LocalVar]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U>,
     Unfolding: (\ (m :: LexerTypes.BSVModuleDec)
                   (ls :: [LexerTypes.LocalVar]) ->
                 BSV2PVS.orderLDecs'
                   (GHC.Base.map
                      @ (LexerTypes.ID_Path,
                         Data.Either.Either
                           (GHC.Base.Maybe LexerTypes.BSVType)
                           (GHC.Base.Maybe LexerTypes.PVSType),
                         LexerTypes.Expression)
                      @ ((LexerTypes.ID_Path,
                          Data.Either.Either
                            (GHC.Base.Maybe LexerTypes.BSVType)
                            (GHC.Base.Maybe LexerTypes.PVSType),
                          LexerTypes.Expression),
                         [LexerTypes.ID_Path])
                      (\ (ds :: (LexerTypes.ID_Path,
                                 Data.Either.Either
                                   (GHC.Base.Maybe LexerTypes.BSVType)
                                   (GHC.Base.Maybe LexerTypes.PVSType),
                                 LexerTypes.Expression)) ->
                       case ds of wild { (,,) x y z ->
                       (wild,
                        BSV2PVS.getReadsBy
                          m
                          BSV2PVS.convertToFunction1
                          (GHC.Types.[] @ GHC.Base.String)
                          z) })
                      ls)) -}
2c35dc2aa9034b9e409eade6f4bfa476
  orderLDecs' ::
    [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
    -> [LexerTypes.LocalVar]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [(LexerTypes.LocalVar,
                            [LexerTypes.ID_Path])]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ LexerTypes.LocalVar
                   : ipv ipv1
                   -> let {
                        names :: [LexerTypes.ID_Path]
                        = GHC.Base.map
                            @ (LexerTypes.LocalVar, [LexerTypes.ID_Path])
                            @ LexerTypes.ID_Path
                            BSV2PVS.orderLDecs'1
                            wild
                      } in
                      letrec {
                        go16 :: [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
                                -> [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]) ->
                          case ds1 of wild1 {
                            [] -> GHC.Types.[] @ (LexerTypes.LocalVar, [LexerTypes.ID_Path])
                            : y ys
                            -> case Data.OldList.intersectBy
                                      @ LexerTypes.ID_Path
                                      BSV2PVS.pathEq
                                      names
                                      (case y of wild2 { (,) ds2 y1 -> y1 }) of wild2 {
                                 []
                                 -> GHC.Types.:
                                      @ (LexerTypes.LocalVar, [LexerTypes.ID_Path])
                                      y
                                      (go16 ys)
                                 : ds2 ds3 -> go16 ys } }
                      } in
                      let {
                        clearLDecs :: [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
                        = go16 wild
                      } in
                      let {
                        z :: [(LexerTypes.ID_Path,
                               Data.Either.Either
                                 (GHC.Base.Maybe LexerTypes.BSVType)
                                 (GHC.Base.Maybe LexerTypes.PVSType),
                               LexerTypes.Expression)]
                        = BSV2PVS.orderLDecs'_go clearLDecs wild
                      } in
                      letrec {
                        go17 :: [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
                                -> [(LexerTypes.ID_Path,
                                     Data.Either.Either
                                       (GHC.Base.Maybe LexerTypes.BSVType)
                                       (GHC.Base.Maybe LexerTypes.PVSType),
                                     LexerTypes.Expression)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]) ->
                          case ds1 of wild1 {
                            [] -> z
                            : y ys
                            -> GHC.Types.:
                                 @ (LexerTypes.ID_Path,
                                    Data.Either.Either
                                      (GHC.Base.Maybe LexerTypes.BSVType)
                                      (GHC.Base.Maybe LexerTypes.PVSType),
                                    LexerTypes.Expression)
                                 (Data.Tuple.fst @ LexerTypes.LocalVar @ [LexerTypes.ID_Path] y)
                                 (go17 ys) }
                      } in
                      go17 clearLDecs }) -}
873d439c0b39de68be3313e84ab5d3fe
  orderLDecs'1 ::
    (LexerTypes.LocalVar, [LexerTypes.ID_Path]) -> LexerTypes.ID_Path
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SLL)L),1*U(1*U(1*U,A,A),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (LexerTypes.LocalVar, [LexerTypes.ID_Path])) ->
                 case x of wild { (,) x1 ds1 ->
                 case x1 of wild1 { (,,) q ds ds2 -> q } }) -}
45c61056a343251040ce2bc35e4e7011
  orderLDecs'_go ::
    [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
    -> [(LexerTypes.LocalVar, [LexerTypes.ID_Path])]
    -> [LexerTypes.LocalVar]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
2c419f484cd8ae82edf143fa916109cf
  orderValueMethods ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.TransitionTable]
    -> [LexerTypes.ValueMethod]
    -> [LexerTypes.ValueMethod]
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><S,1*U> -}
d8524198e0b7bb175d42d6e3132ea850
  p2bType :: LexerTypes.PVSType -> LexerTypes.BSVType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: LexerTypes.PVSType) ->
                 case ds of wild {
                   LexerTypes.PVS_Bool -> LexerTypes.BSV_Bool
                   LexerTypes.PVS_Bit n3 -> LexerTypes.BSV_Bit n3
                   LexerTypes.PVS_Int n3 -> LexerTypes.BSV_Int n3
                   LexerTypes.PVS_UInt n3 -> LexerTypes.BSV_UInt n3
                   LexerTypes.PVS_Real -> LexerTypes.BSV_Real
                   LexerTypes.PVS_Custom n3 -> LexerTypes.BSV_Custom n3
                   LexerTypes.PVS_Maybe ipv -> BSV2PVS.p2bType1 }) -}
23d7b5cc75d1fe641feb518f9d1edc53
  p2bType1 :: LexerTypes.BSVType
  {- Strictness: x -}
28c44b81af2943df6f893a4d2f77db43
  pathEq ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
08b60776d8723b66e1e4451630a85d83
  pathPrefixEq ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
09a7bb710d3d1cae3efd7c35a8d60187
  pathPrefixReplacement ::
    LexerTypes.ID_Path
    -> GHC.Base.Maybe LexerTypes.ID_Path
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
61981a7eade02feb3eb1e7ff62b17feb
  pathTerminalEq ::
    LexerTypes.ID_Path -> LexerTypes.ID_Path -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
5df1dbd88eae072b5e1322d78731e14b
  prependIDPath ::
    GHC.Base.String -> LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (0, True, True)
                LexerTypes.ID_Submod_Struct -}
8be8c0574851ab3dd7ab1a47a01c068e
  preprocMidModInts :: LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U,U,U,U,U,U,U,U)>,
     Unfolding: (\ (x :: LexerTypes.BSVPackage) ->
                 case x of wild { LexerTypes.BSVPackage ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 LexerTypes.BSVPackage
                   ds
                   ds1
                   ds2
                   (GHC.Base.++
                      @ (LexerTypes.Name, [LexerTypes.MethodDec],
                         [LexerTypes.InterfaceRef], [LexerTypes.InterfaceAttribute])
                      ds3
                      (BSV2PVS.preprocMidModInts_go ds7))
                   ds4
                   ds5
                   ds6
                   (GHC.Base.map
                      @ LexerTypes.BSVModuleDec
                      @ LexerTypes.BSVModuleDec
                      BSV2PVS.purgeMidModDecs
                      ds7)
                   ds8
                   ds9
                   ds10 }) -}
e521ee9d31b6422921857d750f8616dc
  preprocMidModInts_go ::
    [LexerTypes.BSVModuleDec]
    -> [(LexerTypes.Name, [LexerTypes.MethodDec],
         [LexerTypes.InterfaceRef], [LexerTypes.InterfaceAttribute])]
  {- Arity: 1, Strictness: <S,1*U> -}
5e5fa7200e4079c156871abde9a27456
  propagateMethodCalls ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> [LexerTypes.ID_Path]
    -> [LexerTypes.Replacement]
    -> LexerTypes.BSVModuleDec
  {- Arity: 4,
     Strictness: <L,U(A,A,A,A,A,A,A,U,A,A,A)><S,1*U(U,U,U,U,U,U,U,U,1*U,U)><L,U><L,U>m -}
98893a902ad14dcf86bf8bd547ad5e14
  purgeMidModDecs ::
    LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,U,U,U,U,U,U,1*U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 case w of ww { LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   (GHC.Base.++
                      @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                         LexerTypes.Guard, [LexerTypes.Statement],
                         [LexerTypes.MethodBodyAttribute])
                      ww10
                      (letrec {
                         go16 :: [(GHC.Base.String, GHC.Base.String,
                                   [LexerTypes.MethodBody])]
                                 -> [(LexerTypes.MethodName, LexerTypes.ReturnType,
                                      LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                                      [LexerTypes.MethodBodyAttribute])]
                           {- Arity: 1, Strictness: <S,U> -}
                         = \ (ds :: [(GHC.Base.String, GHC.Base.String,
                                      [LexerTypes.MethodBody])]) ->
                           case ds of wild {
                             []
                             -> GHC.Types.[]
                                  @ (LexerTypes.MethodName, LexerTypes.ReturnType,
                                     LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                                     [LexerTypes.MethodBodyAttribute])
                             : y ys
                             -> case y of wild1 { (,,) ds1 ds2 q ->
                                GHC.Base.++
                                  @ (LexerTypes.MethodName, LexerTypes.ReturnType,
                                     LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                                     [LexerTypes.MethodBodyAttribute])
                                  q
                                  (go16 ys) } }
                       } in
                       go16 ww5)) }) -}
fa307aa9b08deed2fa8f4577c50ffb05
  rcCvLocal ::
    [LexerTypes.BSVstateDec]
    -> LexerTypes.LocalVar -> LexerTypes.LocalVar
  {- Arity: 2, Strictness: <L,U><S(LSL),1*U(U,1*U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.BSVstateDec]) (w1 :: LexerTypes.LocalVar) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case ww2 of wild {
                   Data.Either.Left y
                   -> (ww1,
                       Data.Either.Right
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         @ (GHC.Base.Maybe LexerTypes.PVSType)
                         (case y of wild1 {
                            GHC.Base.Nothing -> GHC.Base.Nothing @ LexerTypes.PVSType
                            GHC.Base.Just a1
                            -> GHC.Base.Just @ LexerTypes.PVSType (BSV2PVS.b2pType a1) }),
                       BSV2PVS.cvExp w ww3)
                   Data.Either.Right y
                   -> (ww1,
                       Data.Either.Right
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         @ (GHC.Base.Maybe LexerTypes.PVSType)
                         y,
                       BSV2PVS.cvExp w ww3) } }) -}
0b5cb7adceb232633b6496a476ea444c
  rcDinvLocal ::
    [LexerTypes.Argument] -> LexerTypes.LocalVar -> LexerTypes.LocalVar
  {- Arity: 2, Strictness: <L,A><S(LSL),1*U(U,1*U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.Argument]) (w1 :: LexerTypes.LocalVar) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 case ww2 of wild {
                   Data.Either.Left y
                   -> (ww1,
                       Data.Either.Right
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         @ (GHC.Base.Maybe LexerTypes.PVSType)
                         (case y of wild1 {
                            GHC.Base.Nothing -> GHC.Base.Nothing @ LexerTypes.PVSType
                            GHC.Base.Just a1
                            -> GHC.Base.Just @ LexerTypes.PVSType (BSV2PVS.b2pType a1) }),
                       BSV2PVS.$wdinvExp ww3)
                   Data.Either.Right y
                   -> (ww1,
                       Data.Either.Right
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         @ (GHC.Base.Maybe LexerTypes.PVSType)
                         y,
                       BSV2PVS.$wdinvExp ww3) } }) -}
e398927bd83a56b3966b2ed6f8783dbb
  recCvCase ::
    [LexerTypes.BSVstateDec] -> LexerTypes.Case -> LexerTypes.Case
  {- Arity: 2, Strictness: <L,U><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (st :: [LexerTypes.BSVstateDec])
                   (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) x y -> (x, BSV2PVS.cvStmt st y) }) -}
a8c4b3b7348ac7d417d8713b92b65581
  recDinvCase ::
    [LexerTypes.Argument] -> LexerTypes.Case -> LexerTypes.Case
  {- Arity: 2, Strictness: <L,A><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (st :: [LexerTypes.Argument])
                   (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) x y -> (x, BSV2PVS.dinvStmt st y) }) -}
4053641c9e89d7462a9be981df086920
  recRfCase ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Base.Maybe LexerTypes.BSVType
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.Case
    -> LexerTypes.Case
  {- Arity: 7,
     Strictness: <L,U><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><L,U><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (7, True, False)
                (\ (td :: [LexerTypes.BSVTypeDef])
                   (mod :: LexerTypes.BSVModuleDec)
                   (st :: [GHC.Base.String])
                   (p :: [GHC.Base.String])
                   (btyp :: GHC.Base.Maybe LexerTypes.BSVType)
                   (iref :: [LexerTypes.InterfaceRef])
                   (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) x y ->
                 (x, BSV2PVS.rfStmt td mod st p btyp iref y) }) -}
9a7c1ae756164c155d07b6e19026493c
  reclpCase :: LexerTypes.Case -> LexerTypes.Case
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.Literal, LexerTypes.Statement)) ->
                 case ds of wild { (,) x y -> (x, BSV2PVS.lpStmt y) }) -}
084addb487a25d5aafc830e51b63d5c7
  recordifyBSV ::
    (LexerTypes.PackageName, [LexerTypes.PackageName],
     [GHC.Base.String], [LexerTypes.InterfaceDec],
     [LexerTypes.BSVConstantDec], [LexerTypes.BSVTypeDef],
     [LexerTypes.BSVModuleDec], [LexerTypes.BSVInstDef],
     [LexerTypes.BSVFunction], [LexerTypes.BSVMacro],
     [LexerTypes.HexFile])
    -> LexerTypes.BSVPackage
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.PackageName, [LexerTypes.PackageName],
                           [GHC.Base.String], [LexerTypes.InterfaceDec],
                           [LexerTypes.BSVConstantDec], [LexerTypes.BSVTypeDef],
                           [LexerTypes.BSVModuleDec], [LexerTypes.BSVInstDef],
                           [LexerTypes.BSVFunction], [LexerTypes.BSVMacro],
                           [LexerTypes.HexFile])) ->
                 case ds of wild { (,,,,,,,,,,) nom imp incl inter str typ mods insts funcs macros hexes ->
                 LexerTypes.BSVPackage
                   nom
                   imp
                   incl
                   inter
                   str
                   typ
                   insts
                   mods
                   funcs
                   macros
                   hexes }) -}
5d16d3864ed8b8f988e8674fd443b924
  recordifyPVS ::
    (LexerTypes.PackageName, [LexerTypes.PVSConstantDec],
     [LexerTypes.PVSTypeDef], [LexerTypes.PVStransition],
     [LexerTypes.PVSstateDec], [LexerTypes.PVSInstDef],
     [LexerTypes.PVSFunction])
    -> LexerTypes.PVSPackage
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (LexerTypes.PackageName, [LexerTypes.PVSConstantDec],
                           [LexerTypes.PVSTypeDef], [LexerTypes.PVStransition],
                           [LexerTypes.PVSstateDec], [LexerTypes.PVSInstDef],
                           [LexerTypes.PVSFunction])) ->
                 case ds of wild { (,,,,,,) nom str typ trans state insts funcs ->
                 LexerTypes.PVSPackage nom str typ trans state insts funcs }) -}
9f64631d766a77c9ed07e677c1fbe445
  removeActionPath :: LexerTypes.ActionPath -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
66e3c07110b2ccd229db4022f7f50079
  removeAtIndex :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: [a]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BSV2PVS.$wremoveAtIndex @ a ww1 w1 }) -}
9f892130d34f1407666a7e57c100a323
  removeIRefs ::
    LexerTypes.ID_Path
    -> [LexerTypes.InterfaceRef] -> LexerTypes.ID_Path
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
87394fa3026068195f7d9ddb2202e69b
  removeLDec ::
    LexerTypes.ID_Path -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
ca0eed729991cad47fd405773076b1b6
  removeLDecReference ::
    LexerTypes.LocalVar -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <S,1*U(U,A,A)><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.LocalVar) (w1 :: LexerTypes.Statement) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 BSV2PVS.$wremoveLDecReference ww1 w1 }) -}
ddbc15f44be20e54a6d07fcda99beb19
  removeLDecReferences ::
    [LexerTypes.Statement]
    -> LexerTypes.LocalVar -> [LexerTypes.Statement]
  {- Arity: 2, Strictness: <S,1*U><L,U(U,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ss :: [LexerTypes.Statement]) (l :: LexerTypes.LocalVar) ->
                 GHC.Base.build
                   @ LexerTypes.Statement
                   (\ @ b1
                      (c :: LexerTypes.Statement -> b1 -> b1)[OneShot]
                      (n3 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ LexerTypes.Statement
                      @ b1
                      (GHC.Base.mapFB
                         @ LexerTypes.Statement
                         @ b1
                         @ LexerTypes.Statement
                         c
                         (BSV2PVS.removeLDecReference l))
                      n3
                      ss)) -}
f4f6c7b6abb5dc3b52742f2dfa36087a
  removeNonConflicts ::
    [LexerTypes.ModuleAttribute]
    -> [LexerTypes.RuleDec] -> GHC.Base.String -> [LexerTypes.RuleDec]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><L,U> -}
6ccdbb0cf9de4fe87430347b982672c6
  removeSelf ::
    GHC.Base.String -> [LexerTypes.RuleDec] -> [LexerTypes.RuleDec]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
f870bf154d0426c3d149c4df4b52e632
  removeStructPrefix :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct x y -> y
                   LexerTypes.ID ds1 -> BSV2PVS.removeStructPrefix2
                   LexerTypes.ID_Vect ipv ipv1 -> BSV2PVS.removeStructPrefix1 }) -}
11c3e191181b45fda60408a28d53b87a
  removeStructPrefix1 :: LexerTypes.ID_Path
  {- Strictness: x -}
bc2f8e75f4be4cf3696239149b87b61f
  removeStructPrefix2 :: LexerTypes.ID_Path
  {- Strictness: x -}
b56f442b278f28712a6b420f289803dc
  removeVoids :: [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
39760dd841ee3147ca16f89851496028
  replaceLetWith ::
    [LexerTypes.Statement]
    -> LexerTypes.Statement -> [LexerTypes.Statement]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
3cbbe4054e740fbf437aebe5c2f056bf
  replaceSkips ::
    LexerTypes.ID_Path
    -> LexerTypes.SpecificTree -> LexerTypes.SpecificTree
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (n3 :: LexerTypes.ID_Path)
                   (ds :: LexerTypes.SpecificTree) ->
                 case ds of wild {
                   LexerTypes.SpecStem gd ds1 t2
                   -> case ds1 of wild1 {
                        Data.Either.Left exp1
                        -> LexerTypes.SpecStem
                             gd
                             (Data.Either.Left
                                @ LexerTypes.Expression
                                @ LexerTypes.SpecTrueTree
                                (case LexerTypes.$fEqExpression_$c==
                                        exp1
                                        LexerTypes.Skip of wild2 {
                                   GHC.Types.False -> exp1
                                   GHC.Types.True -> LexerTypes.Identifier n3 }))
                             (BSV2PVS.simplifySpecificTree4 t2)
                        Data.Either.Right t1
                        -> LexerTypes.SpecStem
                             gd
                             (Data.Either.Right
                                @ LexerTypes.Expression
                                @ LexerTypes.SpecificTree
                                (BSV2PVS.simplifySpecificTree4 t1))
                             (BSV2PVS.simplifySpecificTree4 t2) }
                   LexerTypes.SpecLeaf gd exp1 exp2
                   -> LexerTypes.SpecLeaf
                        gd
                        (case LexerTypes.$fEqExpression_$c==
                                exp1
                                LexerTypes.Skip of wild1 {
                           GHC.Types.False -> exp1
                           GHC.Types.True -> LexerTypes.Identifier n3 })
                        (case LexerTypes.$fEqExpression_$c==
                                exp2
                                LexerTypes.Skip of wild1 {
                           GHC.Types.False -> exp2
                           GHC.Types.True -> LexerTypes.Identifier n3 })
                   LexerTypes.SpecEx exp1
                   -> LexerTypes.SpecEx
                        (case LexerTypes.$fEqExpression_$c==
                                exp1
                                LexerTypes.Skip of wild1 {
                           GHC.Types.False -> exp1
                           GHC.Types.True -> LexerTypes.Identifier n3 }) }) -}
27fd5b7a1b767174a70ee1ebef0c4a2a
  resolveMultipleStatements ::
    [LexerTypes.Statement] -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U> -}
751102981f69cec5d287ab7b593c328d
  returnTypeToBSVType ::
    LexerTypes.ReturnType -> GHC.Base.Maybe LexerTypes.BSVType
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.ReturnType) ->
                 case ds of wild {
                   LexerTypes.Action -> GHC.Base.Nothing @ LexerTypes.BSVType
                   LexerTypes.ActionValue t -> GHC.Base.Just @ LexerTypes.BSVType t
                   LexerTypes.Value t -> GHC.Base.Just @ LexerTypes.BSVType t }) -}
9e86b2816ac19d8097c475d2511ff9c4
  rf2Vec :: LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,1*U,U,1*U,U,1*U,1*U,1*U,A,U)>,
     Unfolding: (\ (universe :: LexerTypes.BSVPackage) ->
                 LexerTypes.BSVPackage
                   (LexerTypes.bsv_packageName universe)
                   (LexerTypes.imports universe)
                   (LexerTypes.including universe)
                   (LexerTypes.interfaces universe)
                   (LexerTypes.bsv_constants universe)
                   (LexerTypes.bsv_typedefs universe)
                   (LexerTypes.bsv_instDefs universe)
                   (case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                    GHC.Base.map
                      @ LexerTypes.BSVModuleDec
                      @ LexerTypes.BSVModuleDec
                      (let {
                         w :: [LexerTypes.InterfaceRef]
                         = BSV2PVS.getSubinterfaceNames_go ds4
                       } in
                       \ (w1 :: LexerTypes.BSVModuleDec) ->
                       case BSV2PVS.$wrfMod
                              ds6
                              ds11
                              (GHC.Types.[] @ GHC.Base.String)
                              w
                              w1 of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                       LexerTypes.BSVModuleDec ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 })
                      ds8 })
                   (LexerTypes.bsv_functions universe)
                   (GHC.Types.[] @ LexerTypes.BSVMacro)
                   (GHC.Types.[] @ LexerTypes.HexFile)) -}
cec008826d01dea82243de15e382905c
  rfAct ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.ActionDec
    -> LexerTypes.ActionDec
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (6, True, False)
                (\ (td :: [LexerTypes.BSVTypeDef])
                   (mod :: LexerTypes.BSVModuleDec)
                   (st :: [GHC.Base.String])
                   (p :: [GHC.Base.String])
                   (iref :: [LexerTypes.InterfaceRef])
                   (ds :: (LexerTypes.ActionName, [LexerTypes.Statement],
                           [LexerTypes.ActionAttribute])) ->
                 case ds of wild { (,,) x y z ->
                 (x,
                  GHC.Base.build
                    @ LexerTypes.Statement
                    (\ @ b1
                       (c :: LexerTypes.Statement -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ LexerTypes.Statement
                       @ b1
                       (GHC.Base.mapFB
                          @ LexerTypes.Statement
                          @ b1
                          @ LexerTypes.Statement
                          c
                          (BSV2PVS.rfStmt
                             td
                             mod
                             st
                             p
                             (GHC.Base.Nothing @ LexerTypes.BSVType)
                             iref))
                       n3
                       y),
                  z) }) -}
e8c97295d3e9c7f68892fdd669862baa
  rfExp ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Base.Maybe LexerTypes.BSVType
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.Expression
    -> LexerTypes.Expression
  {- Arity: 7,
     Strictness: <L,U><L,U(U,U,U,U,A,A,A,U,U,U)><L,U><L,U><L,U><L,U><S,1*U> -}
88ae68a8368058821a243e411538bb9c
  rfInterfaces ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.InterfaceRef]
    -> [LexerTypes.MidModInterfaceDec]
    -> [LexerTypes.MidModInterfaceDec]
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><S,1*U> -}
eb3f72c6692472c0973553fdd92d0ab4
  rfLocal ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.LocalVar
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.LocalVar
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U,U,U,A,A,A,U,U,U)><L,U><L,U><S(LSL),1*U(U,1*U,1*U)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ (w :: [LexerTypes.BSVTypeDef])
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: LexerTypes.LocalVar)
                   (w5 :: [LexerTypes.InterfaceRef]) ->
                 case w4 of ww { (,,) ww1 ww2 ww3 ->
                 case ww2 of wild {
                   Data.Either.Left y
                   -> (ww1,
                       Data.Either.Left
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         @ (GHC.Base.Maybe LexerTypes.PVSType)
                         y,
                       BSV2PVS.rfExp w w1 w2 w3 y w5 ww3)
                   Data.Either.Right y
                   -> (ww1,
                       Data.Either.Right
                         @ (GHC.Base.Maybe LexerTypes.BSVType)
                         @ (GHC.Base.Maybe LexerTypes.PVSType)
                         y,
                       BSV2PVS.rfExp
                         w
                         w1
                         w2
                         w3
                         (case y of wild1 {
                            GHC.Base.Nothing -> GHC.Base.Nothing @ LexerTypes.BSVType
                            GHC.Base.Just a1
                            -> GHC.Base.Just @ LexerTypes.BSVType (BSV2PVS.p2bType a1) })
                         w5
                         ww3) } }) -}
8d09e387fa82dc0fb69d8c232b80d0fd
  rfMet ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.MethodBody
    -> LexerTypes.MethodBody
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><S,1*U(U,U,U,1*U,1*U,U)>m,
     Unfolding: (\ (td :: [LexerTypes.BSVTypeDef])
                   (mod :: LexerTypes.BSVModuleDec)
                   (st :: [GHC.Base.String])
                   (p :: [GHC.Base.String])
                   (iref :: [LexerTypes.InterfaceRef])
                   (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) u v w x y z ->
                 (u, v, w,
                  BSV2PVS.rfExp
                    td
                    mod
                    st
                    p
                    (GHC.Base.Nothing @ LexerTypes.BSVType)
                    iref
                    x,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    (BSV2PVS.rfStmt td mod st p (BSV2PVS.returnTypeToBSVType v) iref)
                    y,
                  z) }) -}
1afe61c17ded13d4f60d102cf6c27d29
  rfMod ::
    [LexerTypes.BSVTypeDef]
    -> [LexerTypes.HexFile]
    -> [GHC.Base.String]
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.BSVModuleDec
  {- Arity: 5,
     Strictness: <L,U><L,U><L,1*U><L,U><L,U(U,U,U,U,U,U,U,U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: [LexerTypes.BSVTypeDef])
                   (w1 :: [LexerTypes.HexFile])
                   (w2 :: [GHC.Base.String])
                   (w3 :: [LexerTypes.InterfaceRef])
                   (w4 :: LexerTypes.BSVModuleDec) ->
                 case BSV2PVS.$wrfMod
                        w
                        w1
                        w2
                        w3
                        w4 of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 }) -}
8835b85784b1289d242079b7e35e59e1
  rfRul ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.RuleDec
    -> LexerTypes.RuleDec
  {- Arity: 6,
     Strictness: <L,U><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><S,1*U(U,1*U,1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ (w :: [LexerTypes.BSVTypeDef])
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: [LexerTypes.InterfaceRef])
                   (w5 :: LexerTypes.RuleDec) ->
                 case w5 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1,
                  BSV2PVS.rfExp
                    w
                    w1
                    w2
                    w3
                    (GHC.Base.Nothing @ LexerTypes.BSVType)
                    w4
                    ww2,
                  GHC.Base.map
                    @ LexerTypes.Statement
                    @ LexerTypes.Statement
                    (BSV2PVS.rfStmt
                       w
                       w1
                       w2
                       w3
                       (GHC.Base.Nothing @ LexerTypes.BSVType)
                       w4)
                    ww3,
                  ww4) }) -}
3c57f5c5aec161f54670680861dfb771
  rfState ::
    [LexerTypes.HexFile]
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.BSVstateDec
    -> LexerTypes.BSVstateDec
  {- Arity: 3, Strictness: <L,U><L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [LexerTypes.HexFile])
                   (w1 :: [LexerTypes.InterfaceRef])
                   (w2 :: LexerTypes.BSVstateDec) ->
                 BSV2PVS.$wrfState w w2) -}
1d1d090fbc7e72dedbe33ddca25275a9
  rfState1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
245fca3bd662e76b447f762c61637058
  rfState2 :: GHC.Integer.Type.Integer
  {- Unfolding: (GHC.Real.^_$s^
                   BSV2PVS.rfState1
                   BSV2PVS.getTypeBitSize1) -}
e7e0cdc3df5d1d6ad71ffeee4ba48373
  rfState3 ::
    [LexerTypes.HexFile]
    -> LexerTypes.RegFileLoader -> LexerTypes.BSVstateDec
  {- Arity: 2, Strictness: <B,1*U><B,1*U(U,A,A)>x, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.HexFile]) (w1 :: LexerTypes.RegFileLoader) ->
                 case w1 of ww { LexerTypes.RegFileLoad ww1 ww2 ww3 ->
                 BSV2PVS.$wlvl3 w ww1 }) -}
b704e43c29a54a770913edb62c74a91d
  rfState4 :: [GHC.Types.Char] -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (Data.OldList.isSuffixOf
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar) -}
f22872403f93aa8dc3b84b3291440632
  rfStmt ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> GHC.Base.Maybe LexerTypes.BSVType
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.Statement
    -> LexerTypes.Statement
  {- Arity: 7,
     Strictness: <L,U><L,U(U,U,U,U,A,A,U,U,U,U)><L,U><L,U><L,U><L,U><S,1*U> -}
8232438a369ab2543f9f94240c7aa2f0
  rfStructCase ::
    [LexerTypes.BSVTypeDef]
    -> LexerTypes.BSVModuleDec
    -> [GHC.Base.String]
    -> [GHC.Base.String]
    -> LexerTypes.BSVType
    -> [LexerTypes.InterfaceRef]
    -> (GHC.Base.String, LexerTypes.Expression)
    -> (GHC.Base.String, LexerTypes.Expression)
  {- Arity: 7,
     Strictness: <L,U><L,U(U,U,U,U,A,A,A,U,U,U)><L,U><L,U><S,1*U><L,U><S,1*U(U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: [LexerTypes.BSVTypeDef])
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: [GHC.Base.String])
                   (w3 :: [GHC.Base.String])
                   (w4 :: LexerTypes.BSVType)
                   (w5 :: [LexerTypes.InterfaceRef])
                   (w6 :: (GHC.Base.String, LexerTypes.Expression)) ->
                 case w6 of ww { (,) ww1 ww2 ->
                 case BSV2PVS.$wrfStructCase
                        w
                        w1
                        w2
                        w3
                        w4
                        w5
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
247316b9d85073c869cfb22645107751
  rfStructCase1 :: (GHC.Base.String, LexerTypes.Expression)
  {- Strictness: x -}
111c49c1e1d5a6f796cf20ba738bc75e
  rmInstanceDef ::
    LexerTypes.ID_Path -> LexerTypes.BSVModuleDec -> LexerTypes.ID_Path
  {- Arity: 2, Strictness: <S,1*U><L,1*U(A,A,1*U,A,A,A,A,A,A,A)> -}
fd4f8bb5c25def6d5e32d07a5ed17231
  rmLDecs :: [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a3f3adf2fcd04946bb1a5453e420333b
  rmRF :: LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 1, Strictness: <S,1*U> -}
cd4d2135a2c3fc90d514ea67b7c6b47e
  ruleCorrespondance ::
    LexerTypes.RuleSchedule
    -> LexerTypes.RuleSchedule -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(LSLLLLLLLLLLLLLLLL),1*U(A,1*U,A,1*U,A,A,A,A,A,A,A,A,1*U,A,1*U,1*U,1*U,1*U)><S(LSLLLLLLLLLLLLLLLL),1*U(A,1*U,A,1*U,A,A,A,A,A,A,A,A,1*U,A,1*U,1*U,1*U,1*U)>,
     Unfolding: (\ (x :: LexerTypes.RuleSchedule)
                   (y :: LexerTypes.RuleSchedule) ->
                 case x of wild { LexerTypes.RuleSchedule ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                 case y of wild1 { LexerTypes.RuleSchedule ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ds30 ds31 ds32 ds33 ds34 ds35 ds36 ds37 ds38 ds39 ->
                 case LexerTypes.$fEqExpression_$c== ds2 ds23 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ LexerTypes.Expression
                             LexerTypes.$fEqExpression
                             ds4
                             ds25 of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ LexerTypes.ActionPath
                                  LexerTypes.$fEqActionPath
                                  ds13
                                  ds34 of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c==
                                       @ LexerTypes.ActionPath
                                       LexerTypes.$fEqActionPath
                                       ds15
                                       ds36 of wild5 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case GHC.Classes.$fEq[]_$c==
                                            @ LexerTypes.ActionPath
                                            LexerTypes.$fEqActionPath
                                            ds16
                                            ds37 of wild6 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> case GHC.Classes.$fEq[]_$c==
                                                 @ LexerTypes.ActionPath
                                                 LexerTypes.$fEqActionPath
                                                 ds17
                                                 ds38 of wild7 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> GHC.Classes.$fEq[]_$c==
                                                 @ LexerTypes.ActionPath
                                                 LexerTypes.$fEqActionPath
                                                 ds18
                                                 ds39 } } } } } } } }) -}
9dc89e3915e605c866ded6c1a2575b0c
  ruleMerge ::
    [LexerTypes.RuleSchedule]
    -> [([LexerTypes.ActionPath], LexerTypes.ActionPath)]
    -> (LexerTypes.RuleSchedule,
        ([LexerTypes.ActionPath], LexerTypes.ActionPath))
  {- Arity: 2, Strictness: <S,1*U><L,A>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [LexerTypes.RuleSchedule])
                   (w1 :: [([LexerTypes.ActionPath], LexerTypes.ActionPath)]) ->
                 case BSV2PVS.$wruleMerge w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
3804a7e0082dafce0f2ed256de3b2f95
  ruleMerge1 ::
    (LexerTypes.RuleSchedule,
     ([LexerTypes.ActionPath], LexerTypes.ActionPath))
  {- Strictness: x -}
4dca71a9034e68aef15d33f6b8660465
  ruleMerge_go ::
    [LexerTypes.RuleSchedule] -> [LexerTypes.Expression]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
37f15d943dba2203310993d7606492d3
  ruleMerge_go1 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
629d753f4d2af938a6712eabb84735a1
  ruleMerge_go2 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
2a34b37927e5e706fd23d47c47f894f0
  ruleMerge_go3 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
70fd3adb122d8018a4f4019ca55aa91f
  ruleMerge_go4 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8865d9e4fe8c379ada4acf06064afd81
  ruleMerge_go5 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
351c47e9f74b83435007ca45cb7ce1e9
  ruleMerge_go6 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ed97fcbd87d5d0fc38c36e9264551882
  ruleMerge_go7 :: [LexerTypes.RuleSchedule] -> [LexerTypes.ID_Path]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ddb29e1b84dc41df1f50a7439159e703
  ruleMerge_go8 ::
    [LexerTypes.RuleSchedule] -> [LexerTypes.Statement]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a9a3028eb38a573b562a4e109f83edad
  rulizeMethods :: LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,U,U,U,U,U,1*U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec) ->
                 case mod of wild { LexerTypes.BSVModuleDec ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 LexerTypes.BSVModuleDec
                   ds
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   ds7
                   (GHC.Base.build
                      @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                         [LexerTypes.RuleAttribute])
                      (\ @ b
                         (c :: (LexerTypes.RuleName, LexerTypes.Guard,
                                [LexerTypes.Statement], [LexerTypes.RuleAttribute])
                               -> b -> b)[OneShot]
                         (n3 :: b)[OneShot] ->
                       GHC.Base.foldr
                         @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                            [LexerTypes.RuleAttribute])
                         @ b
                         c
                         (GHC.Base.foldr
                            @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                               LexerTypes.Guard, [LexerTypes.Statement],
                               [LexerTypes.MethodBodyAttribute])
                            @ b
                            (GHC.Base.mapFB
                               @ (LexerTypes.RuleName, LexerTypes.Guard, [LexerTypes.Statement],
                                  [LexerTypes.RuleAttribute])
                               @ b
                               @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                                  LexerTypes.Guard, [LexerTypes.Statement],
                                  [LexerTypes.MethodBodyAttribute])
                               c
                               BSV2PVS.convertMethodToRule')
                            n3
                            ds9)
                         ds8))
                   (GHC.Types.[] @ LexerTypes.MethodBody) }) -}
83a6c4f86c14d2665ebfdfbcb1143b40
  safeGetMod ::
    GHC.Base.String
    -> [LexerTypes.BSVModuleDec]
    -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
119987bd1b3cbb69b654f587cd39cc1d
  samAct ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ActionDec -> LexerTypes.ActionDec
  {- Arity: 2,
     Strictness: <L,U(A,A,U,A,A,A,A,A,A,A)><S,1*U(U,1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: LexerTypes.ActionDec) ->
                 case w1 of ww { (,,) ww1 ww2 ww3 ->
                 (ww1,
                  letrec {
                    go16 :: [LexerTypes.Statement] -> [LexerTypes.Statement]
                      {- Arity: 1, Strictness: <S,U> -}
                    = \ (ds :: [LexerTypes.Statement]) ->
                      case ds of wild {
                        [] -> GHC.Types.[] @ LexerTypes.Statement
                        : y ys
                        -> GHC.Base.++
                             @ LexerTypes.Statement
                             (BSV2PVS.samStmt w y)
                             (go16 ys) }
                  } in
                  go16 ww2,
                  ww3) }) -}
924740c3e445b52d9153ea47ac04ee4b
  samInt ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.MidModInterfaceDec -> LexerTypes.MidModInterfaceDec
  {- Arity: 2,
     Strictness: <L,U(A,A,U,A,A,A,A,A,A,A)><S,1*U(U,U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec)
                   (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y ms ->
                 (x, y,
                  GHC.Base.build
                    @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                       LexerTypes.Guard, [LexerTypes.Statement],
                       [LexerTypes.MethodBodyAttribute])
                    (\ @ b1
                       (c :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                              LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                              [LexerTypes.MethodBodyAttribute])
                             -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                          LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.MethodBodyAttribute])
                       @ b1
                       (GHC.Base.mapFB
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          @ b1
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          c
                          (BSV2PVS.samMet mod))
                       n3
                       ms)) }) -}
5b078cbcf4cc936cf61b66c69b384557
  samMet ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.MethodBody -> LexerTypes.MethodBody
  {- Arity: 2,
     Strictness: <L,U(A,A,U,A,A,A,A,A,A,A)><S,1*U(U,U,U,U,1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: LexerTypes.MethodBody) ->
                 case w1 of ww { (,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 (ww1, ww2, ww3, ww4,
                  letrec {
                    go16 :: [LexerTypes.Statement] -> [LexerTypes.Statement]
                      {- Arity: 1, Strictness: <S,U> -}
                    = \ (ds :: [LexerTypes.Statement]) ->
                      case ds of wild {
                        [] -> GHC.Types.[] @ LexerTypes.Statement
                        : y ys
                        -> GHC.Base.++
                             @ LexerTypes.Statement
                             (BSV2PVS.samStmt w y)
                             (go16 ys) }
                  } in
                  go16 ww5,
                  ww6) }) -}
f338636785c6f25839bf6e9eb50bf83d
  samMod :: LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 case BSV2PVS.$wsamMod
                        w of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 }) -}
e6895b12c474675ce6ea86bce02b0a2f
  samRul ::
    LexerTypes.BSVModuleDec -> LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 2,
     Strictness: <L,U(A,A,U,A,A,A,A,A,A,A)><S,1*U(U,U,1*U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: LexerTypes.RuleDec) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2,
                  letrec {
                    go16 :: [LexerTypes.Statement] -> [LexerTypes.Statement]
                      {- Arity: 1, Strictness: <S,U> -}
                    = \ (ds :: [LexerTypes.Statement]) ->
                      case ds of wild {
                        [] -> GHC.Types.[] @ LexerTypes.Statement
                        : y ys
                        -> GHC.Base.++
                             @ LexerTypes.Statement
                             (BSV2PVS.samStmt w y)
                             (go16 ys) }
                  } in
                  go16 ww3,
                  ww4) }) -}
81e0a19fae6f453f57d8665607ade944
  samStmt ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.Statement -> [LexerTypes.Statement]
  {- Arity: 2, Strictness: <L,U(A,A,U,A,A,A,A,A,A,A)><S,1*U> -}
1d62f5b1c34cf14707e3fea45e0e267b
  scrubDwireSkips ::
    LexerTypes.Expression
    -> LexerTypes.SpecificTree -> LexerTypes.SpecificTree
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
a3ce10c8e3de2a30813e4ce62647f470
  scrubDwireSkips' ::
    LexerTypes.Expression
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: LexerTypes.Expression) (ds :: LexerTypes.Expression) ->
                 case ds of wild { DEFAULT -> wild LexerTypes.Skip -> x }) -}
2d19e9f66321df9e85ed51b9de5042b4
  scrubValueMethods ::
    LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec) ->
                 case mod of wild { LexerTypes.BSVModuleDec ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 LexerTypes.BSVModuleDec
                   ds
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   ds7
                   ds8
                   (BSV2PVS.scrubValueMethods_go
                      (BSV2PVS.gatherValueMethods ds9)
                      ds9) }) -}
e3e14e9be7a4e58e4cdd58a2acec3da7
  scrubValueMethods_go ::
    [LexerTypes.MethodBody]
    -> [LexerTypes.MethodBody] -> [LexerTypes.MethodBody]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
c5db5ea05b8f761b91dfebb89bf37187
  searchFieldsOf ::
    LexerTypes.BSVTypeDef -> LexerTypes.Name -> LexerTypes.BSVType
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: LexerTypes.BSVTypeDef) (n3 :: LexerTypes.Name) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.searchFieldsOf1
                   LexerTypes.BSV_Struct x ys
                   -> case GHC.List.lookup
                             @ LexerTypes.Name
                             @ LexerTypes.BSVType
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             n3
                             ys of wild1 {
                        GHC.Base.Nothing -> BSV2PVS.b2pInstDef'2
                        GHC.Base.Just x1 -> x1 } }) -}
4404975987b5a0ba823abda820efb781
  searchFieldsOf1 :: LexerTypes.BSVType
  {- Strictness: x -}
48f54422167545c091f1a963a55c6f99
  showIDPath :: LexerTypes.ID_Path -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
02df5c090e661b1a70abad5636a28be1
  showIDexpr :: LexerTypes.Expression -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.Expression) ->
                 case ds of wild {
                   DEFAULT -> BSV2PVS.showIDexpr1
                   LexerTypes.Identifier x -> BSV2PVS.showIDPath x }) -}
60e8246d814b4c068add3a5bdafe3001
  showIDexpr1 :: GHC.Base.String
  {- Strictness: x -}
5e198fcc2f90357db5f7dd38024e73ea
  simplifySpecificTree ::
    LexerTypes.SpecificTree -> LexerTypes.SpecificTree
  {- Arity: 1, Strictness: <S,1*U> -}
88244fc5069daf649bf033df9fcddd3d
  simplifySpecificTree' ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> LexerTypes.SpecificTree
    -> LexerTypes.SpecificTree
  {- Arity: 3, Strictness: <L,A><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (mod :: LexerTypes.BSVModuleDec)
                   (n3 :: LexerTypes.ID_Path)
                   (t :: LexerTypes.SpecificTree) ->
                 BSV2PVS.simplifySpecificTree2
                   (BSV2PVS.simplifySpecificTree
                      (BSV2PVS.replaceSkips n3 (BSV2PVS.simplifySpecificTree4 t)))) -}
51fb3b1243dce8d24782903dd1ec8c42
  simplifySpecificTree2 ::
    LexerTypes.SpecificTree -> LexerTypes.SpecificTree
  {- Arity: 1, Strictness: <S,1*U> -}
6d85251bbb152731977b5d044d65845b
  simplifySpecificTree3 ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> LexerTypes.SpecificTree
    -> LexerTypes.SpecificTree
  {- Arity: 3, Strictness: <L,U(A,A,U,A,A,A,U,A,A,A)><L,U><S,1*U> -}
2604396eb92eab78b88c30f88c41792c
  simplifySpecificTree4 ::
    LexerTypes.SpecificTree -> LexerTypes.SpecificTree
  {- Arity: 1, Strictness: <S,1*U> -}
3a90af920993bfac62b45205b2263bff
  simplifyVoidCases :: [LexerTypes.Case] -> [LexerTypes.Case]
  {- Arity: 1, Strictness: <S,1*U> -}
af2f453cce69f95a92cb0c0b52a42f87
  simplifyVoids :: LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 1, Strictness: <S,1*U> -}
83eb464a4c89c3bb1b81e77f8a0f2d85
  sortUrgency ::
    [LexerTypes.ModuleAttribute]
    -> [GHC.Base.String]
    -> GHC.Base.String
    -> [([GHC.Base.String], [GHC.Base.String])]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
0cb25f3c867e467f0bd3310427a025f5
  sortWires ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.ID_Path]
    -> ([LexerTypes.ID_Path], [LexerTypes.ID_Path])
  {- Arity: 2, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: [LexerTypes.ID_Path]) ->
                 case BSV2PVS.$wsortWires w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
838c1a2bd7496aa4545f598901de98af
  splitCase ::
    LexerTypes.BSVModuleDec -> LexerTypes.Case -> [LexerTypes.Case]
  {- Arity: 2,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S(LS),1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: LexerTypes.Case) ->
                 case w1 of ww { (,) ww1 ww2 -> BSV2PVS.$wsplitCase w ww1 ww2 }) -}
f7272743de59e16348ffdb529d1694a1
  splitFunctions ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.BSVFunction -> LexerTypes.BSVFunction
  {- Arity: 2,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,U,U,1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) (w1 :: LexerTypes.BSVFunction) ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (ww1, ww2, ww3,
                  GHC.Types.:
                    @ LexerTypes.Statement
                    (BSV2PVS.resolveMultipleStatements
                       (GHC.Base.map
                          @ LexerTypes.Statement
                          @ LexerTypes.Statement
                          BSV2PVS.eliminateSingletonSBs
                          (BSV2PVS.splitStatementBlocks w ww4)))
                    (GHC.Types.[] @ LexerTypes.Statement)) }) -}
defda4bcf1c3db6a5a9b81f16b7485ac
  splitPreprocAction ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.ActionDec -> LexerTypes.ActionDec
  {- Arity: 2,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (m :: LexerTypes.BSVModuleDec)
                   (ds :: (LexerTypes.ActionName, [LexerTypes.Statement],
                           [LexerTypes.ActionAttribute])) ->
                 case ds of wild { (,,) x y z ->
                 (x, BSV2PVS.splitStatementBlocks m y, z) }) -}
61b5ae7600e00f97e46bec181e750d95
  splitPreprocInterface ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.MidModInterfaceDec -> LexerTypes.MidModInterfaceDec
  {- Arity: 2,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (m :: LexerTypes.BSVModuleDec)
                   (ds :: (GHC.Base.String, GHC.Base.String,
                           [LexerTypes.MethodBody])) ->
                 case ds of wild { (,,) x y ms ->
                 (x, y,
                  GHC.Base.build
                    @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                       LexerTypes.Guard, [LexerTypes.Statement],
                       [LexerTypes.MethodBodyAttribute])
                    (\ @ b1
                       (c :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                              LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                              [LexerTypes.MethodBodyAttribute])
                             -> b1 -> b1)[OneShot]
                       (n3 :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                          LexerTypes.Guard, [LexerTypes.Statement],
                          [LexerTypes.MethodBodyAttribute])
                       @ b1
                       (GHC.Base.mapFB
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          @ b1
                          @ (LexerTypes.MethodName, LexerTypes.ReturnType, LexerTypes.UTArgs,
                             LexerTypes.Guard, [LexerTypes.Statement],
                             [LexerTypes.MethodBodyAttribute])
                          c
                          (BSV2PVS.splitPreprocMethod m))
                       n3
                       ms)) }) -}
bc1e985a05a8a02bbdeafed9ce0c19a7
  splitPreprocMethod ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.MethodBody -> LexerTypes.MethodBody
  {- Arity: 2,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,U,U,U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (m :: LexerTypes.BSVModuleDec)
                   (ds :: (LexerTypes.MethodName, LexerTypes.ReturnType,
                           LexerTypes.UTArgs, LexerTypes.Guard, [LexerTypes.Statement],
                           [LexerTypes.MethodBodyAttribute])) ->
                 case ds of wild { (,,,,,) u v w x y z ->
                 (u, v, w, x, BSV2PVS.splitStatementBlocks m y, z) }) -}
17842c9b2011bd95449ca7e37fbdacf7
  splitPreprocRule ::
    LexerTypes.BSVModuleDec -> LexerTypes.RuleDec -> LexerTypes.RuleDec
  {- Arity: 2,
     Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U(U,U,1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (m :: LexerTypes.BSVModuleDec)
                   (ds :: (LexerTypes.RuleName, LexerTypes.Guard,
                           [LexerTypes.Statement], [LexerTypes.RuleAttribute])) ->
                 case ds of wild { (,,,) w x y z ->
                 (w, x, BSV2PVS.splitStatementBlocks m y, z) }) -}
77af5aca0c5fd494a214bfb2147abd0b
  splitStatementBlock ::
    LexerTypes.BSVModuleDec
    -> LexerTypes.Statement -> [LexerTypes.Statement]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U> -}
4659ce80112732b65068507464cbe0b4
  splitStatementBlocks ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U>,
     Unfolding: (\ (m :: LexerTypes.BSVModuleDec)
                   (xs :: [LexerTypes.Statement]) ->
                 Data.Maybe.catMaybes1
                   @ LexerTypes.Statement
                   (GHC.Base.map
                      @ LexerTypes.Statement
                      @ (GHC.Base.Maybe LexerTypes.Statement)
                      (BSV2PVS.cleanup m)
                      (BSV2PVS.splitStatementBlocks'
                         m
                         (BSV2PVS.applyLocalDecs (BSV2PVS.lDecExpressionize xs))))) -}
725607ccd03a102a572dc940e0db338f
  splitStatementBlocks' ::
    LexerTypes.BSVModuleDec
    -> [LexerTypes.Statement] -> [LexerTypes.Statement]
  {- Arity: 2, Strictness: <L,U(U,U,U,U,A,A,A,U,U,U)><S,1*U>,
     Unfolding: (\ (m :: LexerTypes.BSVModuleDec)
                   (xs :: [LexerTypes.Statement]) ->
                 letrec {
                   go16 :: [LexerTypes.Statement] -> [LexerTypes.Statement]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [LexerTypes.Statement]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ LexerTypes.Statement
                       : y ys
                       -> case BSV2PVS.isFullySplit y of wild1 {
                            GHC.Types.False
                            -> GHC.Base.++
                                 @ LexerTypes.Statement
                                 (BSV2PVS.splitStatementBlock m y)
                                 (go16 ys)
                            GHC.Types.True
                            -> GHC.Base.++
                                 @ LexerTypes.Statement
                                 (GHC.Types.:
                                    @ LexerTypes.Statement
                                    y
                                    (GHC.Types.[] @ LexerTypes.Statement))
                                 (go16 ys) } }
                 } in
                 go16 xs) -}
2d066579e03c19f8d4e53fcdf0c3bb0c
  splitStatementPreprocModule ::
    LexerTypes.BSVModuleDec -> LexerTypes.BSVModuleDec
  {- Arity: 1, Strictness: <L,U(U,U,U,U,U,U,U,U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: LexerTypes.BSVModuleDec) ->
                 case BSV2PVS.$wsplitStatementPreprocModule
                        w of ww { (#,,,,,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 LexerTypes.BSVModuleDec
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10 }) -}
2ec7ade6130896defd78f036c5b20f06
  splitStatementPreprocPackage ::
    LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,A,1*U)>,
     Unfolding: (\ (universe :: LexerTypes.BSVPackage) ->
                 let {
                   q :: [LexerTypes.BSVModuleDec]
                   = case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                     GHC.Base.map
                       @ LexerTypes.BSVModuleDec
                       @ LexerTypes.BSVModuleDec
                       BSV2PVS.splitStatementPreprocModule
                       ds8 }
                 } in
                 LexerTypes.BSVPackage
                   (LexerTypes.bsv_packageName universe)
                   (LexerTypes.imports universe)
                   (LexerTypes.including universe)
                   (LexerTypes.interfaces universe)
                   (LexerTypes.bsv_constants universe)
                   (LexerTypes.bsv_typedefs universe)
                   (LexerTypes.bsv_instDefs universe)
                   q
                   (case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                    GHC.Base.map
                      @ (GHC.Base.String, [LexerTypes.Argument], LexerTypes.BSVType,
                         [LexerTypes.Statement])
                      @ (GHC.Base.String, [LexerTypes.Argument], LexerTypes.BSVType,
                         [LexerTypes.Statement])
                      (let {
                         m :: LexerTypes.BSVModuleDec
                         = case q of wild1 {
                             [] -> GHC.List.badHead @ LexerTypes.BSVModuleDec : x ds16 -> x }
                       } in
                       \ (ds :: (GHC.Base.String, [LexerTypes.Argument],
                                 LexerTypes.BSVType, [LexerTypes.Statement])) ->
                       case ds of wild1 { (,,,) w x y z ->
                       (w, x, y,
                        GHC.Types.:
                          @ LexerTypes.Statement
                          (BSV2PVS.resolveMultipleStatements
                             (GHC.Base.map
                                @ LexerTypes.Statement
                                @ LexerTypes.Statement
                                BSV2PVS.eliminateSingletonSBs
                                (BSV2PVS.splitStatementBlocks m z)))
                          (GHC.Types.[] @ LexerTypes.Statement)) })
                      ds9 })
                   (GHC.Types.[] @ LexerTypes.BSVMacro)
                   (LexerTypes.hexFiles universe)) -}
34c84a388fb690d587bdf832fc7d2ce2
  stepIntoCases ::
    ([LexerTypes.Statement] -> [LexerTypes.Statement])
    -> [(LexerTypes.Literal, LexerTypes.Statement)]
    -> [(LexerTypes.Literal, LexerTypes.Statement)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
4334bfa8a29fc269c2f85dcc8584118e
  stepIntoStatement ::
    ([LexerTypes.Statement] -> [LexerTypes.Statement])
    -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
9804a22a449c66ec543513dba4dfd1fe
  strangeMerge ::
    [GHC.Base.String]
    -> LexerTypes.ID_Path
    -> [LexerTypes.InterfaceRef]
    -> LexerTypes.ID_Path
  {- Arity: 3, Strictness: <S,U><S,U><S,1*U> -}
0560ffa28e61cfc0eaa0be5332e5463c
  string2IDPath :: GHC.Base.String -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (xs :: GHC.Base.String) ->
                 case Data.List.Extra.$wsplitOn
                        @ GHC.Types.Char
                        BSV2PVS.string2IDPath1
                          `cast`
                        (Sym (GHC.Classes.N:IP[0]
                                  <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                        GHC.Classes.$fEqChar
                        BSV2PVS.killNonreferencedMethods1
                        xs of ww { (#,#) ww1 ww2 ->
                 BSV2PVS.strings2idpath
                   (GHC.Types.: @ [GHC.Types.Char] ww1 ww2) }) -}
ca72fd433519a3ad11b2baac56ce26e2
  string2IDPath1 :: GHC.Stack.Types.CallStack
  {- Strictness: m2,
     Unfolding: (GHC.Stack.Types.PushCallStack
                   BSV2PVS.string2IDPath10
                   BSV2PVS.string2IDPath2
                   GHC.Stack.Types.EmptyCallStack) -}
8ef743498d2fb233d687819518717212
  string2IDPath10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.string2IDPath11) -}
1b6e540663cb1639569f49f8b02c2b2b
  string2IDPath11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("splitOn"#) -}
7036bb150a1d9562d66e3e059175a2dd
  string2IDPath2 :: GHC.Stack.Types.SrcLoc
  {- Strictness: m,
     Unfolding: (GHC.Stack.Types.SrcLoc
                   BSV2PVS.string2IDPath9
                   BSV2PVS.string2IDPath8
                   BSV2PVS.string2IDPath6
                   BSV2PVS.string2IDPath5
                   BSV2PVS.string2IDPath4
                   BSV2PVS.string2IDPath5
                   BSV2PVS.string2IDPath3) -}
0af0d4ad80348e23f2ac8b17e362d9ca
  string2IDPath3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 51#) -}
b278ea23e946052f1b24e4c3e5f0e4a0
  string2IDPath4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 37#) -}
ad9db7f8985643ed289d74aaafb10147
  string2IDPath5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3577#) -}
7fc2dabac220055ae9774ad90b86c3c7
  string2IDPath6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   BSV2PVS.string2IDPath7) -}
6b87b3266dad0fcb73d24f42032c2030
  string2IDPath7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("src/BSV2PVS.hs"#) -}
1056b9cdc9d1c71e3c1c1e52e701f7b9
  string2IDPath8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# BSV2PVS.$trModule2) -}
44c062ccca528920420395d20a486d8b
  string2IDPath9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# BSV2PVS.$trModule4) -}
d43fdf153cbfba2ae520ae90b31030e6
  stringPathEq ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (xs :: GHC.Base.String) (ys :: GHC.Base.String) ->
                 case Data.List.Extra.$wsplit
                        @ GHC.Types.Char
                        BSV2PVS.stringPathEq1
                        xs of ww { (#,#) ww1 ww2 ->
                 case Data.List.Extra.$wsplit
                        @ GHC.Types.Char
                        BSV2PVS.stringPathEq1
                        ys of ww4 { (#,#) ww5 ww6 ->
                 BSV2PVS.stringPathEq'
                   (GHC.Types.: @ [GHC.Types.Char] ww1 ww2)
                   (GHC.Types.: @ [GHC.Types.Char] ww5 ww6) } }) -}
be8d9762e9c021d3f1dced28c940c7f6
  stringPathEq' ::
    [GHC.Base.String] -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U> -}
3c3336ad41ddee6157e1f98c26af0740
  stringPathEq1 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.False '`'# -> GHC.Types.True } }) -}
ac1cacfb7d38e56850f736a3238339b6
  strings2idpath :: [GHC.Base.String] -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U> -}
ddbb2fc9ca19aaa1426a0aea8671ab5a
  stripIDPrefix :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct x y -> y
                   LexerTypes.ID i -> LexerTypes.ID i
                   LexerTypes.ID_Vect ipv ipv1 -> BSV2PVS.stripIDPrefix1 }) -}
459b1b9e93213ab837ab680754283e77
  stripIDPrefix1 :: LexerTypes.ID_Path
  {- Strictness: x -}
efd49bff8a8f4ba581135a384a44b342
  substituteActionMethods ::
    LexerTypes.BSVPackage -> LexerTypes.BSVPackage
  {- Arity: 1,
     Strictness: <L,U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: (\ (universe :: LexerTypes.BSVPackage) ->
                 LexerTypes.BSVPackage
                   (LexerTypes.bsv_packageName universe)
                   (LexerTypes.imports universe)
                   (LexerTypes.including universe)
                   (LexerTypes.interfaces universe)
                   (LexerTypes.bsv_constants universe)
                   (LexerTypes.bsv_typedefs universe)
                   (LexerTypes.bsv_instDefs universe)
                   (case universe of wild { LexerTypes.BSVPackage ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ->
                    GHC.Base.map
                      @ LexerTypes.BSVModuleDec
                      @ LexerTypes.BSVModuleDec
                      BSV2PVS.samMod
                      ds8 })
                   (LexerTypes.bsv_functions universe)
                   (LexerTypes.bsv_macros universe)
                   (LexerTypes.hexFiles universe)) -}
fd3f1ead1821c43aabe3163dd59d43ed
  switchToIf ::
    LexerTypes.Guard
    -> [LexerTypes.Case]
    -> [LexerTypes.StatementAttribute]
    -> LexerTypes.Statement
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U> -}
f924ed40f40455a291350a72e9eed55c
  tailID :: LexerTypes.ID_Path -> LexerTypes.ID_Path
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: LexerTypes.ID_Path) ->
                 case ds of wild {
                   LexerTypes.ID_Submod_Struct x y -> y
                   LexerTypes.ID x -> BSV2PVS.tailID2
                   LexerTypes.ID_Vect ipv ipv1 -> BSV2PVS.tailID1 }) -}
c55b9050fdd0d1ba27d4d2f4bc306512
  tailID1 :: LexerTypes.ID_Path
  {- Strictness: x -}
873ad0ba142d861afeb8574d08df5ff9
  tailID2 :: LexerTypes.ID_Path
  {- Strictness: x -}
5c866b6e6e42b4d26d331f0e60f8d9ef
  treefilter ::
    LexerTypes.ID_Path -> LexerTypes.Statement -> LexerTypes.Statement
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
6298e22eeb4d6609dfed2f65d2f2548d
  typos ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> GHC.Base.String
    -> [LexerTypes.PVSType]
  {- Arity: 3,
     Strictness: <S(LLLSLLLLLLL),1*U(A,A,A,1*U,A,A,A,A,A,A,A)><L,1*U(A,A,A,1*U,A,A,A,A,A,A)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: LexerTypes.BSVPackage)
                   (w1 :: LexerTypes.BSVModuleDec)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { LexerTypes.BSVPackage ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ->
                 BSV2PVS.$wtypos ww4 w1 w2 }) -}
06bc1b15754e5b8ca714aeb7aeb3303d
  typos1 ::
    (LexerTypes.Name, LexerTypes.BSVType,
     [LexerTypes.ArgumentAttribute])
    -> LexerTypes.PVSType
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (LexerTypes.Name, LexerTypes.BSVType,
                          [LexerTypes.ArgumentAttribute])) ->
                 case x of wild { (,,) ds t ds1 -> BSV2PVS.b2pType t }) -}
c7b0695e639c62d5fedca1964432ab0a
  typos2 :: LexerTypes.InterfaceDec
  {- Strictness: x -}
36e4f01b352d00c322ce191ba8165fd5
  ultimateModuleFinder ::
    LexerTypes.BSVPackage
    -> LexerTypes.BSVModuleDec
    -> LexerTypes.ID_Path
    -> GHC.Base.Maybe LexerTypes.BSVModuleDec
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,A,A,A,1*U,A,A,A)><L,1*U(1*U,A,1*U,A,A,A,1*U,A,A,A)><S,1*U> -}
f17d76b6963a71a6aac6ac898d85dce5
  unMaybeList :: GHC.Classes.Eq a => [GHC.Base.Maybe a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ @ a (w :: GHC.Classes.Eq a) (w1 :: [GHC.Base.Maybe a]) ->
                 BSV2PVS.$wunMaybeList @ a w1) -}
eabc1579fe5f1bcfbfc99e1959453b0f
  unMaybeList_$sunMaybeList ::
    [GHC.Base.Maybe LexerTypes.RuleDec] -> [LexerTypes.RuleDec]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
eab32ce00ffb5728dad11a1924b209ec
  unMaybeWithDefault :: GHC.Base.Maybe a -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (ds :: GHC.Base.Maybe a) (ds1 :: a) ->
                 case ds of wild {
                   GHC.Base.Nothing -> ds1 GHC.Base.Just x -> x }) -}
65269366bd899780c0328e1e533c4324
  utArg2Arg :: LexerTypes.UTArgs -> [LexerTypes.Argument]
  {- Arity: 1, Strictness: <S,1*U> -}
94c209335df387c491c725c7228d3764
  vectorDecision ::
    [LexerTypes.BSVstateDec]
    -> GHC.Base.String
    -> LexerTypes.Literal
    -> Data.Either.Either LexerTypes.Expression LexerTypes.ID_Path
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: (\ (state :: [LexerTypes.BSVstateDec])
                   (nom :: GHC.Base.String)
                   (lit :: LexerTypes.Literal) ->
                 case GHC.List.elem
                        @ GHC.Base.String
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        nom
                        (BSV2PVS.vectorNames state) of wild {
                   GHC.Types.False
                   -> Data.Either.Left
                        @ LexerTypes.Expression
                        @ LexerTypes.ID_Path
                        (LexerTypes.BitSelect
                           (LexerTypes.Identifier (LexerTypes.ID nom))
                           lit)
                   GHC.Types.True
                   -> Data.Either.Right
                        @ LexerTypes.Expression
                        @ LexerTypes.ID_Path
                        (LexerTypes.ID_Vect nom lit) }) -}
dd1b27e8ea0c382cf70d5d4e798fc8d7
  vectorNames :: [LexerTypes.BSVstateDec] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8da80237ad29ad8af0939296bc0c51e3
  vectorNames' :: [LexerTypes.Argument] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: [LexerTypes.Argument]) ->
                 GHC.Types.[] @ GHC.Base.String) -}
4b08dd9d7724d7d21b9c7f91e9d92c39
  vectorProcess ::
    [LexerTypes.Argument]
    -> LexerTypes.Expression -> LexerTypes.Expression
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: [LexerTypes.Argument]) (w1 :: LexerTypes.Expression) ->
                 BSV2PVS.$wvectorProcess w1) -}
79984ffc61710f74143806319ee2868f
  weirdFold ::
    ([a] -> b -> (b, [a])) -> [a] -> [b] -> ([b], [a]) -> ([b], [a])
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U(1*U,1*U)))><L,U><S,1*U><S,1*U(U,A)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: [a] -> b -> (b, [a]))
                   (w1 :: [a])
                   (w2 :: [b])
                   (w3 :: ([b], [a])) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case BSV2PVS.$wweirdFold
                        @ a
                        @ b
                        w
                        w1
                        w2
                        ww1 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
04eae8b58b574535ddf2942919d8eefb
  winnowRuleSchedules ::
    LexerTypes.ActionPath
    -> [LexerTypes.RuleSchedule] -> [LexerTypes.RuleSchedule]
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: LexerTypes.ActionPath)
                   (rs :: [LexerTypes.RuleSchedule]) ->
                 BSV2PVS.winnowRuleSchedules' x rs rs) -}
24e37865318243fbac97278a90ff41aa
  winnowRuleSchedules' ::
    LexerTypes.ActionPath
    -> [LexerTypes.RuleSchedule]
    -> [LexerTypes.RuleSchedule]
    -> [LexerTypes.RuleSchedule]
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
"SPEC elemWith @ ID_Path" forall ($dEq :: GHC.Classes.Eq
                                            LexerTypes.ID_Path)
  BSV2PVS.elemWith @ LexerTypes.ID_Path $dEq
  = BSV2PVS.elemWith_$selemWith
"SPEC elemWith @ String" forall ($dEq :: GHC.Classes.Eq
                                           GHC.Base.String)
  BSV2PVS.elemWith @ [GHC.Types.Char] $dEq
  = BSV2PVS.elemWith_$selemWith1
"SPEC unMaybeList @ RuleDec" forall ($dEq :: GHC.Classes.Eq
                                               LexerTypes.RuleDec)
  BSV2PVS.unMaybeList @ (LexerTypes.RuleName, LexerTypes.Guard,
                         [LexerTypes.Statement], [LexerTypes.RuleAttribute])
                      $dEq
  = BSV2PVS.unMaybeList_$sunMaybeList
"SPEC/BSV2PVS $fEq(,) @ [Char] @ (Maybe BSVType)" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                           (GHC.Base.Maybe
                                                                              LexerTypes.BSVType))
                                                                  (v :: GHC.Classes.Eq
                                                                          [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char]
                      @ (GHC.Base.Maybe LexerTypes.BSVType)
                      v
                      v1
  = BSV2PVS.$s$fEq(,)
"SPEC/BSV2PVS $fEqMaybe @ BSVType" [orphan] forall (v :: GHC.Classes.Eq
                                                           LexerTypes.BSVType)
  GHC.Base.$fEqMaybe @ LexerTypes.BSVType v
  = BSV2PVS.$s$fEq(,)_$s$fEqMaybe
"SPEC/BSV2PVS $fEqMaybe_$c== @ BSVType" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                   LexerTypes.BSVType)
  GHC.Base.$fEqMaybe_$c== @ LexerTypes.BSVType $dEq
  = BSV2PVS.$s$fEqMaybe_$c==
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

